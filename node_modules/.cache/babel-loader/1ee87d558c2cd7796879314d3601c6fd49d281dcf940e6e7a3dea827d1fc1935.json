{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport Path from 'zrender/lib/graphic/Path';\nimport Group from 'zrender/lib/graphic/Group';\nimport { extend, defaults, each, map } from 'zrender/lib/core/util';\nimport { Rect, Sector, updateProps, initProps, removeElementWithFadeOut } from '../../util/graphic';\nimport { getECData } from '../../util/innerStore';\nimport { enableHoverEmphasis, setStatesStylesFromModel } from '../../util/states';\nimport { setLabelStyle, getLabelStatesModels, setLabelValueAnimation } from '../../label/labelStyle';\nimport { throttle } from '../../util/throttle';\nimport { createClipPath } from '../helper/createClipPathFromCoordSys';\nimport Sausage from '../../util/shape/sausage';\nimport ChartView from '../../view/Chart';\nimport { isCoordinateSystemType } from '../../coord/CoordinateSystem';\nimport { getDefaultLabel, getDefaultInterpolatedLabel } from '../helper/labelHelper';\nimport { warn } from '../../util/log';\nvar _eventPos = [0, 0];\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nfunction getClipArea(coord, data) {\n  var coordSysClipArea = coord.getArea && coord.getArea();\n  if (isCoordinateSystemType(coord, 'cartesian2d')) {\n    var baseAxis = coord.getBaseAxis(); // When boundaryGap is false or using time axis. bar may exceed the grid.\n    // We should not clip this part.\n    // See test/bar2.html\n\n    if (baseAxis.type !== 'category' || !baseAxis.onBand) {\n      var expandWidth = data.getLayout('bandWidth');\n      if (baseAxis.isHorizontal()) {\n        coordSysClipArea.x -= expandWidth;\n        coordSysClipArea.width += expandWidth * 2;\n      } else {\n        coordSysClipArea.y -= expandWidth;\n        coordSysClipArea.height += expandWidth * 2;\n      }\n    }\n  }\n  return coordSysClipArea;\n}\nvar BarView = /** @class */\nfunction (_super) {\n  __extends(BarView, _super);\n  function BarView() {\n    var _this = _super.call(this) || this;\n    _this.type = BarView.type;\n    _this._isFirstFrame = true;\n    return _this;\n  }\n  BarView.prototype.render = function (seriesModel, ecModel, api, payload) {\n    this._model = seriesModel;\n    this._removeOnRenderedListener(api);\n    this._updateDrawMode(seriesModel);\n    var coordinateSystemType = seriesModel.get('coordinateSystem');\n    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn('Only cartesian2d and polar supported for bar.');\n    }\n  };\n  BarView.prototype.incrementalPrepareRender = function (seriesModel) {\n    this._clear();\n    this._updateDrawMode(seriesModel); // incremental also need to clip, otherwise might be overlow.\n    // But must not set clip in each frame, otherwise all of the children will be marked redraw.\n\n    this._updateLargeClip(seriesModel);\n  };\n  BarView.prototype.incrementalRender = function (params, seriesModel) {\n    // Do not support progressive in normal mode.\n    this._incrementalRenderLarge(params, seriesModel);\n  };\n  BarView.prototype._updateDrawMode = function (seriesModel) {\n    var isLargeDraw = seriesModel.pipelineContext.large;\n    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {\n      this._isLargeDraw = isLargeDraw;\n      this._clear();\n    }\n  };\n  BarView.prototype._renderNormal = function (seriesModel, ecModel, api, payload) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coord = seriesModel.coordinateSystem;\n    var baseAxis = coord.getBaseAxis();\n    var isHorizontalOrRadial;\n    if (coord.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n    } else if (coord.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n    }\n    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n    var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);\n    if (realtimeSortCfg) {\n      this._enableRealtimeSort(realtimeSortCfg, data, api);\n    }\n    var needsClip = seriesModel.get('clip', true) || realtimeSortCfg;\n    var coordSysClipArea = getClipArea(coord, data); // If there is clipPath created in large mode. Remove it.\n\n    group.removeClipPath(); // We don't use clipPath in normal mode because we needs a perfect animation\n    // And don't want the label are clipped.\n\n    var roundCap = seriesModel.get('roundCap', true);\n    var drawBackground = seriesModel.get('showBackground', true);\n    var backgroundModel = seriesModel.getModel('backgroundStyle');\n    var barBorderRadius = backgroundModel.get('borderRadius') || 0;\n    var bgEls = [];\n    var oldBgEls = this._backgroundEls;\n    var isInitSort = payload && payload.isInitSort;\n    var isChangeOrder = payload && payload.type === 'changeAxisOrder';\n    function createBackground(dataIndex) {\n      var bgLayout = getLayout[coord.type](data, dataIndex);\n      var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);\n      bgEl.useStyle(backgroundModel.getItemStyle()); // Only cartesian2d support borderRadius.\n\n      if (coord.type === 'cartesian2d') {\n        bgEl.setShape('r', barBorderRadius);\n      }\n      bgEls[dataIndex] = bgEl;\n      return bgEl;\n    }\n    ;\n    data.diff(oldData).add(function (dataIndex) {\n      var itemModel = data.getItemModel(dataIndex);\n      var layout = getLayout[coord.type](data, dataIndex, itemModel);\n      if (drawBackground) {\n        createBackground(dataIndex);\n      } // If dataZoom in filteMode: 'empty', the baseValue can be set as NaN in \"axisProxy\".\n\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n      var isClipped = false;\n      if (needsClip) {\n        // Clip will modify the layout params.\n        // And return a boolean to determine if the shape are fully clipped.\n        isClipped = clip[coord.type](coordSysClipArea, layout);\n      }\n      var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);\n      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n      if (isInitSort) {\n        el.attr({\n          shape: layout\n        });\n      } else if (realtimeSortCfg) {\n        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, dataIndex, isHorizontalOrRadial, false, false);\n      } else {\n        initProps(el, {\n          shape: layout\n        }, seriesModel, dataIndex);\n      }\n      data.setItemGraphicEl(dataIndex, el);\n      group.add(el);\n      el.ignore = isClipped;\n    }).update(function (newIndex, oldIndex) {\n      var itemModel = data.getItemModel(newIndex);\n      var layout = getLayout[coord.type](data, newIndex, itemModel);\n      if (drawBackground) {\n        var bgEl = void 0;\n        if (oldBgEls.length === 0) {\n          bgEl = createBackground(oldIndex);\n        } else {\n          bgEl = oldBgEls[oldIndex];\n          bgEl.useStyle(backgroundModel.getItemStyle()); // Only cartesian2d support borderRadius.\n\n          if (coord.type === 'cartesian2d') {\n            bgEl.setShape('r', barBorderRadius);\n          }\n          bgEls[newIndex] = bgEl;\n        }\n        var bgLayout = getLayout[coord.type](data, newIndex);\n        var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);\n        updateProps(bgEl, {\n          shape: shape\n        }, animationModel, newIndex);\n      }\n      var el = oldData.getItemGraphicEl(oldIndex);\n      if (!data.hasValue(newIndex)) {\n        group.remove(el);\n        el = null;\n        return;\n      }\n      var isClipped = false;\n      if (needsClip) {\n        isClipped = clip[coord.type](coordSysClipArea, layout);\n        if (isClipped) {\n          group.remove(el);\n        }\n      }\n      if (!el) {\n        el = elementCreator[coord.type](seriesModel, data, newIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap);\n      } // Not change anything if only order changed.\n      // Especially not change label.\n\n      if (!isChangeOrder) {\n        updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n      }\n      if (isInitSort) {\n        el.attr({\n          shape: layout\n        });\n      } else if (realtimeSortCfg) {\n        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, newIndex, isHorizontalOrRadial, true, isChangeOrder);\n      } else {\n        updateProps(el, {\n          shape: layout\n        }, seriesModel, newIndex, null);\n      }\n      data.setItemGraphicEl(newIndex, el);\n      el.ignore = isClipped;\n      group.add(el);\n    }).remove(function (dataIndex) {\n      var el = oldData.getItemGraphicEl(dataIndex);\n      el && removeElementWithFadeOut(el, seriesModel, dataIndex);\n    }).execute();\n    var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group());\n    bgGroup.removeAll();\n    for (var i = 0; i < bgEls.length; ++i) {\n      bgGroup.add(bgEls[i]);\n    }\n    group.add(bgGroup);\n    this._backgroundEls = bgEls;\n    this._data = data;\n  };\n  BarView.prototype._renderLarge = function (seriesModel, ecModel, api) {\n    this._clear();\n    createLarge(seriesModel, this.group);\n    this._updateLargeClip(seriesModel);\n  };\n  BarView.prototype._incrementalRenderLarge = function (params, seriesModel) {\n    this._removeBackground();\n    createLarge(seriesModel, this.group, true);\n  };\n  BarView.prototype._updateLargeClip = function (seriesModel) {\n    // Use clipPath in large mode.\n    var clipPath = seriesModel.get('clip', true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;\n    if (clipPath) {\n      this.group.setClipPath(clipPath);\n    } else {\n      this.group.removeClipPath();\n    }\n  };\n  BarView.prototype._enableRealtimeSort = function (realtimeSortCfg, data, api) {\n    var _this = this; // If no data in the first frame, wait for data to initSort\n\n    if (!data.count()) {\n      return;\n    }\n    var baseAxis = realtimeSortCfg.baseAxis;\n    if (this._isFirstFrame) {\n      this._dispatchInitSort(data, realtimeSortCfg, api);\n      this._isFirstFrame = false;\n    } else {\n      var orderMapping_1 = function (idx) {\n        var el = data.getItemGraphicEl(idx);\n        if (el) {\n          var shape = el.shape; // If data is NaN, shape.xxx may be NaN, so use || 0 here in case\n\n          return (baseAxis.isHorizontal() // The result should be consistent with the initial sort by data value.\n          // Do not support the case that both positive and negative exist.\n          ? Math.abs(shape.height) : Math.abs(shape.width)) || 0;\n        } else {\n          return 0;\n        }\n      };\n      this._onRendered = function () {\n        _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api);\n      };\n      api.getZr().on('rendered', this._onRendered);\n    }\n  };\n  BarView.prototype._dataSort = function (data, baseAxis, orderMapping) {\n    var info = [];\n    data.each(data.mapDimension(baseAxis.dim), function (ordinalNumber, dataIdx) {\n      var mappedValue = orderMapping(dataIdx);\n      mappedValue = mappedValue == null ? NaN : mappedValue;\n      info.push({\n        dataIndex: dataIdx,\n        mappedValue: mappedValue,\n        ordinalNumber: ordinalNumber\n      });\n    });\n    info.sort(function (a, b) {\n      // If NaN, it will be treated as min val.\n      return b.mappedValue - a.mappedValue;\n    });\n    return {\n      ordinalNumbers: map(info, function (item) {\n        return item.ordinalNumber;\n      })\n    };\n  };\n  BarView.prototype._isOrderChangedWithinSameData = function (data, orderMapping, baseAxis) {\n    var scale = baseAxis.scale;\n    var ordinalDataDim = data.mapDimension(baseAxis.dim);\n    var lastValue = Number.MAX_VALUE;\n    for (var tickNum = 0, len = scale.getOrdinalMeta().categories.length; tickNum < len; ++tickNum) {\n      var rawIdx = data.rawIndexOf(ordinalDataDim, scale.getRawOrdinalNumber(tickNum));\n      var value = rawIdx < 0 // If some tick have no bar, the tick will be treated as min.\n      ? Number.MIN_VALUE // PENDING: if dataZoom on baseAxis exits, is it a performance issue?\n      : orderMapping(data.indexOfRawIndex(rawIdx));\n      if (value > lastValue) {\n        return true;\n      }\n      lastValue = value;\n    }\n    return false;\n  };\n  /*\n   * Consider the case when A and B changed order, whose representing\n   * bars are both out of sight, we don't wish to trigger reorder action\n   * as long as the order in the view doesn't change.\n   */\n\n  BarView.prototype._isOrderDifferentInView = function (orderInfo, baseAxis) {\n    var scale = baseAxis.scale;\n    var extent = scale.getExtent();\n    var tickNum = Math.max(0, extent[0]);\n    var tickMax = Math.min(extent[1], scale.getOrdinalMeta().categories.length - 1);\n    for (; tickNum <= tickMax; ++tickNum) {\n      if (orderInfo.ordinalNumbers[tickNum] !== scale.getRawOrdinalNumber(tickNum)) {\n        return true;\n      }\n    }\n  };\n  BarView.prototype._updateSortWithinSameData = function (data, orderMapping, baseAxis, api) {\n    if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {\n      return;\n    }\n    var sortInfo = this._dataSort(data, baseAxis, orderMapping);\n    if (this._isOrderDifferentInView(sortInfo, baseAxis)) {\n      this._removeOnRenderedListener(api);\n      api.dispatchAction({\n        type: 'changeAxisOrder',\n        componentType: baseAxis.dim + 'Axis',\n        axisId: baseAxis.index,\n        sortInfo: sortInfo\n      });\n    }\n  };\n  BarView.prototype._dispatchInitSort = function (data, realtimeSortCfg, api) {\n    var baseAxis = realtimeSortCfg.baseAxis;\n    var sortResult = this._dataSort(data, baseAxis, function (dataIdx) {\n      return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);\n    });\n    api.dispatchAction({\n      type: 'changeAxisOrder',\n      componentType: baseAxis.dim + 'Axis',\n      isInitSort: true,\n      axisId: baseAxis.index,\n      sortInfo: sortResult,\n      animation: {\n        // Update the axis label from the natural initial layout to\n        // sorted layout should has no animation.\n        duration: 0\n      }\n    });\n  };\n  BarView.prototype.remove = function (ecModel, api) {\n    this._clear(this._model);\n    this._removeOnRenderedListener(api);\n  };\n  BarView.prototype.dispose = function (ecModel, api) {\n    this._removeOnRenderedListener(api);\n  };\n  BarView.prototype._removeOnRenderedListener = function (api) {\n    if (this._onRendered) {\n      api.getZr().off('rendered', this._onRendered);\n      this._onRendered = null;\n    }\n  };\n  BarView.prototype._clear = function (model) {\n    var group = this.group;\n    var data = this._data;\n    if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {\n      this._removeBackground();\n      this._backgroundEls = [];\n      data.eachItemGraphicEl(function (el) {\n        removeElementWithFadeOut(el, model, getECData(el).dataIndex);\n      });\n    } else {\n      group.removeAll();\n    }\n    this._data = null;\n    this._isFirstFrame = true;\n  };\n  BarView.prototype._removeBackground = function () {\n    this.group.remove(this._backgroundGroup);\n    this._backgroundGroup = null;\n  };\n  BarView.type = 'bar';\n  return BarView;\n}(ChartView);\nvar clip = {\n  cartesian2d: function (coordSysBoundingRect, layout) {\n    var signWidth = layout.width < 0 ? -1 : 1;\n    var signHeight = layout.height < 0 ? -1 : 1; // Needs positive width and height\n\n    if (signWidth < 0) {\n      layout.x += layout.width;\n      layout.width = -layout.width;\n    }\n    if (signHeight < 0) {\n      layout.y += layout.height;\n      layout.height = -layout.height;\n    }\n    var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;\n    var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;\n    var x = mathMax(layout.x, coordSysBoundingRect.x);\n    var x2 = mathMin(layout.x + layout.width, coordSysX2);\n    var y = mathMax(layout.y, coordSysBoundingRect.y);\n    var y2 = mathMin(layout.y + layout.height, coordSysY2);\n    var xClipped = x2 < x;\n    var yClipped = y2 < y; // When xClipped or yClipped, the element will be marked as `ignore`.\n    // But we should also place the element at the edge of the coord sys bounding rect.\n    // Beause if data changed and the bar show again, its transition animaiton\n    // will begin at this place.\n\n    layout.x = xClipped && x > coordSysX2 ? x2 : x;\n    layout.y = yClipped && y > coordSysY2 ? y2 : y;\n    layout.width = xClipped ? 0 : x2 - x;\n    layout.height = yClipped ? 0 : y2 - y; // Reverse back\n\n    if (signWidth < 0) {\n      layout.x += layout.width;\n      layout.width = -layout.width;\n    }\n    if (signHeight < 0) {\n      layout.y += layout.height;\n      layout.height = -layout.height;\n    }\n    return xClipped || yClipped;\n  },\n  polar: function (coordSysClipArea, layout) {\n    var signR = layout.r0 <= layout.r ? 1 : -1; // Make sure r is larger than r0\n\n    if (signR < 0) {\n      var tmp = layout.r;\n      layout.r = layout.r0;\n      layout.r0 = tmp;\n    }\n    var r = mathMin(layout.r, coordSysClipArea.r);\n    var r0 = mathMax(layout.r0, coordSysClipArea.r0);\n    layout.r = r;\n    layout.r0 = r0;\n    var clipped = r - r0 < 0; // Reverse back\n\n    if (signR < 0) {\n      var tmp = layout.r;\n      layout.r = layout.r0;\n      layout.r0 = tmp;\n    }\n    return clipped;\n  }\n};\nvar elementCreator = {\n  cartesian2d: function (seriesModel, data, newIndex, layout, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {\n    var rect = new Rect({\n      shape: extend({}, layout),\n      z2: 1\n    });\n    rect.__dataIndex = newIndex;\n    rect.name = 'item';\n    if (animationModel) {\n      var rectShape = rect.shape;\n      var animateProperty = isHorizontal ? 'height' : 'width';\n      rectShape[animateProperty] = 0;\n    }\n    return rect;\n  },\n  polar: function (seriesModel, data, newIndex, layout, isRadial, animationModel, axisModel, isUpdate, roundCap) {\n    // Keep the same logic with bar in catesion: use end value to control\n    // direction. Notice that if clockwise is true (by default), the sector\n    // will always draw clockwisely, no matter whether endAngle is greater\n    // or less than startAngle.\n    var clockwise = layout.startAngle < layout.endAngle;\n    var ShapeClass = !isRadial && roundCap ? Sausage : Sector;\n    var sector = new ShapeClass({\n      shape: defaults({\n        clockwise: clockwise\n      }, layout),\n      z2: 1\n    });\n    sector.name = 'item'; // Animation\n\n    if (animationModel) {\n      var sectorShape = sector.shape;\n      var animateProperty = isRadial ? 'r' : 'endAngle';\n      var animateTarget = {};\n      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n      animateTarget[animateProperty] = layout[animateProperty];\n      (isUpdate ? updateProps : initProps)(sector, {\n        shape: animateTarget // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue\n      }, animationModel);\n    }\n    return sector;\n  }\n};\nfunction shouldRealtimeSort(seriesModel, coordSys) {\n  var realtimeSortOption = seriesModel.get('realtimeSort', true);\n  var baseAxis = coordSys.getBaseAxis();\n  if (process.env.NODE_ENV !== 'production') {\n    if (realtimeSortOption) {\n      if (baseAxis.type !== 'category') {\n        warn('`realtimeSort` will not work because this bar series is not based on a category axis.');\n      }\n      if (coordSys.type !== 'cartesian2d') {\n        warn('`realtimeSort` will not work because this bar series is not on cartesian2d.');\n      }\n    }\n  }\n  if (realtimeSortOption && baseAxis.type === 'category' && coordSys.type === 'cartesian2d') {\n    return {\n      baseAxis: baseAxis,\n      otherAxis: coordSys.getOtherAxis(baseAxis)\n    };\n  }\n}\nfunction updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout, newIndex, isHorizontal, isUpdate, isChangeOrder) {\n  var seriesTarget;\n  var axisTarget;\n  if (isHorizontal) {\n    axisTarget = {\n      x: layout.x,\n      width: layout.width\n    };\n    seriesTarget = {\n      y: layout.y,\n      height: layout.height\n    };\n  } else {\n    axisTarget = {\n      y: layout.y,\n      height: layout.height\n    };\n    seriesTarget = {\n      x: layout.x,\n      width: layout.width\n    };\n  }\n  if (!isChangeOrder) {\n    // Keep the original growth animation if only axis order changed.\n    // Not start a new animation.\n    (isUpdate ? updateProps : initProps)(el, {\n      shape: seriesTarget\n    }, seriesAnimationModel, newIndex, null);\n  }\n  var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;\n  (isUpdate ? updateProps : initProps)(el, {\n    shape: axisTarget\n  }, axisAnimationModel, newIndex);\n}\nvar getLayout = {\n  // itemModel is only used to get borderWidth, which is not needed\n  // when calculating bar background layout.\n  cartesian2d: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0; // fix layout with lineWidth\n\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n    return {\n      x: layout.x + signX * fixedLineWidth / 2,\n      y: layout.y + signY * fixedLineWidth / 2,\n      width: layout.width - signX * fixedLineWidth,\n      height: layout.height - signY * fixedLineWidth\n    };\n  },\n  polar: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    return {\n      cx: layout.cx,\n      cy: layout.cy,\n      r0: layout.r0,\n      r: layout.r,\n      startAngle: layout.startAngle,\n      endAngle: layout.endAngle\n    };\n  }\n};\nfunction isZeroOnPolar(layout) {\n  return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle;\n}\nfunction updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {\n  var style = data.getItemVisual(dataIndex, 'style');\n  if (!isPolar) {\n    el.setShape('r', itemModel.get(['itemStyle', 'borderRadius']) || 0);\n  }\n  el.useStyle(style);\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && el.attr('cursor', cursorStyle);\n  if (!isPolar) {\n    var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n    var labelStatesModels = getLabelStatesModels(itemModel);\n    setLabelStyle(el, labelStatesModels, {\n      labelFetcher: seriesModel,\n      labelDataIndex: dataIndex,\n      defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),\n      inheritColor: style.fill,\n      defaultOpacity: style.opacity,\n      defaultOutsidePosition: labelPositionOutside\n    });\n    var label = el.getTextContent();\n    setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function (value) {\n      return getDefaultInterpolatedLabel(data, value);\n    });\n  }\n  var emphasisModel = itemModel.getModel(['emphasis']);\n  enableHoverEmphasis(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n  setStatesStylesFromModel(el, itemModel);\n  if (isZeroOnPolar(layout)) {\n    el.style.fill = 'none';\n    el.style.stroke = 'none';\n    each(el.states, function (state) {\n      if (state.style) {\n        state.style.fill = state.style.stroke = 'none';\n      }\n    });\n  }\n} // In case width or height are too small.\n\nfunction getLineWidth(itemModel, rawLayout) {\n  // Has no border.\n  var borderColor = itemModel.get(['itemStyle', 'borderColor']);\n  if (!borderColor || borderColor === 'none') {\n    return 0;\n  }\n  var lineWidth = itemModel.get(['itemStyle', 'borderWidth']) || 0; // width or height may be NaN for empty data\n\n  var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);\n  var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);\n  return Math.min(lineWidth, width, height);\n}\nvar LagePathShape = /** @class */\nfunction () {\n  function LagePathShape() {}\n  return LagePathShape;\n}();\nvar LargePath = /** @class */\nfunction (_super) {\n  __extends(LargePath, _super);\n  function LargePath(opts) {\n    var _this = _super.call(this, opts) || this;\n    _this.type = 'largeBar';\n    return _this;\n  }\n  ;\n  LargePath.prototype.getDefaultShape = function () {\n    return new LagePathShape();\n  };\n  LargePath.prototype.buildPath = function (ctx, shape) {\n    // Drawing lines is more efficient than drawing\n    // a whole line or drawing rects.\n    var points = shape.points;\n    var startPoint = this.__startPoint;\n    var baseDimIdx = this.__baseDimIdx;\n    for (var i = 0; i < points.length; i += 2) {\n      startPoint[baseDimIdx] = points[i + baseDimIdx];\n      ctx.moveTo(startPoint[0], startPoint[1]);\n      ctx.lineTo(points[i], points[i + 1]);\n    }\n  };\n  return LargePath;\n}(Path);\nfunction createLarge(seriesModel, group, incremental) {\n  // TODO support polar\n  var data = seriesModel.getData();\n  var startPoint = [];\n  var baseDimIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;\n  startPoint[1 - baseDimIdx] = data.getLayout('valueAxisStart');\n  var largeDataIndices = data.getLayout('largeDataIndices');\n  var barWidth = data.getLayout('barWidth');\n  var backgroundModel = seriesModel.getModel('backgroundStyle');\n  var drawBackground = seriesModel.get('showBackground', true);\n  if (drawBackground) {\n    var points = data.getLayout('largeBackgroundPoints');\n    var backgroundStartPoint = [];\n    backgroundStartPoint[1 - baseDimIdx] = data.getLayout('backgroundStart');\n    var bgEl = new LargePath({\n      shape: {\n        points: points\n      },\n      incremental: !!incremental,\n      silent: true,\n      z2: 0\n    });\n    bgEl.__startPoint = backgroundStartPoint;\n    bgEl.__baseDimIdx = baseDimIdx;\n    bgEl.__largeDataIndices = largeDataIndices;\n    bgEl.__barWidth = barWidth;\n    setLargeBackgroundStyle(bgEl, backgroundModel, data);\n    group.add(bgEl);\n  }\n  var el = new LargePath({\n    shape: {\n      points: data.getLayout('largePoints')\n    },\n    incremental: !!incremental\n  });\n  el.__startPoint = startPoint;\n  el.__baseDimIdx = baseDimIdx;\n  el.__largeDataIndices = largeDataIndices;\n  el.__barWidth = barWidth;\n  group.add(el);\n  setLargeStyle(el, seriesModel, data); // Enable tooltip and user mouse/touch event handlers.\n\n  getECData(el).seriesIndex = seriesModel.seriesIndex;\n  if (!seriesModel.get('silent')) {\n    el.on('mousedown', largePathUpdateDataIndex);\n    el.on('mousemove', largePathUpdateDataIndex);\n  }\n} // Use throttle to avoid frequently traverse to find dataIndex.\n\nvar largePathUpdateDataIndex = throttle(function (event) {\n  var largePath = this;\n  var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);\n  getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;\n}, 30, false);\nfunction largePathFindDataIndex(largePath, x, y) {\n  var baseDimIdx = largePath.__baseDimIdx;\n  var valueDimIdx = 1 - baseDimIdx;\n  var points = largePath.shape.points;\n  var largeDataIndices = largePath.__largeDataIndices;\n  var barWidthHalf = Math.abs(largePath.__barWidth / 2);\n  var startValueVal = largePath.__startPoint[valueDimIdx];\n  _eventPos[0] = x;\n  _eventPos[1] = y;\n  var pointerBaseVal = _eventPos[baseDimIdx];\n  var pointerValueVal = _eventPos[1 - baseDimIdx];\n  var baseLowerBound = pointerBaseVal - barWidthHalf;\n  var baseUpperBound = pointerBaseVal + barWidthHalf;\n  for (var i = 0, len = points.length / 2; i < len; i++) {\n    var ii = i * 2;\n    var barBaseVal = points[ii + baseDimIdx];\n    var barValueVal = points[ii + valueDimIdx];\n    if (barBaseVal >= baseLowerBound && barBaseVal <= baseUpperBound && (startValueVal <= barValueVal ? pointerValueVal >= startValueVal && pointerValueVal <= barValueVal : pointerValueVal >= barValueVal && pointerValueVal <= startValueVal)) {\n      return largeDataIndices[i];\n    }\n  }\n  return -1;\n}\nfunction setLargeStyle(el, seriesModel, data) {\n  var globalStyle = data.getVisual('style');\n  el.useStyle(extend({}, globalStyle)); // Use stroke instead of fill.\n\n  el.style.fill = null;\n  el.style.stroke = globalStyle.fill;\n  el.style.lineWidth = data.getLayout('barWidth');\n}\nfunction setLargeBackgroundStyle(el, backgroundModel, data) {\n  var borderColor = backgroundModel.get('borderColor') || backgroundModel.get('color');\n  var itemStyle = backgroundModel.getItemStyle();\n  el.useStyle(itemStyle);\n  el.style.fill = null;\n  el.style.stroke = borderColor;\n  el.style.lineWidth = data.getLayout('barWidth');\n}\nfunction createBackgroundShape(isHorizontalOrRadial, layout, coord) {\n  if (isCoordinateSystemType(coord, 'cartesian2d')) {\n    var rectShape = layout;\n    var coordLayout = coord.getArea();\n    return {\n      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,\n      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,\n      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,\n      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height\n    };\n  } else {\n    var coordLayout = coord.getArea();\n    var sectorShape = layout;\n    return {\n      cx: coordLayout.cx,\n      cy: coordLayout.cy,\n      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,\n      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,\n      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,\n      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2\n    };\n  }\n}\nfunction createBackgroundEl(coord, isHorizontalOrRadial, layout) {\n  var ElementClz = coord.type === 'polar' ? Sector : Rect;\n  return new ElementClz({\n    shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),\n    silent: true,\n    z2: 0\n  });\n}\nexport default BarView;","map":{"version":3,"names":["__extends","Path","Group","extend","defaults","each","map","Rect","Sector","updateProps","initProps","removeElementWithFadeOut","getECData","enableHoverEmphasis","setStatesStylesFromModel","setLabelStyle","getLabelStatesModels","setLabelValueAnimation","throttle","createClipPath","Sausage","ChartView","isCoordinateSystemType","getDefaultLabel","getDefaultInterpolatedLabel","warn","_eventPos","mathMax","Math","max","mathMin","min","getClipArea","coord","data","coordSysClipArea","getArea","baseAxis","getBaseAxis","type","onBand","expandWidth","getLayout","isHorizontal","x","width","y","height","BarView","_super","_this","call","_isFirstFrame","prototype","render","seriesModel","ecModel","api","payload","_model","_removeOnRenderedListener","_updateDrawMode","coordinateSystemType","get","_isLargeDraw","_renderLarge","_renderNormal","process","env","NODE_ENV","incrementalPrepareRender","_clear","_updateLargeClip","incrementalRender","params","_incrementalRenderLarge","isLargeDraw","pipelineContext","large","group","getData","oldData","_data","coordinateSystem","isHorizontalOrRadial","dim","animationModel","isAnimationEnabled","realtimeSortCfg","shouldRealtimeSort","_enableRealtimeSort","needsClip","removeClipPath","roundCap","drawBackground","backgroundModel","getModel","barBorderRadius","bgEls","oldBgEls","_backgroundEls","isInitSort","isChangeOrder","createBackground","dataIndex","bgLayout","bgEl","createBackgroundEl","useStyle","getItemStyle","setShape","diff","add","itemModel","getItemModel","layout","hasValue","isClipped","clip","el","elementCreator","model","updateStyle","attr","shape","updateRealtimeAnimation","setItemGraphicEl","ignore","update","newIndex","oldIndex","length","createBackgroundShape","getItemGraphicEl","remove","execute","bgGroup","_backgroundGroup","removeAll","i","createLarge","_removeBackground","clipPath","setClipPath","count","_dispatchInitSort","orderMapping_1","idx","abs","_onRendered","_updateSortWithinSameData","getZr","on","_dataSort","orderMapping","info","mapDimension","ordinalNumber","dataIdx","mappedValue","NaN","push","sort","a","b","ordinalNumbers","item","_isOrderChangedWithinSameData","scale","ordinalDataDim","lastValue","Number","MAX_VALUE","tickNum","len","getOrdinalMeta","categories","rawIdx","rawIndexOf","getRawOrdinalNumber","value","MIN_VALUE","indexOfRawIndex","_isOrderDifferentInView","orderInfo","extent","getExtent","tickMax","sortInfo","dispatchAction","componentType","axisId","index","sortResult","otherAxis","animation","duration","dispose","off","eachItemGraphicEl","cartesian2d","coordSysBoundingRect","signWidth","signHeight","coordSysX2","coordSysY2","x2","y2","xClipped","yClipped","polar","signR","r0","r","tmp","clipped","axisModel","isUpdate","rect","z2","__dataIndex","name","rectShape","animateProperty","isRadial","clockwise","startAngle","endAngle","ShapeClass","sector","sectorShape","animateTarget","coordSys","realtimeSortOption","getOtherAxis","seriesAnimationModel","seriesTarget","axisTarget","axisAnimationModel","getItemLayout","fixedLineWidth","getLineWidth","signX","signY","cx","cy","isZeroOnPolar","isPolar","style","getItemVisual","cursorStyle","getShallow","labelPositionOutside","labelStatesModels","labelFetcher","labelDataIndex","defaultText","inheritColor","fill","defaultOpacity","opacity","defaultOutsidePosition","label","getTextContent","getRawValue","emphasisModel","stroke","states","state","rawLayout","borderColor","lineWidth","isNaN","LagePathShape","LargePath","opts","getDefaultShape","buildPath","ctx","points","startPoint","__startPoint","baseDimIdx","__baseDimIdx","moveTo","lineTo","incremental","largeDataIndices","barWidth","backgroundStartPoint","silent","__largeDataIndices","__barWidth","setLargeBackgroundStyle","setLargeStyle","seriesIndex","largePathUpdateDataIndex","event","largePath","largePathFindDataIndex","offsetX","offsetY","valueDimIdx","barWidthHalf","startValueVal","pointerBaseVal","pointerValueVal","baseLowerBound","baseUpperBound","ii","barBaseVal","barValueVal","globalStyle","getVisual","itemStyle","coordLayout","PI","ElementClz"],"sources":["/Users/jiong/Downloads/my-app/node_modules/echarts/lib/chart/bar/BarView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport Path from 'zrender/lib/graphic/Path';\nimport Group from 'zrender/lib/graphic/Group';\nimport { extend, defaults, each, map } from 'zrender/lib/core/util';\nimport { Rect, Sector, updateProps, initProps, removeElementWithFadeOut } from '../../util/graphic';\nimport { getECData } from '../../util/innerStore';\nimport { enableHoverEmphasis, setStatesStylesFromModel } from '../../util/states';\nimport { setLabelStyle, getLabelStatesModels, setLabelValueAnimation } from '../../label/labelStyle';\nimport { throttle } from '../../util/throttle';\nimport { createClipPath } from '../helper/createClipPathFromCoordSys';\nimport Sausage from '../../util/shape/sausage';\nimport ChartView from '../../view/Chart';\nimport { isCoordinateSystemType } from '../../coord/CoordinateSystem';\nimport { getDefaultLabel, getDefaultInterpolatedLabel } from '../helper/labelHelper';\nimport { warn } from '../../util/log';\nvar _eventPos = [0, 0];\nvar mathMax = Math.max;\nvar mathMin = Math.min;\n\nfunction getClipArea(coord, data) {\n  var coordSysClipArea = coord.getArea && coord.getArea();\n\n  if (isCoordinateSystemType(coord, 'cartesian2d')) {\n    var baseAxis = coord.getBaseAxis(); // When boundaryGap is false or using time axis. bar may exceed the grid.\n    // We should not clip this part.\n    // See test/bar2.html\n\n    if (baseAxis.type !== 'category' || !baseAxis.onBand) {\n      var expandWidth = data.getLayout('bandWidth');\n\n      if (baseAxis.isHorizontal()) {\n        coordSysClipArea.x -= expandWidth;\n        coordSysClipArea.width += expandWidth * 2;\n      } else {\n        coordSysClipArea.y -= expandWidth;\n        coordSysClipArea.height += expandWidth * 2;\n      }\n    }\n  }\n\n  return coordSysClipArea;\n}\n\nvar BarView =\n/** @class */\nfunction (_super) {\n  __extends(BarView, _super);\n\n  function BarView() {\n    var _this = _super.call(this) || this;\n\n    _this.type = BarView.type;\n    _this._isFirstFrame = true;\n    return _this;\n  }\n\n  BarView.prototype.render = function (seriesModel, ecModel, api, payload) {\n    this._model = seriesModel;\n\n    this._removeOnRenderedListener(api);\n\n    this._updateDrawMode(seriesModel);\n\n    var coordinateSystemType = seriesModel.get('coordinateSystem');\n\n    if (coordinateSystemType === 'cartesian2d' || coordinateSystemType === 'polar') {\n      this._isLargeDraw ? this._renderLarge(seriesModel, ecModel, api) : this._renderNormal(seriesModel, ecModel, api, payload);\n    } else if (process.env.NODE_ENV !== 'production') {\n      warn('Only cartesian2d and polar supported for bar.');\n    }\n  };\n\n  BarView.prototype.incrementalPrepareRender = function (seriesModel) {\n    this._clear();\n\n    this._updateDrawMode(seriesModel); // incremental also need to clip, otherwise might be overlow.\n    // But must not set clip in each frame, otherwise all of the children will be marked redraw.\n\n\n    this._updateLargeClip(seriesModel);\n  };\n\n  BarView.prototype.incrementalRender = function (params, seriesModel) {\n    // Do not support progressive in normal mode.\n    this._incrementalRenderLarge(params, seriesModel);\n  };\n\n  BarView.prototype._updateDrawMode = function (seriesModel) {\n    var isLargeDraw = seriesModel.pipelineContext.large;\n\n    if (this._isLargeDraw == null || isLargeDraw !== this._isLargeDraw) {\n      this._isLargeDraw = isLargeDraw;\n\n      this._clear();\n    }\n  };\n\n  BarView.prototype._renderNormal = function (seriesModel, ecModel, api, payload) {\n    var group = this.group;\n    var data = seriesModel.getData();\n    var oldData = this._data;\n    var coord = seriesModel.coordinateSystem;\n    var baseAxis = coord.getBaseAxis();\n    var isHorizontalOrRadial;\n\n    if (coord.type === 'cartesian2d') {\n      isHorizontalOrRadial = baseAxis.isHorizontal();\n    } else if (coord.type === 'polar') {\n      isHorizontalOrRadial = baseAxis.dim === 'angle';\n    }\n\n    var animationModel = seriesModel.isAnimationEnabled() ? seriesModel : null;\n    var realtimeSortCfg = shouldRealtimeSort(seriesModel, coord);\n\n    if (realtimeSortCfg) {\n      this._enableRealtimeSort(realtimeSortCfg, data, api);\n    }\n\n    var needsClip = seriesModel.get('clip', true) || realtimeSortCfg;\n    var coordSysClipArea = getClipArea(coord, data); // If there is clipPath created in large mode. Remove it.\n\n    group.removeClipPath(); // We don't use clipPath in normal mode because we needs a perfect animation\n    // And don't want the label are clipped.\n\n    var roundCap = seriesModel.get('roundCap', true);\n    var drawBackground = seriesModel.get('showBackground', true);\n    var backgroundModel = seriesModel.getModel('backgroundStyle');\n    var barBorderRadius = backgroundModel.get('borderRadius') || 0;\n    var bgEls = [];\n    var oldBgEls = this._backgroundEls;\n    var isInitSort = payload && payload.isInitSort;\n    var isChangeOrder = payload && payload.type === 'changeAxisOrder';\n\n    function createBackground(dataIndex) {\n      var bgLayout = getLayout[coord.type](data, dataIndex);\n      var bgEl = createBackgroundEl(coord, isHorizontalOrRadial, bgLayout);\n      bgEl.useStyle(backgroundModel.getItemStyle()); // Only cartesian2d support borderRadius.\n\n      if (coord.type === 'cartesian2d') {\n        bgEl.setShape('r', barBorderRadius);\n      }\n\n      bgEls[dataIndex] = bgEl;\n      return bgEl;\n    }\n\n    ;\n    data.diff(oldData).add(function (dataIndex) {\n      var itemModel = data.getItemModel(dataIndex);\n      var layout = getLayout[coord.type](data, dataIndex, itemModel);\n\n      if (drawBackground) {\n        createBackground(dataIndex);\n      } // If dataZoom in filteMode: 'empty', the baseValue can be set as NaN in \"axisProxy\".\n\n\n      if (!data.hasValue(dataIndex)) {\n        return;\n      }\n\n      var isClipped = false;\n\n      if (needsClip) {\n        // Clip will modify the layout params.\n        // And return a boolean to determine if the shape are fully clipped.\n        isClipped = clip[coord.type](coordSysClipArea, layout);\n      }\n\n      var el = elementCreator[coord.type](seriesModel, data, dataIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, false, roundCap);\n      updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n\n      if (isInitSort) {\n        el.attr({\n          shape: layout\n        });\n      } else if (realtimeSortCfg) {\n        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, dataIndex, isHorizontalOrRadial, false, false);\n      } else {\n        initProps(el, {\n          shape: layout\n        }, seriesModel, dataIndex);\n      }\n\n      data.setItemGraphicEl(dataIndex, el);\n      group.add(el);\n      el.ignore = isClipped;\n    }).update(function (newIndex, oldIndex) {\n      var itemModel = data.getItemModel(newIndex);\n      var layout = getLayout[coord.type](data, newIndex, itemModel);\n\n      if (drawBackground) {\n        var bgEl = void 0;\n\n        if (oldBgEls.length === 0) {\n          bgEl = createBackground(oldIndex);\n        } else {\n          bgEl = oldBgEls[oldIndex];\n          bgEl.useStyle(backgroundModel.getItemStyle()); // Only cartesian2d support borderRadius.\n\n          if (coord.type === 'cartesian2d') {\n            bgEl.setShape('r', barBorderRadius);\n          }\n\n          bgEls[newIndex] = bgEl;\n        }\n\n        var bgLayout = getLayout[coord.type](data, newIndex);\n        var shape = createBackgroundShape(isHorizontalOrRadial, bgLayout, coord);\n        updateProps(bgEl, {\n          shape: shape\n        }, animationModel, newIndex);\n      }\n\n      var el = oldData.getItemGraphicEl(oldIndex);\n\n      if (!data.hasValue(newIndex)) {\n        group.remove(el);\n        el = null;\n        return;\n      }\n\n      var isClipped = false;\n\n      if (needsClip) {\n        isClipped = clip[coord.type](coordSysClipArea, layout);\n\n        if (isClipped) {\n          group.remove(el);\n        }\n      }\n\n      if (!el) {\n        el = elementCreator[coord.type](seriesModel, data, newIndex, layout, isHorizontalOrRadial, animationModel, baseAxis.model, !!el, roundCap);\n      } // Not change anything if only order changed.\n      // Especially not change label.\n\n\n      if (!isChangeOrder) {\n        updateStyle(el, data, newIndex, itemModel, layout, seriesModel, isHorizontalOrRadial, coord.type === 'polar');\n      }\n\n      if (isInitSort) {\n        el.attr({\n          shape: layout\n        });\n      } else if (realtimeSortCfg) {\n        updateRealtimeAnimation(realtimeSortCfg, animationModel, el, layout, newIndex, isHorizontalOrRadial, true, isChangeOrder);\n      } else {\n        updateProps(el, {\n          shape: layout\n        }, seriesModel, newIndex, null);\n      }\n\n      data.setItemGraphicEl(newIndex, el);\n      el.ignore = isClipped;\n      group.add(el);\n    }).remove(function (dataIndex) {\n      var el = oldData.getItemGraphicEl(dataIndex);\n      el && removeElementWithFadeOut(el, seriesModel, dataIndex);\n    }).execute();\n    var bgGroup = this._backgroundGroup || (this._backgroundGroup = new Group());\n    bgGroup.removeAll();\n\n    for (var i = 0; i < bgEls.length; ++i) {\n      bgGroup.add(bgEls[i]);\n    }\n\n    group.add(bgGroup);\n    this._backgroundEls = bgEls;\n    this._data = data;\n  };\n\n  BarView.prototype._renderLarge = function (seriesModel, ecModel, api) {\n    this._clear();\n\n    createLarge(seriesModel, this.group);\n\n    this._updateLargeClip(seriesModel);\n  };\n\n  BarView.prototype._incrementalRenderLarge = function (params, seriesModel) {\n    this._removeBackground();\n\n    createLarge(seriesModel, this.group, true);\n  };\n\n  BarView.prototype._updateLargeClip = function (seriesModel) {\n    // Use clipPath in large mode.\n    var clipPath = seriesModel.get('clip', true) ? createClipPath(seriesModel.coordinateSystem, false, seriesModel) : null;\n\n    if (clipPath) {\n      this.group.setClipPath(clipPath);\n    } else {\n      this.group.removeClipPath();\n    }\n  };\n\n  BarView.prototype._enableRealtimeSort = function (realtimeSortCfg, data, api) {\n    var _this = this; // If no data in the first frame, wait for data to initSort\n\n\n    if (!data.count()) {\n      return;\n    }\n\n    var baseAxis = realtimeSortCfg.baseAxis;\n\n    if (this._isFirstFrame) {\n      this._dispatchInitSort(data, realtimeSortCfg, api);\n\n      this._isFirstFrame = false;\n    } else {\n      var orderMapping_1 = function (idx) {\n        var el = data.getItemGraphicEl(idx);\n\n        if (el) {\n          var shape = el.shape; // If data is NaN, shape.xxx may be NaN, so use || 0 here in case\n\n          return (baseAxis.isHorizontal() // The result should be consistent with the initial sort by data value.\n          // Do not support the case that both positive and negative exist.\n          ? Math.abs(shape.height) : Math.abs(shape.width)) || 0;\n        } else {\n          return 0;\n        }\n      };\n\n      this._onRendered = function () {\n        _this._updateSortWithinSameData(data, orderMapping_1, baseAxis, api);\n      };\n\n      api.getZr().on('rendered', this._onRendered);\n    }\n  };\n\n  BarView.prototype._dataSort = function (data, baseAxis, orderMapping) {\n    var info = [];\n    data.each(data.mapDimension(baseAxis.dim), function (ordinalNumber, dataIdx) {\n      var mappedValue = orderMapping(dataIdx);\n      mappedValue = mappedValue == null ? NaN : mappedValue;\n      info.push({\n        dataIndex: dataIdx,\n        mappedValue: mappedValue,\n        ordinalNumber: ordinalNumber\n      });\n    });\n    info.sort(function (a, b) {\n      // If NaN, it will be treated as min val.\n      return b.mappedValue - a.mappedValue;\n    });\n    return {\n      ordinalNumbers: map(info, function (item) {\n        return item.ordinalNumber;\n      })\n    };\n  };\n\n  BarView.prototype._isOrderChangedWithinSameData = function (data, orderMapping, baseAxis) {\n    var scale = baseAxis.scale;\n    var ordinalDataDim = data.mapDimension(baseAxis.dim);\n    var lastValue = Number.MAX_VALUE;\n\n    for (var tickNum = 0, len = scale.getOrdinalMeta().categories.length; tickNum < len; ++tickNum) {\n      var rawIdx = data.rawIndexOf(ordinalDataDim, scale.getRawOrdinalNumber(tickNum));\n      var value = rawIdx < 0 // If some tick have no bar, the tick will be treated as min.\n      ? Number.MIN_VALUE // PENDING: if dataZoom on baseAxis exits, is it a performance issue?\n      : orderMapping(data.indexOfRawIndex(rawIdx));\n\n      if (value > lastValue) {\n        return true;\n      }\n\n      lastValue = value;\n    }\n\n    return false;\n  };\n  /*\n   * Consider the case when A and B changed order, whose representing\n   * bars are both out of sight, we don't wish to trigger reorder action\n   * as long as the order in the view doesn't change.\n   */\n\n\n  BarView.prototype._isOrderDifferentInView = function (orderInfo, baseAxis) {\n    var scale = baseAxis.scale;\n    var extent = scale.getExtent();\n    var tickNum = Math.max(0, extent[0]);\n    var tickMax = Math.min(extent[1], scale.getOrdinalMeta().categories.length - 1);\n\n    for (; tickNum <= tickMax; ++tickNum) {\n      if (orderInfo.ordinalNumbers[tickNum] !== scale.getRawOrdinalNumber(tickNum)) {\n        return true;\n      }\n    }\n  };\n\n  BarView.prototype._updateSortWithinSameData = function (data, orderMapping, baseAxis, api) {\n    if (!this._isOrderChangedWithinSameData(data, orderMapping, baseAxis)) {\n      return;\n    }\n\n    var sortInfo = this._dataSort(data, baseAxis, orderMapping);\n\n    if (this._isOrderDifferentInView(sortInfo, baseAxis)) {\n      this._removeOnRenderedListener(api);\n\n      api.dispatchAction({\n        type: 'changeAxisOrder',\n        componentType: baseAxis.dim + 'Axis',\n        axisId: baseAxis.index,\n        sortInfo: sortInfo\n      });\n    }\n  };\n\n  BarView.prototype._dispatchInitSort = function (data, realtimeSortCfg, api) {\n    var baseAxis = realtimeSortCfg.baseAxis;\n\n    var sortResult = this._dataSort(data, baseAxis, function (dataIdx) {\n      return data.get(data.mapDimension(realtimeSortCfg.otherAxis.dim), dataIdx);\n    });\n\n    api.dispatchAction({\n      type: 'changeAxisOrder',\n      componentType: baseAxis.dim + 'Axis',\n      isInitSort: true,\n      axisId: baseAxis.index,\n      sortInfo: sortResult,\n      animation: {\n        // Update the axis label from the natural initial layout to\n        // sorted layout should has no animation.\n        duration: 0\n      }\n    });\n  };\n\n  BarView.prototype.remove = function (ecModel, api) {\n    this._clear(this._model);\n\n    this._removeOnRenderedListener(api);\n  };\n\n  BarView.prototype.dispose = function (ecModel, api) {\n    this._removeOnRenderedListener(api);\n  };\n\n  BarView.prototype._removeOnRenderedListener = function (api) {\n    if (this._onRendered) {\n      api.getZr().off('rendered', this._onRendered);\n      this._onRendered = null;\n    }\n  };\n\n  BarView.prototype._clear = function (model) {\n    var group = this.group;\n    var data = this._data;\n\n    if (model && model.isAnimationEnabled() && data && !this._isLargeDraw) {\n      this._removeBackground();\n\n      this._backgroundEls = [];\n      data.eachItemGraphicEl(function (el) {\n        removeElementWithFadeOut(el, model, getECData(el).dataIndex);\n      });\n    } else {\n      group.removeAll();\n    }\n\n    this._data = null;\n    this._isFirstFrame = true;\n  };\n\n  BarView.prototype._removeBackground = function () {\n    this.group.remove(this._backgroundGroup);\n    this._backgroundGroup = null;\n  };\n\n  BarView.type = 'bar';\n  return BarView;\n}(ChartView);\n\nvar clip = {\n  cartesian2d: function (coordSysBoundingRect, layout) {\n    var signWidth = layout.width < 0 ? -1 : 1;\n    var signHeight = layout.height < 0 ? -1 : 1; // Needs positive width and height\n\n    if (signWidth < 0) {\n      layout.x += layout.width;\n      layout.width = -layout.width;\n    }\n\n    if (signHeight < 0) {\n      layout.y += layout.height;\n      layout.height = -layout.height;\n    }\n\n    var coordSysX2 = coordSysBoundingRect.x + coordSysBoundingRect.width;\n    var coordSysY2 = coordSysBoundingRect.y + coordSysBoundingRect.height;\n    var x = mathMax(layout.x, coordSysBoundingRect.x);\n    var x2 = mathMin(layout.x + layout.width, coordSysX2);\n    var y = mathMax(layout.y, coordSysBoundingRect.y);\n    var y2 = mathMin(layout.y + layout.height, coordSysY2);\n    var xClipped = x2 < x;\n    var yClipped = y2 < y; // When xClipped or yClipped, the element will be marked as `ignore`.\n    // But we should also place the element at the edge of the coord sys bounding rect.\n    // Beause if data changed and the bar show again, its transition animaiton\n    // will begin at this place.\n\n    layout.x = xClipped && x > coordSysX2 ? x2 : x;\n    layout.y = yClipped && y > coordSysY2 ? y2 : y;\n    layout.width = xClipped ? 0 : x2 - x;\n    layout.height = yClipped ? 0 : y2 - y; // Reverse back\n\n    if (signWidth < 0) {\n      layout.x += layout.width;\n      layout.width = -layout.width;\n    }\n\n    if (signHeight < 0) {\n      layout.y += layout.height;\n      layout.height = -layout.height;\n    }\n\n    return xClipped || yClipped;\n  },\n  polar: function (coordSysClipArea, layout) {\n    var signR = layout.r0 <= layout.r ? 1 : -1; // Make sure r is larger than r0\n\n    if (signR < 0) {\n      var tmp = layout.r;\n      layout.r = layout.r0;\n      layout.r0 = tmp;\n    }\n\n    var r = mathMin(layout.r, coordSysClipArea.r);\n    var r0 = mathMax(layout.r0, coordSysClipArea.r0);\n    layout.r = r;\n    layout.r0 = r0;\n    var clipped = r - r0 < 0; // Reverse back\n\n    if (signR < 0) {\n      var tmp = layout.r;\n      layout.r = layout.r0;\n      layout.r0 = tmp;\n    }\n\n    return clipped;\n  }\n};\nvar elementCreator = {\n  cartesian2d: function (seriesModel, data, newIndex, layout, isHorizontal, animationModel, axisModel, isUpdate, roundCap) {\n    var rect = new Rect({\n      shape: extend({}, layout),\n      z2: 1\n    });\n    rect.__dataIndex = newIndex;\n    rect.name = 'item';\n\n    if (animationModel) {\n      var rectShape = rect.shape;\n      var animateProperty = isHorizontal ? 'height' : 'width';\n      rectShape[animateProperty] = 0;\n    }\n\n    return rect;\n  },\n  polar: function (seriesModel, data, newIndex, layout, isRadial, animationModel, axisModel, isUpdate, roundCap) {\n    // Keep the same logic with bar in catesion: use end value to control\n    // direction. Notice that if clockwise is true (by default), the sector\n    // will always draw clockwisely, no matter whether endAngle is greater\n    // or less than startAngle.\n    var clockwise = layout.startAngle < layout.endAngle;\n    var ShapeClass = !isRadial && roundCap ? Sausage : Sector;\n    var sector = new ShapeClass({\n      shape: defaults({\n        clockwise: clockwise\n      }, layout),\n      z2: 1\n    });\n    sector.name = 'item'; // Animation\n\n    if (animationModel) {\n      var sectorShape = sector.shape;\n      var animateProperty = isRadial ? 'r' : 'endAngle';\n      var animateTarget = {};\n      sectorShape[animateProperty] = isRadial ? 0 : layout.startAngle;\n      animateTarget[animateProperty] = layout[animateProperty];\n      (isUpdate ? updateProps : initProps)(sector, {\n        shape: animateTarget // __value: typeof dataValue === 'string' ? parseInt(dataValue, 10) : dataValue\n\n      }, animationModel);\n    }\n\n    return sector;\n  }\n};\n\nfunction shouldRealtimeSort(seriesModel, coordSys) {\n  var realtimeSortOption = seriesModel.get('realtimeSort', true);\n  var baseAxis = coordSys.getBaseAxis();\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (realtimeSortOption) {\n      if (baseAxis.type !== 'category') {\n        warn('`realtimeSort` will not work because this bar series is not based on a category axis.');\n      }\n\n      if (coordSys.type !== 'cartesian2d') {\n        warn('`realtimeSort` will not work because this bar series is not on cartesian2d.');\n      }\n    }\n  }\n\n  if (realtimeSortOption && baseAxis.type === 'category' && coordSys.type === 'cartesian2d') {\n    return {\n      baseAxis: baseAxis,\n      otherAxis: coordSys.getOtherAxis(baseAxis)\n    };\n  }\n}\n\nfunction updateRealtimeAnimation(realtimeSortCfg, seriesAnimationModel, el, layout, newIndex, isHorizontal, isUpdate, isChangeOrder) {\n  var seriesTarget;\n  var axisTarget;\n\n  if (isHorizontal) {\n    axisTarget = {\n      x: layout.x,\n      width: layout.width\n    };\n    seriesTarget = {\n      y: layout.y,\n      height: layout.height\n    };\n  } else {\n    axisTarget = {\n      y: layout.y,\n      height: layout.height\n    };\n    seriesTarget = {\n      x: layout.x,\n      width: layout.width\n    };\n  }\n\n  if (!isChangeOrder) {\n    // Keep the original growth animation if only axis order changed.\n    // Not start a new animation.\n    (isUpdate ? updateProps : initProps)(el, {\n      shape: seriesTarget\n    }, seriesAnimationModel, newIndex, null);\n  }\n\n  var axisAnimationModel = seriesAnimationModel ? realtimeSortCfg.baseAxis.model : null;\n  (isUpdate ? updateProps : initProps)(el, {\n    shape: axisTarget\n  }, axisAnimationModel, newIndex);\n}\n\nvar getLayout = {\n  // itemModel is only used to get borderWidth, which is not needed\n  // when calculating bar background layout.\n  cartesian2d: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    var fixedLineWidth = itemModel ? getLineWidth(itemModel, layout) : 0; // fix layout with lineWidth\n\n    var signX = layout.width > 0 ? 1 : -1;\n    var signY = layout.height > 0 ? 1 : -1;\n    return {\n      x: layout.x + signX * fixedLineWidth / 2,\n      y: layout.y + signY * fixedLineWidth / 2,\n      width: layout.width - signX * fixedLineWidth,\n      height: layout.height - signY * fixedLineWidth\n    };\n  },\n  polar: function (data, dataIndex, itemModel) {\n    var layout = data.getItemLayout(dataIndex);\n    return {\n      cx: layout.cx,\n      cy: layout.cy,\n      r0: layout.r0,\n      r: layout.r,\n      startAngle: layout.startAngle,\n      endAngle: layout.endAngle\n    };\n  }\n};\n\nfunction isZeroOnPolar(layout) {\n  return layout.startAngle != null && layout.endAngle != null && layout.startAngle === layout.endAngle;\n}\n\nfunction updateStyle(el, data, dataIndex, itemModel, layout, seriesModel, isHorizontal, isPolar) {\n  var style = data.getItemVisual(dataIndex, 'style');\n\n  if (!isPolar) {\n    el.setShape('r', itemModel.get(['itemStyle', 'borderRadius']) || 0);\n  }\n\n  el.useStyle(style);\n  var cursorStyle = itemModel.getShallow('cursor');\n  cursorStyle && el.attr('cursor', cursorStyle);\n\n  if (!isPolar) {\n    var labelPositionOutside = isHorizontal ? layout.height > 0 ? 'bottom' : 'top' : layout.width > 0 ? 'left' : 'right';\n    var labelStatesModels = getLabelStatesModels(itemModel);\n    setLabelStyle(el, labelStatesModels, {\n      labelFetcher: seriesModel,\n      labelDataIndex: dataIndex,\n      defaultText: getDefaultLabel(seriesModel.getData(), dataIndex),\n      inheritColor: style.fill,\n      defaultOpacity: style.opacity,\n      defaultOutsidePosition: labelPositionOutside\n    });\n    var label = el.getTextContent();\n    setLabelValueAnimation(label, labelStatesModels, seriesModel.getRawValue(dataIndex), function (value) {\n      return getDefaultInterpolatedLabel(data, value);\n    });\n  }\n\n  var emphasisModel = itemModel.getModel(['emphasis']);\n  enableHoverEmphasis(el, emphasisModel.get('focus'), emphasisModel.get('blurScope'));\n  setStatesStylesFromModel(el, itemModel);\n\n  if (isZeroOnPolar(layout)) {\n    el.style.fill = 'none';\n    el.style.stroke = 'none';\n    each(el.states, function (state) {\n      if (state.style) {\n        state.style.fill = state.style.stroke = 'none';\n      }\n    });\n  }\n} // In case width or height are too small.\n\n\nfunction getLineWidth(itemModel, rawLayout) {\n  // Has no border.\n  var borderColor = itemModel.get(['itemStyle', 'borderColor']);\n\n  if (!borderColor || borderColor === 'none') {\n    return 0;\n  }\n\n  var lineWidth = itemModel.get(['itemStyle', 'borderWidth']) || 0; // width or height may be NaN for empty data\n\n  var width = isNaN(rawLayout.width) ? Number.MAX_VALUE : Math.abs(rawLayout.width);\n  var height = isNaN(rawLayout.height) ? Number.MAX_VALUE : Math.abs(rawLayout.height);\n  return Math.min(lineWidth, width, height);\n}\n\nvar LagePathShape =\n/** @class */\nfunction () {\n  function LagePathShape() {}\n\n  return LagePathShape;\n}();\n\nvar LargePath =\n/** @class */\nfunction (_super) {\n  __extends(LargePath, _super);\n\n  function LargePath(opts) {\n    var _this = _super.call(this, opts) || this;\n\n    _this.type = 'largeBar';\n    return _this;\n  }\n\n  ;\n\n  LargePath.prototype.getDefaultShape = function () {\n    return new LagePathShape();\n  };\n\n  LargePath.prototype.buildPath = function (ctx, shape) {\n    // Drawing lines is more efficient than drawing\n    // a whole line or drawing rects.\n    var points = shape.points;\n    var startPoint = this.__startPoint;\n    var baseDimIdx = this.__baseDimIdx;\n\n    for (var i = 0; i < points.length; i += 2) {\n      startPoint[baseDimIdx] = points[i + baseDimIdx];\n      ctx.moveTo(startPoint[0], startPoint[1]);\n      ctx.lineTo(points[i], points[i + 1]);\n    }\n  };\n\n  return LargePath;\n}(Path);\n\nfunction createLarge(seriesModel, group, incremental) {\n  // TODO support polar\n  var data = seriesModel.getData();\n  var startPoint = [];\n  var baseDimIdx = data.getLayout('valueAxisHorizontal') ? 1 : 0;\n  startPoint[1 - baseDimIdx] = data.getLayout('valueAxisStart');\n  var largeDataIndices = data.getLayout('largeDataIndices');\n  var barWidth = data.getLayout('barWidth');\n  var backgroundModel = seriesModel.getModel('backgroundStyle');\n  var drawBackground = seriesModel.get('showBackground', true);\n\n  if (drawBackground) {\n    var points = data.getLayout('largeBackgroundPoints');\n    var backgroundStartPoint = [];\n    backgroundStartPoint[1 - baseDimIdx] = data.getLayout('backgroundStart');\n    var bgEl = new LargePath({\n      shape: {\n        points: points\n      },\n      incremental: !!incremental,\n      silent: true,\n      z2: 0\n    });\n    bgEl.__startPoint = backgroundStartPoint;\n    bgEl.__baseDimIdx = baseDimIdx;\n    bgEl.__largeDataIndices = largeDataIndices;\n    bgEl.__barWidth = barWidth;\n    setLargeBackgroundStyle(bgEl, backgroundModel, data);\n    group.add(bgEl);\n  }\n\n  var el = new LargePath({\n    shape: {\n      points: data.getLayout('largePoints')\n    },\n    incremental: !!incremental\n  });\n  el.__startPoint = startPoint;\n  el.__baseDimIdx = baseDimIdx;\n  el.__largeDataIndices = largeDataIndices;\n  el.__barWidth = barWidth;\n  group.add(el);\n  setLargeStyle(el, seriesModel, data); // Enable tooltip and user mouse/touch event handlers.\n\n  getECData(el).seriesIndex = seriesModel.seriesIndex;\n\n  if (!seriesModel.get('silent')) {\n    el.on('mousedown', largePathUpdateDataIndex);\n    el.on('mousemove', largePathUpdateDataIndex);\n  }\n} // Use throttle to avoid frequently traverse to find dataIndex.\n\n\nvar largePathUpdateDataIndex = throttle(function (event) {\n  var largePath = this;\n  var dataIndex = largePathFindDataIndex(largePath, event.offsetX, event.offsetY);\n  getECData(largePath).dataIndex = dataIndex >= 0 ? dataIndex : null;\n}, 30, false);\n\nfunction largePathFindDataIndex(largePath, x, y) {\n  var baseDimIdx = largePath.__baseDimIdx;\n  var valueDimIdx = 1 - baseDimIdx;\n  var points = largePath.shape.points;\n  var largeDataIndices = largePath.__largeDataIndices;\n  var barWidthHalf = Math.abs(largePath.__barWidth / 2);\n  var startValueVal = largePath.__startPoint[valueDimIdx];\n  _eventPos[0] = x;\n  _eventPos[1] = y;\n  var pointerBaseVal = _eventPos[baseDimIdx];\n  var pointerValueVal = _eventPos[1 - baseDimIdx];\n  var baseLowerBound = pointerBaseVal - barWidthHalf;\n  var baseUpperBound = pointerBaseVal + barWidthHalf;\n\n  for (var i = 0, len = points.length / 2; i < len; i++) {\n    var ii = i * 2;\n    var barBaseVal = points[ii + baseDimIdx];\n    var barValueVal = points[ii + valueDimIdx];\n\n    if (barBaseVal >= baseLowerBound && barBaseVal <= baseUpperBound && (startValueVal <= barValueVal ? pointerValueVal >= startValueVal && pointerValueVal <= barValueVal : pointerValueVal >= barValueVal && pointerValueVal <= startValueVal)) {\n      return largeDataIndices[i];\n    }\n  }\n\n  return -1;\n}\n\nfunction setLargeStyle(el, seriesModel, data) {\n  var globalStyle = data.getVisual('style');\n  el.useStyle(extend({}, globalStyle)); // Use stroke instead of fill.\n\n  el.style.fill = null;\n  el.style.stroke = globalStyle.fill;\n  el.style.lineWidth = data.getLayout('barWidth');\n}\n\nfunction setLargeBackgroundStyle(el, backgroundModel, data) {\n  var borderColor = backgroundModel.get('borderColor') || backgroundModel.get('color');\n  var itemStyle = backgroundModel.getItemStyle();\n  el.useStyle(itemStyle);\n  el.style.fill = null;\n  el.style.stroke = borderColor;\n  el.style.lineWidth = data.getLayout('barWidth');\n}\n\nfunction createBackgroundShape(isHorizontalOrRadial, layout, coord) {\n  if (isCoordinateSystemType(coord, 'cartesian2d')) {\n    var rectShape = layout;\n    var coordLayout = coord.getArea();\n    return {\n      x: isHorizontalOrRadial ? rectShape.x : coordLayout.x,\n      y: isHorizontalOrRadial ? coordLayout.y : rectShape.y,\n      width: isHorizontalOrRadial ? rectShape.width : coordLayout.width,\n      height: isHorizontalOrRadial ? coordLayout.height : rectShape.height\n    };\n  } else {\n    var coordLayout = coord.getArea();\n    var sectorShape = layout;\n    return {\n      cx: coordLayout.cx,\n      cy: coordLayout.cy,\n      r0: isHorizontalOrRadial ? coordLayout.r0 : sectorShape.r0,\n      r: isHorizontalOrRadial ? coordLayout.r : sectorShape.r,\n      startAngle: isHorizontalOrRadial ? sectorShape.startAngle : 0,\n      endAngle: isHorizontalOrRadial ? sectorShape.endAngle : Math.PI * 2\n    };\n  }\n}\n\nfunction createBackgroundEl(coord, isHorizontalOrRadial, layout) {\n  var ElementClz = coord.type === 'polar' ? Sector : Rect;\n  return new ElementClz({\n    shape: createBackgroundShape(isHorizontalOrRadial, layout, coord),\n    silent: true,\n    z2: 0\n  });\n}\n\nexport default BarView;"],"mappings":";AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,SAAS,QAAQ,OAAO;AACjC,OAAOC,IAAI,MAAM,0BAA0B;AAC3C,OAAOC,KAAK,MAAM,2BAA2B;AAC7C,SAASC,MAAM,EAAEC,QAAQ,EAAEC,IAAI,EAAEC,GAAG,QAAQ,uBAAuB;AACnE,SAASC,IAAI,EAAEC,MAAM,EAAEC,WAAW,EAAEC,SAAS,EAAEC,wBAAwB,QAAQ,oBAAoB;AACnG,SAASC,SAAS,QAAQ,uBAAuB;AACjD,SAASC,mBAAmB,EAAEC,wBAAwB,QAAQ,mBAAmB;AACjF,SAASC,aAAa,EAAEC,oBAAoB,EAAEC,sBAAsB,QAAQ,wBAAwB;AACpG,SAASC,QAAQ,QAAQ,qBAAqB;AAC9C,SAASC,cAAc,QAAQ,sCAAsC;AACrE,OAAOC,OAAO,MAAM,0BAA0B;AAC9C,OAAOC,SAAS,MAAM,kBAAkB;AACxC,SAASC,sBAAsB,QAAQ,8BAA8B;AACrE,SAASC,eAAe,EAAEC,2BAA2B,QAAQ,uBAAuB;AACpF,SAASC,IAAI,QAAQ,gBAAgB;AACrC,IAAIC,SAAS,GAAG,CAAC,CAAC,EAAE,CAAC,CAAC;AACtB,IAAIC,OAAO,GAAGC,IAAI,CAACC,GAAG;AACtB,IAAIC,OAAO,GAAGF,IAAI,CAACG,GAAG;AAEtB,SAASC,WAAW,CAACC,KAAK,EAAEC,IAAI,EAAE;EAChC,IAAIC,gBAAgB,GAAGF,KAAK,CAACG,OAAO,IAAIH,KAAK,CAACG,OAAO,EAAE;EAEvD,IAAId,sBAAsB,CAACW,KAAK,EAAE,aAAa,CAAC,EAAE;IAChD,IAAII,QAAQ,GAAGJ,KAAK,CAACK,WAAW,EAAE,CAAC,CAAC;IACpC;IACA;;IAEA,IAAID,QAAQ,CAACE,IAAI,KAAK,UAAU,IAAI,CAACF,QAAQ,CAACG,MAAM,EAAE;MACpD,IAAIC,WAAW,GAAGP,IAAI,CAACQ,SAAS,CAAC,WAAW,CAAC;MAE7C,IAAIL,QAAQ,CAACM,YAAY,EAAE,EAAE;QAC3BR,gBAAgB,CAACS,CAAC,IAAIH,WAAW;QACjCN,gBAAgB,CAACU,KAAK,IAAIJ,WAAW,GAAG,CAAC;MAC3C,CAAC,MAAM;QACLN,gBAAgB,CAACW,CAAC,IAAIL,WAAW;QACjCN,gBAAgB,CAACY,MAAM,IAAIN,WAAW,GAAG,CAAC;MAC5C;IACF;EACF;EAEA,OAAON,gBAAgB;AACzB;AAEA,IAAIa,OAAO,GACX;AACA,UAAUC,MAAM,EAAE;EAChBjD,SAAS,CAACgD,OAAO,EAAEC,MAAM,CAAC;EAE1B,SAASD,OAAO,GAAG;IACjB,IAAIE,KAAK,GAAGD,MAAM,CAACE,IAAI,CAAC,IAAI,CAAC,IAAI,IAAI;IAErCD,KAAK,CAACX,IAAI,GAAGS,OAAO,CAACT,IAAI;IACzBW,KAAK,CAACE,aAAa,GAAG,IAAI;IAC1B,OAAOF,KAAK;EACd;EAEAF,OAAO,CAACK,SAAS,CAACC,MAAM,GAAG,UAAUC,WAAW,EAAEC,OAAO,EAAEC,GAAG,EAAEC,OAAO,EAAE;IACvE,IAAI,CAACC,MAAM,GAAGJ,WAAW;IAEzB,IAAI,CAACK,yBAAyB,CAACH,GAAG,CAAC;IAEnC,IAAI,CAACI,eAAe,CAACN,WAAW,CAAC;IAEjC,IAAIO,oBAAoB,GAAGP,WAAW,CAACQ,GAAG,CAAC,kBAAkB,CAAC;IAE9D,IAAID,oBAAoB,KAAK,aAAa,IAAIA,oBAAoB,KAAK,OAAO,EAAE;MAC9E,IAAI,CAACE,YAAY,GAAG,IAAI,CAACC,YAAY,CAACV,WAAW,EAAEC,OAAO,EAAEC,GAAG,CAAC,GAAG,IAAI,CAACS,aAAa,CAACX,WAAW,EAAEC,OAAO,EAAEC,GAAG,EAAEC,OAAO,CAAC;IAC3H,CAAC,MAAM,IAAIS,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;MAChD5C,IAAI,CAAC,+CAA+C,CAAC;IACvD;EACF,CAAC;EAEDuB,OAAO,CAACK,SAAS,CAACiB,wBAAwB,GAAG,UAAUf,WAAW,EAAE;IAClE,IAAI,CAACgB,MAAM,EAAE;IAEb,IAAI,CAACV,eAAe,CAACN,WAAW,CAAC,CAAC,CAAC;IACnC;;IAGA,IAAI,CAACiB,gBAAgB,CAACjB,WAAW,CAAC;EACpC,CAAC;EAEDP,OAAO,CAACK,SAAS,CAACoB,iBAAiB,GAAG,UAAUC,MAAM,EAAEnB,WAAW,EAAE;IACnE;IACA,IAAI,CAACoB,uBAAuB,CAACD,MAAM,EAAEnB,WAAW,CAAC;EACnD,CAAC;EAEDP,OAAO,CAACK,SAAS,CAACQ,eAAe,GAAG,UAAUN,WAAW,EAAE;IACzD,IAAIqB,WAAW,GAAGrB,WAAW,CAACsB,eAAe,CAACC,KAAK;IAEnD,IAAI,IAAI,CAACd,YAAY,IAAI,IAAI,IAAIY,WAAW,KAAK,IAAI,CAACZ,YAAY,EAAE;MAClE,IAAI,CAACA,YAAY,GAAGY,WAAW;MAE/B,IAAI,CAACL,MAAM,EAAE;IACf;EACF,CAAC;EAEDvB,OAAO,CAACK,SAAS,CAACa,aAAa,GAAG,UAAUX,WAAW,EAAEC,OAAO,EAAEC,GAAG,EAAEC,OAAO,EAAE;IAC9E,IAAIqB,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAI7C,IAAI,GAAGqB,WAAW,CAACyB,OAAO,EAAE;IAChC,IAAIC,OAAO,GAAG,IAAI,CAACC,KAAK;IACxB,IAAIjD,KAAK,GAAGsB,WAAW,CAAC4B,gBAAgB;IACxC,IAAI9C,QAAQ,GAAGJ,KAAK,CAACK,WAAW,EAAE;IAClC,IAAI8C,oBAAoB;IAExB,IAAInD,KAAK,CAACM,IAAI,KAAK,aAAa,EAAE;MAChC6C,oBAAoB,GAAG/C,QAAQ,CAACM,YAAY,EAAE;IAChD,CAAC,MAAM,IAAIV,KAAK,CAACM,IAAI,KAAK,OAAO,EAAE;MACjC6C,oBAAoB,GAAG/C,QAAQ,CAACgD,GAAG,KAAK,OAAO;IACjD;IAEA,IAAIC,cAAc,GAAG/B,WAAW,CAACgC,kBAAkB,EAAE,GAAGhC,WAAW,GAAG,IAAI;IAC1E,IAAIiC,eAAe,GAAGC,kBAAkB,CAAClC,WAAW,EAAEtB,KAAK,CAAC;IAE5D,IAAIuD,eAAe,EAAE;MACnB,IAAI,CAACE,mBAAmB,CAACF,eAAe,EAAEtD,IAAI,EAAEuB,GAAG,CAAC;IACtD;IAEA,IAAIkC,SAAS,GAAGpC,WAAW,CAACQ,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,IAAIyB,eAAe;IAChE,IAAIrD,gBAAgB,GAAGH,WAAW,CAACC,KAAK,EAAEC,IAAI,CAAC,CAAC,CAAC;;IAEjD6C,KAAK,CAACa,cAAc,EAAE,CAAC,CAAC;IACxB;;IAEA,IAAIC,QAAQ,GAAGtC,WAAW,CAACQ,GAAG,CAAC,UAAU,EAAE,IAAI,CAAC;IAChD,IAAI+B,cAAc,GAAGvC,WAAW,CAACQ,GAAG,CAAC,gBAAgB,EAAE,IAAI,CAAC;IAC5D,IAAIgC,eAAe,GAAGxC,WAAW,CAACyC,QAAQ,CAAC,iBAAiB,CAAC;IAC7D,IAAIC,eAAe,GAAGF,eAAe,CAAChC,GAAG,CAAC,cAAc,CAAC,IAAI,CAAC;IAC9D,IAAImC,KAAK,GAAG,EAAE;IACd,IAAIC,QAAQ,GAAG,IAAI,CAACC,cAAc;IAClC,IAAIC,UAAU,GAAG3C,OAAO,IAAIA,OAAO,CAAC2C,UAAU;IAC9C,IAAIC,aAAa,GAAG5C,OAAO,IAAIA,OAAO,CAACnB,IAAI,KAAK,iBAAiB;IAEjE,SAASgE,gBAAgB,CAACC,SAAS,EAAE;MACnC,IAAIC,QAAQ,GAAG/D,SAAS,CAACT,KAAK,CAACM,IAAI,CAAC,CAACL,IAAI,EAAEsE,SAAS,CAAC;MACrD,IAAIE,IAAI,GAAGC,kBAAkB,CAAC1E,KAAK,EAAEmD,oBAAoB,EAAEqB,QAAQ,CAAC;MACpEC,IAAI,CAACE,QAAQ,CAACb,eAAe,CAACc,YAAY,EAAE,CAAC,CAAC,CAAC;;MAE/C,IAAI5E,KAAK,CAACM,IAAI,KAAK,aAAa,EAAE;QAChCmE,IAAI,CAACI,QAAQ,CAAC,GAAG,EAAEb,eAAe,CAAC;MACrC;MAEAC,KAAK,CAACM,SAAS,CAAC,GAAGE,IAAI;MACvB,OAAOA,IAAI;IACb;IAEA;IACAxE,IAAI,CAAC6E,IAAI,CAAC9B,OAAO,CAAC,CAAC+B,GAAG,CAAC,UAAUR,SAAS,EAAE;MAC1C,IAAIS,SAAS,GAAG/E,IAAI,CAACgF,YAAY,CAACV,SAAS,CAAC;MAC5C,IAAIW,MAAM,GAAGzE,SAAS,CAACT,KAAK,CAACM,IAAI,CAAC,CAACL,IAAI,EAAEsE,SAAS,EAAES,SAAS,CAAC;MAE9D,IAAInB,cAAc,EAAE;QAClBS,gBAAgB,CAACC,SAAS,CAAC;MAC7B,CAAC,CAAC;;MAGF,IAAI,CAACtE,IAAI,CAACkF,QAAQ,CAACZ,SAAS,CAAC,EAAE;QAC7B;MACF;MAEA,IAAIa,SAAS,GAAG,KAAK;MAErB,IAAI1B,SAAS,EAAE;QACb;QACA;QACA0B,SAAS,GAAGC,IAAI,CAACrF,KAAK,CAACM,IAAI,CAAC,CAACJ,gBAAgB,EAAEgF,MAAM,CAAC;MACxD;MAEA,IAAII,EAAE,GAAGC,cAAc,CAACvF,KAAK,CAACM,IAAI,CAAC,CAACgB,WAAW,EAAErB,IAAI,EAAEsE,SAAS,EAAEW,MAAM,EAAE/B,oBAAoB,EAAEE,cAAc,EAAEjD,QAAQ,CAACoF,KAAK,EAAE,KAAK,EAAE5B,QAAQ,CAAC;MAChJ6B,WAAW,CAACH,EAAE,EAAErF,IAAI,EAAEsE,SAAS,EAAES,SAAS,EAAEE,MAAM,EAAE5D,WAAW,EAAE6B,oBAAoB,EAAEnD,KAAK,CAACM,IAAI,KAAK,OAAO,CAAC;MAE9G,IAAI8D,UAAU,EAAE;QACdkB,EAAE,CAACI,IAAI,CAAC;UACNC,KAAK,EAAET;QACT,CAAC,CAAC;MACJ,CAAC,MAAM,IAAI3B,eAAe,EAAE;QAC1BqC,uBAAuB,CAACrC,eAAe,EAAEF,cAAc,EAAEiC,EAAE,EAAEJ,MAAM,EAAEX,SAAS,EAAEpB,oBAAoB,EAAE,KAAK,EAAE,KAAK,CAAC;MACrH,CAAC,MAAM;QACL1E,SAAS,CAAC6G,EAAE,EAAE;UACZK,KAAK,EAAET;QACT,CAAC,EAAE5D,WAAW,EAAEiD,SAAS,CAAC;MAC5B;MAEAtE,IAAI,CAAC4F,gBAAgB,CAACtB,SAAS,EAAEe,EAAE,CAAC;MACpCxC,KAAK,CAACiC,GAAG,CAACO,EAAE,CAAC;MACbA,EAAE,CAACQ,MAAM,GAAGV,SAAS;IACvB,CAAC,CAAC,CAACW,MAAM,CAAC,UAAUC,QAAQ,EAAEC,QAAQ,EAAE;MACtC,IAAIjB,SAAS,GAAG/E,IAAI,CAACgF,YAAY,CAACe,QAAQ,CAAC;MAC3C,IAAId,MAAM,GAAGzE,SAAS,CAACT,KAAK,CAACM,IAAI,CAAC,CAACL,IAAI,EAAE+F,QAAQ,EAAEhB,SAAS,CAAC;MAE7D,IAAInB,cAAc,EAAE;QAClB,IAAIY,IAAI,GAAG,KAAK,CAAC;QAEjB,IAAIP,QAAQ,CAACgC,MAAM,KAAK,CAAC,EAAE;UACzBzB,IAAI,GAAGH,gBAAgB,CAAC2B,QAAQ,CAAC;QACnC,CAAC,MAAM;UACLxB,IAAI,GAAGP,QAAQ,CAAC+B,QAAQ,CAAC;UACzBxB,IAAI,CAACE,QAAQ,CAACb,eAAe,CAACc,YAAY,EAAE,CAAC,CAAC,CAAC;;UAE/C,IAAI5E,KAAK,CAACM,IAAI,KAAK,aAAa,EAAE;YAChCmE,IAAI,CAACI,QAAQ,CAAC,GAAG,EAAEb,eAAe,CAAC;UACrC;UAEAC,KAAK,CAAC+B,QAAQ,CAAC,GAAGvB,IAAI;QACxB;QAEA,IAAID,QAAQ,GAAG/D,SAAS,CAACT,KAAK,CAACM,IAAI,CAAC,CAACL,IAAI,EAAE+F,QAAQ,CAAC;QACpD,IAAIL,KAAK,GAAGQ,qBAAqB,CAAChD,oBAAoB,EAAEqB,QAAQ,EAAExE,KAAK,CAAC;QACxExB,WAAW,CAACiG,IAAI,EAAE;UAChBkB,KAAK,EAAEA;QACT,CAAC,EAAEtC,cAAc,EAAE2C,QAAQ,CAAC;MAC9B;MAEA,IAAIV,EAAE,GAAGtC,OAAO,CAACoD,gBAAgB,CAACH,QAAQ,CAAC;MAE3C,IAAI,CAAChG,IAAI,CAACkF,QAAQ,CAACa,QAAQ,CAAC,EAAE;QAC5BlD,KAAK,CAACuD,MAAM,CAACf,EAAE,CAAC;QAChBA,EAAE,GAAG,IAAI;QACT;MACF;MAEA,IAAIF,SAAS,GAAG,KAAK;MAErB,IAAI1B,SAAS,EAAE;QACb0B,SAAS,GAAGC,IAAI,CAACrF,KAAK,CAACM,IAAI,CAAC,CAACJ,gBAAgB,EAAEgF,MAAM,CAAC;QAEtD,IAAIE,SAAS,EAAE;UACbtC,KAAK,CAACuD,MAAM,CAACf,EAAE,CAAC;QAClB;MACF;MAEA,IAAI,CAACA,EAAE,EAAE;QACPA,EAAE,GAAGC,cAAc,CAACvF,KAAK,CAACM,IAAI,CAAC,CAACgB,WAAW,EAAErB,IAAI,EAAE+F,QAAQ,EAAEd,MAAM,EAAE/B,oBAAoB,EAAEE,cAAc,EAAEjD,QAAQ,CAACoF,KAAK,EAAE,CAAC,CAACF,EAAE,EAAE1B,QAAQ,CAAC;MAC5I,CAAC,CAAC;MACF;;MAGA,IAAI,CAACS,aAAa,EAAE;QAClBoB,WAAW,CAACH,EAAE,EAAErF,IAAI,EAAE+F,QAAQ,EAAEhB,SAAS,EAAEE,MAAM,EAAE5D,WAAW,EAAE6B,oBAAoB,EAAEnD,KAAK,CAACM,IAAI,KAAK,OAAO,CAAC;MAC/G;MAEA,IAAI8D,UAAU,EAAE;QACdkB,EAAE,CAACI,IAAI,CAAC;UACNC,KAAK,EAAET;QACT,CAAC,CAAC;MACJ,CAAC,MAAM,IAAI3B,eAAe,EAAE;QAC1BqC,uBAAuB,CAACrC,eAAe,EAAEF,cAAc,EAAEiC,EAAE,EAAEJ,MAAM,EAAEc,QAAQ,EAAE7C,oBAAoB,EAAE,IAAI,EAAEkB,aAAa,CAAC;MAC3H,CAAC,MAAM;QACL7F,WAAW,CAAC8G,EAAE,EAAE;UACdK,KAAK,EAAET;QACT,CAAC,EAAE5D,WAAW,EAAE0E,QAAQ,EAAE,IAAI,CAAC;MACjC;MAEA/F,IAAI,CAAC4F,gBAAgB,CAACG,QAAQ,EAAEV,EAAE,CAAC;MACnCA,EAAE,CAACQ,MAAM,GAAGV,SAAS;MACrBtC,KAAK,CAACiC,GAAG,CAACO,EAAE,CAAC;IACf,CAAC,CAAC,CAACe,MAAM,CAAC,UAAU9B,SAAS,EAAE;MAC7B,IAAIe,EAAE,GAAGtC,OAAO,CAACoD,gBAAgB,CAAC7B,SAAS,CAAC;MAC5Ce,EAAE,IAAI5G,wBAAwB,CAAC4G,EAAE,EAAEhE,WAAW,EAAEiD,SAAS,CAAC;IAC5D,CAAC,CAAC,CAAC+B,OAAO,EAAE;IACZ,IAAIC,OAAO,GAAG,IAAI,CAACC,gBAAgB,KAAK,IAAI,CAACA,gBAAgB,GAAG,IAAIvI,KAAK,EAAE,CAAC;IAC5EsI,OAAO,CAACE,SAAS,EAAE;IAEnB,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGzC,KAAK,CAACiC,MAAM,EAAE,EAAEQ,CAAC,EAAE;MACrCH,OAAO,CAACxB,GAAG,CAACd,KAAK,CAACyC,CAAC,CAAC,CAAC;IACvB;IAEA5D,KAAK,CAACiC,GAAG,CAACwB,OAAO,CAAC;IAClB,IAAI,CAACpC,cAAc,GAAGF,KAAK;IAC3B,IAAI,CAAChB,KAAK,GAAGhD,IAAI;EACnB,CAAC;EAEDc,OAAO,CAACK,SAAS,CAACY,YAAY,GAAG,UAAUV,WAAW,EAAEC,OAAO,EAAEC,GAAG,EAAE;IACpE,IAAI,CAACc,MAAM,EAAE;IAEbqE,WAAW,CAACrF,WAAW,EAAE,IAAI,CAACwB,KAAK,CAAC;IAEpC,IAAI,CAACP,gBAAgB,CAACjB,WAAW,CAAC;EACpC,CAAC;EAEDP,OAAO,CAACK,SAAS,CAACsB,uBAAuB,GAAG,UAAUD,MAAM,EAAEnB,WAAW,EAAE;IACzE,IAAI,CAACsF,iBAAiB,EAAE;IAExBD,WAAW,CAACrF,WAAW,EAAE,IAAI,CAACwB,KAAK,EAAE,IAAI,CAAC;EAC5C,CAAC;EAED/B,OAAO,CAACK,SAAS,CAACmB,gBAAgB,GAAG,UAAUjB,WAAW,EAAE;IAC1D;IACA,IAAIuF,QAAQ,GAAGvF,WAAW,CAACQ,GAAG,CAAC,MAAM,EAAE,IAAI,CAAC,GAAG5C,cAAc,CAACoC,WAAW,CAAC4B,gBAAgB,EAAE,KAAK,EAAE5B,WAAW,CAAC,GAAG,IAAI;IAEtH,IAAIuF,QAAQ,EAAE;MACZ,IAAI,CAAC/D,KAAK,CAACgE,WAAW,CAACD,QAAQ,CAAC;IAClC,CAAC,MAAM;MACL,IAAI,CAAC/D,KAAK,CAACa,cAAc,EAAE;IAC7B;EACF,CAAC;EAED5C,OAAO,CAACK,SAAS,CAACqC,mBAAmB,GAAG,UAAUF,eAAe,EAAEtD,IAAI,EAAEuB,GAAG,EAAE;IAC5E,IAAIP,KAAK,GAAG,IAAI,CAAC,CAAC;;IAGlB,IAAI,CAAChB,IAAI,CAAC8G,KAAK,EAAE,EAAE;MACjB;IACF;IAEA,IAAI3G,QAAQ,GAAGmD,eAAe,CAACnD,QAAQ;IAEvC,IAAI,IAAI,CAACe,aAAa,EAAE;MACtB,IAAI,CAAC6F,iBAAiB,CAAC/G,IAAI,EAAEsD,eAAe,EAAE/B,GAAG,CAAC;MAElD,IAAI,CAACL,aAAa,GAAG,KAAK;IAC5B,CAAC,MAAM;MACL,IAAI8F,cAAc,GAAG,UAAUC,GAAG,EAAE;QAClC,IAAI5B,EAAE,GAAGrF,IAAI,CAACmG,gBAAgB,CAACc,GAAG,CAAC;QAEnC,IAAI5B,EAAE,EAAE;UACN,IAAIK,KAAK,GAAGL,EAAE,CAACK,KAAK,CAAC,CAAC;;UAEtB,OAAO,CAACvF,QAAQ,CAACM,YAAY,EAAE,CAAC;UAChC;UAAA,EACEf,IAAI,CAACwH,GAAG,CAACxB,KAAK,CAAC7E,MAAM,CAAC,GAAGnB,IAAI,CAACwH,GAAG,CAACxB,KAAK,CAAC/E,KAAK,CAAC,KAAK,CAAC;QACxD,CAAC,MAAM;UACL,OAAO,CAAC;QACV;MACF,CAAC;MAED,IAAI,CAACwG,WAAW,GAAG,YAAY;QAC7BnG,KAAK,CAACoG,yBAAyB,CAACpH,IAAI,EAAEgH,cAAc,EAAE7G,QAAQ,EAAEoB,GAAG,CAAC;MACtE,CAAC;MAEDA,GAAG,CAAC8F,KAAK,EAAE,CAACC,EAAE,CAAC,UAAU,EAAE,IAAI,CAACH,WAAW,CAAC;IAC9C;EACF,CAAC;EAEDrG,OAAO,CAACK,SAAS,CAACoG,SAAS,GAAG,UAAUvH,IAAI,EAAEG,QAAQ,EAAEqH,YAAY,EAAE;IACpE,IAAIC,IAAI,GAAG,EAAE;IACbzH,IAAI,CAAC7B,IAAI,CAAC6B,IAAI,CAAC0H,YAAY,CAACvH,QAAQ,CAACgD,GAAG,CAAC,EAAE,UAAUwE,aAAa,EAAEC,OAAO,EAAE;MAC3E,IAAIC,WAAW,GAAGL,YAAY,CAACI,OAAO,CAAC;MACvCC,WAAW,GAAGA,WAAW,IAAI,IAAI,GAAGC,GAAG,GAAGD,WAAW;MACrDJ,IAAI,CAACM,IAAI,CAAC;QACRzD,SAAS,EAAEsD,OAAO;QAClBC,WAAW,EAAEA,WAAW;QACxBF,aAAa,EAAEA;MACjB,CAAC,CAAC;IACJ,CAAC,CAAC;IACFF,IAAI,CAACO,IAAI,CAAC,UAAUC,CAAC,EAAEC,CAAC,EAAE;MACxB;MACA,OAAOA,CAAC,CAACL,WAAW,GAAGI,CAAC,CAACJ,WAAW;IACtC,CAAC,CAAC;IACF,OAAO;MACLM,cAAc,EAAE/J,GAAG,CAACqJ,IAAI,EAAE,UAAUW,IAAI,EAAE;QACxC,OAAOA,IAAI,CAACT,aAAa;MAC3B,CAAC;IACH,CAAC;EACH,CAAC;EAED7G,OAAO,CAACK,SAAS,CAACkH,6BAA6B,GAAG,UAAUrI,IAAI,EAAEwH,YAAY,EAAErH,QAAQ,EAAE;IACxF,IAAImI,KAAK,GAAGnI,QAAQ,CAACmI,KAAK;IAC1B,IAAIC,cAAc,GAAGvI,IAAI,CAAC0H,YAAY,CAACvH,QAAQ,CAACgD,GAAG,CAAC;IACpD,IAAIqF,SAAS,GAAGC,MAAM,CAACC,SAAS;IAEhC,KAAK,IAAIC,OAAO,GAAG,CAAC,EAAEC,GAAG,GAAGN,KAAK,CAACO,cAAc,EAAE,CAACC,UAAU,CAAC7C,MAAM,EAAE0C,OAAO,GAAGC,GAAG,EAAE,EAAED,OAAO,EAAE;MAC9F,IAAII,MAAM,GAAG/I,IAAI,CAACgJ,UAAU,CAACT,cAAc,EAAED,KAAK,CAACW,mBAAmB,CAACN,OAAO,CAAC,CAAC;MAChF,IAAIO,KAAK,GAAGH,MAAM,GAAG,CAAC,CAAC;MAAA,EACrBN,MAAM,CAACU,SAAS,CAAC;MAAA,EACjB3B,YAAY,CAACxH,IAAI,CAACoJ,eAAe,CAACL,MAAM,CAAC,CAAC;MAE5C,IAAIG,KAAK,GAAGV,SAAS,EAAE;QACrB,OAAO,IAAI;MACb;MAEAA,SAAS,GAAGU,KAAK;IACnB;IAEA,OAAO,KAAK;EACd,CAAC;EACD;AACF;AACA;AACA;AACA;;EAGEpI,OAAO,CAACK,SAAS,CAACkI,uBAAuB,GAAG,UAAUC,SAAS,EAAEnJ,QAAQ,EAAE;IACzE,IAAImI,KAAK,GAAGnI,QAAQ,CAACmI,KAAK;IAC1B,IAAIiB,MAAM,GAAGjB,KAAK,CAACkB,SAAS,EAAE;IAC9B,IAAIb,OAAO,GAAGjJ,IAAI,CAACC,GAAG,CAAC,CAAC,EAAE4J,MAAM,CAAC,CAAC,CAAC,CAAC;IACpC,IAAIE,OAAO,GAAG/J,IAAI,CAACG,GAAG,CAAC0J,MAAM,CAAC,CAAC,CAAC,EAAEjB,KAAK,CAACO,cAAc,EAAE,CAACC,UAAU,CAAC7C,MAAM,GAAG,CAAC,CAAC;IAE/E,OAAO0C,OAAO,IAAIc,OAAO,EAAE,EAAEd,OAAO,EAAE;MACpC,IAAIW,SAAS,CAACnB,cAAc,CAACQ,OAAO,CAAC,KAAKL,KAAK,CAACW,mBAAmB,CAACN,OAAO,CAAC,EAAE;QAC5E,OAAO,IAAI;MACb;IACF;EACF,CAAC;EAED7H,OAAO,CAACK,SAAS,CAACiG,yBAAyB,GAAG,UAAUpH,IAAI,EAAEwH,YAAY,EAAErH,QAAQ,EAAEoB,GAAG,EAAE;IACzF,IAAI,CAAC,IAAI,CAAC8G,6BAA6B,CAACrI,IAAI,EAAEwH,YAAY,EAAErH,QAAQ,CAAC,EAAE;MACrE;IACF;IAEA,IAAIuJ,QAAQ,GAAG,IAAI,CAACnC,SAAS,CAACvH,IAAI,EAAEG,QAAQ,EAAEqH,YAAY,CAAC;IAE3D,IAAI,IAAI,CAAC6B,uBAAuB,CAACK,QAAQ,EAAEvJ,QAAQ,CAAC,EAAE;MACpD,IAAI,CAACuB,yBAAyB,CAACH,GAAG,CAAC;MAEnCA,GAAG,CAACoI,cAAc,CAAC;QACjBtJ,IAAI,EAAE,iBAAiB;QACvBuJ,aAAa,EAAEzJ,QAAQ,CAACgD,GAAG,GAAG,MAAM;QACpC0G,MAAM,EAAE1J,QAAQ,CAAC2J,KAAK;QACtBJ,QAAQ,EAAEA;MACZ,CAAC,CAAC;IACJ;EACF,CAAC;EAED5I,OAAO,CAACK,SAAS,CAAC4F,iBAAiB,GAAG,UAAU/G,IAAI,EAAEsD,eAAe,EAAE/B,GAAG,EAAE;IAC1E,IAAIpB,QAAQ,GAAGmD,eAAe,CAACnD,QAAQ;IAEvC,IAAI4J,UAAU,GAAG,IAAI,CAACxC,SAAS,CAACvH,IAAI,EAAEG,QAAQ,EAAE,UAAUyH,OAAO,EAAE;MACjE,OAAO5H,IAAI,CAAC6B,GAAG,CAAC7B,IAAI,CAAC0H,YAAY,CAACpE,eAAe,CAAC0G,SAAS,CAAC7G,GAAG,CAAC,EAAEyE,OAAO,CAAC;IAC5E,CAAC,CAAC;IAEFrG,GAAG,CAACoI,cAAc,CAAC;MACjBtJ,IAAI,EAAE,iBAAiB;MACvBuJ,aAAa,EAAEzJ,QAAQ,CAACgD,GAAG,GAAG,MAAM;MACpCgB,UAAU,EAAE,IAAI;MAChB0F,MAAM,EAAE1J,QAAQ,CAAC2J,KAAK;MACtBJ,QAAQ,EAAEK,UAAU;MACpBE,SAAS,EAAE;QACT;QACA;QACAC,QAAQ,EAAE;MACZ;IACF,CAAC,CAAC;EACJ,CAAC;EAEDpJ,OAAO,CAACK,SAAS,CAACiF,MAAM,GAAG,UAAU9E,OAAO,EAAEC,GAAG,EAAE;IACjD,IAAI,CAACc,MAAM,CAAC,IAAI,CAACZ,MAAM,CAAC;IAExB,IAAI,CAACC,yBAAyB,CAACH,GAAG,CAAC;EACrC,CAAC;EAEDT,OAAO,CAACK,SAAS,CAACgJ,OAAO,GAAG,UAAU7I,OAAO,EAAEC,GAAG,EAAE;IAClD,IAAI,CAACG,yBAAyB,CAACH,GAAG,CAAC;EACrC,CAAC;EAEDT,OAAO,CAACK,SAAS,CAACO,yBAAyB,GAAG,UAAUH,GAAG,EAAE;IAC3D,IAAI,IAAI,CAAC4F,WAAW,EAAE;MACpB5F,GAAG,CAAC8F,KAAK,EAAE,CAAC+C,GAAG,CAAC,UAAU,EAAE,IAAI,CAACjD,WAAW,CAAC;MAC7C,IAAI,CAACA,WAAW,GAAG,IAAI;IACzB;EACF,CAAC;EAEDrG,OAAO,CAACK,SAAS,CAACkB,MAAM,GAAG,UAAUkD,KAAK,EAAE;IAC1C,IAAI1C,KAAK,GAAG,IAAI,CAACA,KAAK;IACtB,IAAI7C,IAAI,GAAG,IAAI,CAACgD,KAAK;IAErB,IAAIuC,KAAK,IAAIA,KAAK,CAAClC,kBAAkB,EAAE,IAAIrD,IAAI,IAAI,CAAC,IAAI,CAAC8B,YAAY,EAAE;MACrE,IAAI,CAAC6E,iBAAiB,EAAE;MAExB,IAAI,CAACzC,cAAc,GAAG,EAAE;MACxBlE,IAAI,CAACqK,iBAAiB,CAAC,UAAUhF,EAAE,EAAE;QACnC5G,wBAAwB,CAAC4G,EAAE,EAAEE,KAAK,EAAE7G,SAAS,CAAC2G,EAAE,CAAC,CAACf,SAAS,CAAC;MAC9D,CAAC,CAAC;IACJ,CAAC,MAAM;MACLzB,KAAK,CAAC2D,SAAS,EAAE;IACnB;IAEA,IAAI,CAACxD,KAAK,GAAG,IAAI;IACjB,IAAI,CAAC9B,aAAa,GAAG,IAAI;EAC3B,CAAC;EAEDJ,OAAO,CAACK,SAAS,CAACwF,iBAAiB,GAAG,YAAY;IAChD,IAAI,CAAC9D,KAAK,CAACuD,MAAM,CAAC,IAAI,CAACG,gBAAgB,CAAC;IACxC,IAAI,CAACA,gBAAgB,GAAG,IAAI;EAC9B,CAAC;EAEDzF,OAAO,CAACT,IAAI,GAAG,KAAK;EACpB,OAAOS,OAAO;AAChB,CAAC,CAAC3B,SAAS,CAAC;AAEZ,IAAIiG,IAAI,GAAG;EACTkF,WAAW,EAAE,UAAUC,oBAAoB,EAAEtF,MAAM,EAAE;IACnD,IAAIuF,SAAS,GAAGvF,MAAM,CAACtE,KAAK,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC;IACzC,IAAI8J,UAAU,GAAGxF,MAAM,CAACpE,MAAM,GAAG,CAAC,GAAG,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC;;IAE7C,IAAI2J,SAAS,GAAG,CAAC,EAAE;MACjBvF,MAAM,CAACvE,CAAC,IAAIuE,MAAM,CAACtE,KAAK;MACxBsE,MAAM,CAACtE,KAAK,GAAG,CAACsE,MAAM,CAACtE,KAAK;IAC9B;IAEA,IAAI8J,UAAU,GAAG,CAAC,EAAE;MAClBxF,MAAM,CAACrE,CAAC,IAAIqE,MAAM,CAACpE,MAAM;MACzBoE,MAAM,CAACpE,MAAM,GAAG,CAACoE,MAAM,CAACpE,MAAM;IAChC;IAEA,IAAI6J,UAAU,GAAGH,oBAAoB,CAAC7J,CAAC,GAAG6J,oBAAoB,CAAC5J,KAAK;IACpE,IAAIgK,UAAU,GAAGJ,oBAAoB,CAAC3J,CAAC,GAAG2J,oBAAoB,CAAC1J,MAAM;IACrE,IAAIH,CAAC,GAAGjB,OAAO,CAACwF,MAAM,CAACvE,CAAC,EAAE6J,oBAAoB,CAAC7J,CAAC,CAAC;IACjD,IAAIkK,EAAE,GAAGhL,OAAO,CAACqF,MAAM,CAACvE,CAAC,GAAGuE,MAAM,CAACtE,KAAK,EAAE+J,UAAU,CAAC;IACrD,IAAI9J,CAAC,GAAGnB,OAAO,CAACwF,MAAM,CAACrE,CAAC,EAAE2J,oBAAoB,CAAC3J,CAAC,CAAC;IACjD,IAAIiK,EAAE,GAAGjL,OAAO,CAACqF,MAAM,CAACrE,CAAC,GAAGqE,MAAM,CAACpE,MAAM,EAAE8J,UAAU,CAAC;IACtD,IAAIG,QAAQ,GAAGF,EAAE,GAAGlK,CAAC;IACrB,IAAIqK,QAAQ,GAAGF,EAAE,GAAGjK,CAAC,CAAC,CAAC;IACvB;IACA;IACA;;IAEAqE,MAAM,CAACvE,CAAC,GAAGoK,QAAQ,IAAIpK,CAAC,GAAGgK,UAAU,GAAGE,EAAE,GAAGlK,CAAC;IAC9CuE,MAAM,CAACrE,CAAC,GAAGmK,QAAQ,IAAInK,CAAC,GAAG+J,UAAU,GAAGE,EAAE,GAAGjK,CAAC;IAC9CqE,MAAM,CAACtE,KAAK,GAAGmK,QAAQ,GAAG,CAAC,GAAGF,EAAE,GAAGlK,CAAC;IACpCuE,MAAM,CAACpE,MAAM,GAAGkK,QAAQ,GAAG,CAAC,GAAGF,EAAE,GAAGjK,CAAC,CAAC,CAAC;;IAEvC,IAAI4J,SAAS,GAAG,CAAC,EAAE;MACjBvF,MAAM,CAACvE,CAAC,IAAIuE,MAAM,CAACtE,KAAK;MACxBsE,MAAM,CAACtE,KAAK,GAAG,CAACsE,MAAM,CAACtE,KAAK;IAC9B;IAEA,IAAI8J,UAAU,GAAG,CAAC,EAAE;MAClBxF,MAAM,CAACrE,CAAC,IAAIqE,MAAM,CAACpE,MAAM;MACzBoE,MAAM,CAACpE,MAAM,GAAG,CAACoE,MAAM,CAACpE,MAAM;IAChC;IAEA,OAAOiK,QAAQ,IAAIC,QAAQ;EAC7B,CAAC;EACDC,KAAK,EAAE,UAAU/K,gBAAgB,EAAEgF,MAAM,EAAE;IACzC,IAAIgG,KAAK,GAAGhG,MAAM,CAACiG,EAAE,IAAIjG,MAAM,CAACkG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;;IAE5C,IAAIF,KAAK,GAAG,CAAC,EAAE;MACb,IAAIG,GAAG,GAAGnG,MAAM,CAACkG,CAAC;MAClBlG,MAAM,CAACkG,CAAC,GAAGlG,MAAM,CAACiG,EAAE;MACpBjG,MAAM,CAACiG,EAAE,GAAGE,GAAG;IACjB;IAEA,IAAID,CAAC,GAAGvL,OAAO,CAACqF,MAAM,CAACkG,CAAC,EAAElL,gBAAgB,CAACkL,CAAC,CAAC;IAC7C,IAAID,EAAE,GAAGzL,OAAO,CAACwF,MAAM,CAACiG,EAAE,EAAEjL,gBAAgB,CAACiL,EAAE,CAAC;IAChDjG,MAAM,CAACkG,CAAC,GAAGA,CAAC;IACZlG,MAAM,CAACiG,EAAE,GAAGA,EAAE;IACd,IAAIG,OAAO,GAAGF,CAAC,GAAGD,EAAE,GAAG,CAAC,CAAC,CAAC;;IAE1B,IAAID,KAAK,GAAG,CAAC,EAAE;MACb,IAAIG,GAAG,GAAGnG,MAAM,CAACkG,CAAC;MAClBlG,MAAM,CAACkG,CAAC,GAAGlG,MAAM,CAACiG,EAAE;MACpBjG,MAAM,CAACiG,EAAE,GAAGE,GAAG;IACjB;IAEA,OAAOC,OAAO;EAChB;AACF,CAAC;AACD,IAAI/F,cAAc,GAAG;EACnBgF,WAAW,EAAE,UAAUjJ,WAAW,EAAErB,IAAI,EAAE+F,QAAQ,EAAEd,MAAM,EAAExE,YAAY,EAAE2C,cAAc,EAAEkI,SAAS,EAAEC,QAAQ,EAAE5H,QAAQ,EAAE;IACvH,IAAI6H,IAAI,GAAG,IAAInN,IAAI,CAAC;MAClBqH,KAAK,EAAEzH,MAAM,CAAC,CAAC,CAAC,EAAEgH,MAAM,CAAC;MACzBwG,EAAE,EAAE;IACN,CAAC,CAAC;IACFD,IAAI,CAACE,WAAW,GAAG3F,QAAQ;IAC3ByF,IAAI,CAACG,IAAI,GAAG,MAAM;IAElB,IAAIvI,cAAc,EAAE;MAClB,IAAIwI,SAAS,GAAGJ,IAAI,CAAC9F,KAAK;MAC1B,IAAImG,eAAe,GAAGpL,YAAY,GAAG,QAAQ,GAAG,OAAO;MACvDmL,SAAS,CAACC,eAAe,CAAC,GAAG,CAAC;IAChC;IAEA,OAAOL,IAAI;EACb,CAAC;EACDR,KAAK,EAAE,UAAU3J,WAAW,EAAErB,IAAI,EAAE+F,QAAQ,EAAEd,MAAM,EAAE6G,QAAQ,EAAE1I,cAAc,EAAEkI,SAAS,EAAEC,QAAQ,EAAE5H,QAAQ,EAAE;IAC7G;IACA;IACA;IACA;IACA,IAAIoI,SAAS,GAAG9G,MAAM,CAAC+G,UAAU,GAAG/G,MAAM,CAACgH,QAAQ;IACnD,IAAIC,UAAU,GAAG,CAACJ,QAAQ,IAAInI,QAAQ,GAAGzE,OAAO,GAAGZ,MAAM;IACzD,IAAI6N,MAAM,GAAG,IAAID,UAAU,CAAC;MAC1BxG,KAAK,EAAExH,QAAQ,CAAC;QACd6N,SAAS,EAAEA;MACb,CAAC,EAAE9G,MAAM,CAAC;MACVwG,EAAE,EAAE;IACN,CAAC,CAAC;IACFU,MAAM,CAACR,IAAI,GAAG,MAAM,CAAC,CAAC;;IAEtB,IAAIvI,cAAc,EAAE;MAClB,IAAIgJ,WAAW,GAAGD,MAAM,CAACzG,KAAK;MAC9B,IAAImG,eAAe,GAAGC,QAAQ,GAAG,GAAG,GAAG,UAAU;MACjD,IAAIO,aAAa,GAAG,CAAC,CAAC;MACtBD,WAAW,CAACP,eAAe,CAAC,GAAGC,QAAQ,GAAG,CAAC,GAAG7G,MAAM,CAAC+G,UAAU;MAC/DK,aAAa,CAACR,eAAe,CAAC,GAAG5G,MAAM,CAAC4G,eAAe,CAAC;MACxD,CAACN,QAAQ,GAAGhN,WAAW,GAAGC,SAAS,EAAE2N,MAAM,EAAE;QAC3CzG,KAAK,EAAE2G,aAAa,CAAC;MAEvB,CAAC,EAAEjJ,cAAc,CAAC;IACpB;IAEA,OAAO+I,MAAM;EACf;AACF,CAAC;AAED,SAAS5I,kBAAkB,CAAClC,WAAW,EAAEiL,QAAQ,EAAE;EACjD,IAAIC,kBAAkB,GAAGlL,WAAW,CAACQ,GAAG,CAAC,cAAc,EAAE,IAAI,CAAC;EAC9D,IAAI1B,QAAQ,GAAGmM,QAAQ,CAAClM,WAAW,EAAE;EAErC,IAAI6B,OAAO,CAACC,GAAG,CAACC,QAAQ,KAAK,YAAY,EAAE;IACzC,IAAIoK,kBAAkB,EAAE;MACtB,IAAIpM,QAAQ,CAACE,IAAI,KAAK,UAAU,EAAE;QAChCd,IAAI,CAAC,uFAAuF,CAAC;MAC/F;MAEA,IAAI+M,QAAQ,CAACjM,IAAI,KAAK,aAAa,EAAE;QACnCd,IAAI,CAAC,6EAA6E,CAAC;MACrF;IACF;EACF;EAEA,IAAIgN,kBAAkB,IAAIpM,QAAQ,CAACE,IAAI,KAAK,UAAU,IAAIiM,QAAQ,CAACjM,IAAI,KAAK,aAAa,EAAE;IACzF,OAAO;MACLF,QAAQ,EAAEA,QAAQ;MAClB6J,SAAS,EAAEsC,QAAQ,CAACE,YAAY,CAACrM,QAAQ;IAC3C,CAAC;EACH;AACF;AAEA,SAASwF,uBAAuB,CAACrC,eAAe,EAAEmJ,oBAAoB,EAAEpH,EAAE,EAAEJ,MAAM,EAAEc,QAAQ,EAAEtF,YAAY,EAAE8K,QAAQ,EAAEnH,aAAa,EAAE;EACnI,IAAIsI,YAAY;EAChB,IAAIC,UAAU;EAEd,IAAIlM,YAAY,EAAE;IAChBkM,UAAU,GAAG;MACXjM,CAAC,EAAEuE,MAAM,CAACvE,CAAC;MACXC,KAAK,EAAEsE,MAAM,CAACtE;IAChB,CAAC;IACD+L,YAAY,GAAG;MACb9L,CAAC,EAAEqE,MAAM,CAACrE,CAAC;MACXC,MAAM,EAAEoE,MAAM,CAACpE;IACjB,CAAC;EACH,CAAC,MAAM;IACL8L,UAAU,GAAG;MACX/L,CAAC,EAAEqE,MAAM,CAACrE,CAAC;MACXC,MAAM,EAAEoE,MAAM,CAACpE;IACjB,CAAC;IACD6L,YAAY,GAAG;MACbhM,CAAC,EAAEuE,MAAM,CAACvE,CAAC;MACXC,KAAK,EAAEsE,MAAM,CAACtE;IAChB,CAAC;EACH;EAEA,IAAI,CAACyD,aAAa,EAAE;IAClB;IACA;IACA,CAACmH,QAAQ,GAAGhN,WAAW,GAAGC,SAAS,EAAE6G,EAAE,EAAE;MACvCK,KAAK,EAAEgH;IACT,CAAC,EAAED,oBAAoB,EAAE1G,QAAQ,EAAE,IAAI,CAAC;EAC1C;EAEA,IAAI6G,kBAAkB,GAAGH,oBAAoB,GAAGnJ,eAAe,CAACnD,QAAQ,CAACoF,KAAK,GAAG,IAAI;EACrF,CAACgG,QAAQ,GAAGhN,WAAW,GAAGC,SAAS,EAAE6G,EAAE,EAAE;IACvCK,KAAK,EAAEiH;EACT,CAAC,EAAEC,kBAAkB,EAAE7G,QAAQ,CAAC;AAClC;AAEA,IAAIvF,SAAS,GAAG;EACd;EACA;EACA8J,WAAW,EAAE,UAAUtK,IAAI,EAAEsE,SAAS,EAAES,SAAS,EAAE;IACjD,IAAIE,MAAM,GAAGjF,IAAI,CAAC6M,aAAa,CAACvI,SAAS,CAAC;IAC1C,IAAIwI,cAAc,GAAG/H,SAAS,GAAGgI,YAAY,CAAChI,SAAS,EAAEE,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;;IAEtE,IAAI+H,KAAK,GAAG/H,MAAM,CAACtE,KAAK,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACrC,IAAIsM,KAAK,GAAGhI,MAAM,CAACpE,MAAM,GAAG,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;IACtC,OAAO;MACLH,CAAC,EAAEuE,MAAM,CAACvE,CAAC,GAAGsM,KAAK,GAAGF,cAAc,GAAG,CAAC;MACxClM,CAAC,EAAEqE,MAAM,CAACrE,CAAC,GAAGqM,KAAK,GAAGH,cAAc,GAAG,CAAC;MACxCnM,KAAK,EAAEsE,MAAM,CAACtE,KAAK,GAAGqM,KAAK,GAAGF,cAAc;MAC5CjM,MAAM,EAAEoE,MAAM,CAACpE,MAAM,GAAGoM,KAAK,GAAGH;IAClC,CAAC;EACH,CAAC;EACD9B,KAAK,EAAE,UAAUhL,IAAI,EAAEsE,SAAS,EAAES,SAAS,EAAE;IAC3C,IAAIE,MAAM,GAAGjF,IAAI,CAAC6M,aAAa,CAACvI,SAAS,CAAC;IAC1C,OAAO;MACL4I,EAAE,EAAEjI,MAAM,CAACiI,EAAE;MACbC,EAAE,EAAElI,MAAM,CAACkI,EAAE;MACbjC,EAAE,EAAEjG,MAAM,CAACiG,EAAE;MACbC,CAAC,EAAElG,MAAM,CAACkG,CAAC;MACXa,UAAU,EAAE/G,MAAM,CAAC+G,UAAU;MAC7BC,QAAQ,EAAEhH,MAAM,CAACgH;IACnB,CAAC;EACH;AACF,CAAC;AAED,SAASmB,aAAa,CAACnI,MAAM,EAAE;EAC7B,OAAOA,MAAM,CAAC+G,UAAU,IAAI,IAAI,IAAI/G,MAAM,CAACgH,QAAQ,IAAI,IAAI,IAAIhH,MAAM,CAAC+G,UAAU,KAAK/G,MAAM,CAACgH,QAAQ;AACtG;AAEA,SAASzG,WAAW,CAACH,EAAE,EAAErF,IAAI,EAAEsE,SAAS,EAAES,SAAS,EAAEE,MAAM,EAAE5D,WAAW,EAAEZ,YAAY,EAAE4M,OAAO,EAAE;EAC/F,IAAIC,KAAK,GAAGtN,IAAI,CAACuN,aAAa,CAACjJ,SAAS,EAAE,OAAO,CAAC;EAElD,IAAI,CAAC+I,OAAO,EAAE;IACZhI,EAAE,CAACT,QAAQ,CAAC,GAAG,EAAEG,SAAS,CAAClD,GAAG,CAAC,CAAC,WAAW,EAAE,cAAc,CAAC,CAAC,IAAI,CAAC,CAAC;EACrE;EAEAwD,EAAE,CAACX,QAAQ,CAAC4I,KAAK,CAAC;EAClB,IAAIE,WAAW,GAAGzI,SAAS,CAAC0I,UAAU,CAAC,QAAQ,CAAC;EAChDD,WAAW,IAAInI,EAAE,CAACI,IAAI,CAAC,QAAQ,EAAE+H,WAAW,CAAC;EAE7C,IAAI,CAACH,OAAO,EAAE;IACZ,IAAIK,oBAAoB,GAAGjN,YAAY,GAAGwE,MAAM,CAACpE,MAAM,GAAG,CAAC,GAAG,QAAQ,GAAG,KAAK,GAAGoE,MAAM,CAACtE,KAAK,GAAG,CAAC,GAAG,MAAM,GAAG,OAAO;IACpH,IAAIgN,iBAAiB,GAAG7O,oBAAoB,CAACiG,SAAS,CAAC;IACvDlG,aAAa,CAACwG,EAAE,EAAEsI,iBAAiB,EAAE;MACnCC,YAAY,EAAEvM,WAAW;MACzBwM,cAAc,EAAEvJ,SAAS;MACzBwJ,WAAW,EAAEzO,eAAe,CAACgC,WAAW,CAACyB,OAAO,EAAE,EAAEwB,SAAS,CAAC;MAC9DyJ,YAAY,EAAET,KAAK,CAACU,IAAI;MACxBC,cAAc,EAAEX,KAAK,CAACY,OAAO;MAC7BC,sBAAsB,EAAET;IAC1B,CAAC,CAAC;IACF,IAAIU,KAAK,GAAG/I,EAAE,CAACgJ,cAAc,EAAE;IAC/BtP,sBAAsB,CAACqP,KAAK,EAAET,iBAAiB,EAAEtM,WAAW,CAACiN,WAAW,CAAChK,SAAS,CAAC,EAAE,UAAU4E,KAAK,EAAE;MACpG,OAAO5J,2BAA2B,CAACU,IAAI,EAAEkJ,KAAK,CAAC;IACjD,CAAC,CAAC;EACJ;EAEA,IAAIqF,aAAa,GAAGxJ,SAAS,CAACjB,QAAQ,CAAC,CAAC,UAAU,CAAC,CAAC;EACpDnF,mBAAmB,CAAC0G,EAAE,EAAEkJ,aAAa,CAAC1M,GAAG,CAAC,OAAO,CAAC,EAAE0M,aAAa,CAAC1M,GAAG,CAAC,WAAW,CAAC,CAAC;EACnFjD,wBAAwB,CAACyG,EAAE,EAAEN,SAAS,CAAC;EAEvC,IAAIqI,aAAa,CAACnI,MAAM,CAAC,EAAE;IACzBI,EAAE,CAACiI,KAAK,CAACU,IAAI,GAAG,MAAM;IACtB3I,EAAE,CAACiI,KAAK,CAACkB,MAAM,GAAG,MAAM;IACxBrQ,IAAI,CAACkH,EAAE,CAACoJ,MAAM,EAAE,UAAUC,KAAK,EAAE;MAC/B,IAAIA,KAAK,CAACpB,KAAK,EAAE;QACfoB,KAAK,CAACpB,KAAK,CAACU,IAAI,GAAGU,KAAK,CAACpB,KAAK,CAACkB,MAAM,GAAG,MAAM;MAChD;IACF,CAAC,CAAC;EACJ;AACF,CAAC,CAAC;;AAGF,SAASzB,YAAY,CAAChI,SAAS,EAAE4J,SAAS,EAAE;EAC1C;EACA,IAAIC,WAAW,GAAG7J,SAAS,CAAClD,GAAG,CAAC,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC;EAE7D,IAAI,CAAC+M,WAAW,IAAIA,WAAW,KAAK,MAAM,EAAE;IAC1C,OAAO,CAAC;EACV;EAEA,IAAIC,SAAS,GAAG9J,SAAS,CAAClD,GAAG,CAAC,CAAC,WAAW,EAAE,aAAa,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;;EAElE,IAAIlB,KAAK,GAAGmO,KAAK,CAACH,SAAS,CAAChO,KAAK,CAAC,GAAG8H,MAAM,CAACC,SAAS,GAAGhJ,IAAI,CAACwH,GAAG,CAACyH,SAAS,CAAChO,KAAK,CAAC;EACjF,IAAIE,MAAM,GAAGiO,KAAK,CAACH,SAAS,CAAC9N,MAAM,CAAC,GAAG4H,MAAM,CAACC,SAAS,GAAGhJ,IAAI,CAACwH,GAAG,CAACyH,SAAS,CAAC9N,MAAM,CAAC;EACpF,OAAOnB,IAAI,CAACG,GAAG,CAACgP,SAAS,EAAElO,KAAK,EAAEE,MAAM,CAAC;AAC3C;AAEA,IAAIkO,aAAa,GACjB;AACA,YAAY;EACV,SAASA,aAAa,GAAG,CAAC;EAE1B,OAAOA,aAAa;AACtB,CAAC,EAAE;AAEH,IAAIC,SAAS,GACb;AACA,UAAUjO,MAAM,EAAE;EAChBjD,SAAS,CAACkR,SAAS,EAAEjO,MAAM,CAAC;EAE5B,SAASiO,SAAS,CAACC,IAAI,EAAE;IACvB,IAAIjO,KAAK,GAAGD,MAAM,CAACE,IAAI,CAAC,IAAI,EAAEgO,IAAI,CAAC,IAAI,IAAI;IAE3CjO,KAAK,CAACX,IAAI,GAAG,UAAU;IACvB,OAAOW,KAAK;EACd;EAEA;EAEAgO,SAAS,CAAC7N,SAAS,CAAC+N,eAAe,GAAG,YAAY;IAChD,OAAO,IAAIH,aAAa,EAAE;EAC5B,CAAC;EAEDC,SAAS,CAAC7N,SAAS,CAACgO,SAAS,GAAG,UAAUC,GAAG,EAAE1J,KAAK,EAAE;IACpD;IACA;IACA,IAAI2J,MAAM,GAAG3J,KAAK,CAAC2J,MAAM;IACzB,IAAIC,UAAU,GAAG,IAAI,CAACC,YAAY;IAClC,IAAIC,UAAU,GAAG,IAAI,CAACC,YAAY;IAElC,KAAK,IAAIhJ,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAG4I,MAAM,CAACpJ,MAAM,EAAEQ,CAAC,IAAI,CAAC,EAAE;MACzC6I,UAAU,CAACE,UAAU,CAAC,GAAGH,MAAM,CAAC5I,CAAC,GAAG+I,UAAU,CAAC;MAC/CJ,GAAG,CAACM,MAAM,CAACJ,UAAU,CAAC,CAAC,CAAC,EAAEA,UAAU,CAAC,CAAC,CAAC,CAAC;MACxCF,GAAG,CAACO,MAAM,CAACN,MAAM,CAAC5I,CAAC,CAAC,EAAE4I,MAAM,CAAC5I,CAAC,GAAG,CAAC,CAAC,CAAC;IACtC;EACF,CAAC;EAED,OAAOuI,SAAS;AAClB,CAAC,CAACjR,IAAI,CAAC;AAEP,SAAS2I,WAAW,CAACrF,WAAW,EAAEwB,KAAK,EAAE+M,WAAW,EAAE;EACpD;EACA,IAAI5P,IAAI,GAAGqB,WAAW,CAACyB,OAAO,EAAE;EAChC,IAAIwM,UAAU,GAAG,EAAE;EACnB,IAAIE,UAAU,GAAGxP,IAAI,CAACQ,SAAS,CAAC,qBAAqB,CAAC,GAAG,CAAC,GAAG,CAAC;EAC9D8O,UAAU,CAAC,CAAC,GAAGE,UAAU,CAAC,GAAGxP,IAAI,CAACQ,SAAS,CAAC,gBAAgB,CAAC;EAC7D,IAAIqP,gBAAgB,GAAG7P,IAAI,CAACQ,SAAS,CAAC,kBAAkB,CAAC;EACzD,IAAIsP,QAAQ,GAAG9P,IAAI,CAACQ,SAAS,CAAC,UAAU,CAAC;EACzC,IAAIqD,eAAe,GAAGxC,WAAW,CAACyC,QAAQ,CAAC,iBAAiB,CAAC;EAC7D,IAAIF,cAAc,GAAGvC,WAAW,CAACQ,GAAG,CAAC,gBAAgB,EAAE,IAAI,CAAC;EAE5D,IAAI+B,cAAc,EAAE;IAClB,IAAIyL,MAAM,GAAGrP,IAAI,CAACQ,SAAS,CAAC,uBAAuB,CAAC;IACpD,IAAIuP,oBAAoB,GAAG,EAAE;IAC7BA,oBAAoB,CAAC,CAAC,GAAGP,UAAU,CAAC,GAAGxP,IAAI,CAACQ,SAAS,CAAC,iBAAiB,CAAC;IACxE,IAAIgE,IAAI,GAAG,IAAIwK,SAAS,CAAC;MACvBtJ,KAAK,EAAE;QACL2J,MAAM,EAAEA;MACV,CAAC;MACDO,WAAW,EAAE,CAAC,CAACA,WAAW;MAC1BI,MAAM,EAAE,IAAI;MACZvE,EAAE,EAAE;IACN,CAAC,CAAC;IACFjH,IAAI,CAAC+K,YAAY,GAAGQ,oBAAoB;IACxCvL,IAAI,CAACiL,YAAY,GAAGD,UAAU;IAC9BhL,IAAI,CAACyL,kBAAkB,GAAGJ,gBAAgB;IAC1CrL,IAAI,CAAC0L,UAAU,GAAGJ,QAAQ;IAC1BK,uBAAuB,CAAC3L,IAAI,EAAEX,eAAe,EAAE7D,IAAI,CAAC;IACpD6C,KAAK,CAACiC,GAAG,CAACN,IAAI,CAAC;EACjB;EAEA,IAAIa,EAAE,GAAG,IAAI2J,SAAS,CAAC;IACrBtJ,KAAK,EAAE;MACL2J,MAAM,EAAErP,IAAI,CAACQ,SAAS,CAAC,aAAa;IACtC,CAAC;IACDoP,WAAW,EAAE,CAAC,CAACA;EACjB,CAAC,CAAC;EACFvK,EAAE,CAACkK,YAAY,GAAGD,UAAU;EAC5BjK,EAAE,CAACoK,YAAY,GAAGD,UAAU;EAC5BnK,EAAE,CAAC4K,kBAAkB,GAAGJ,gBAAgB;EACxCxK,EAAE,CAAC6K,UAAU,GAAGJ,QAAQ;EACxBjN,KAAK,CAACiC,GAAG,CAACO,EAAE,CAAC;EACb+K,aAAa,CAAC/K,EAAE,EAAEhE,WAAW,EAAErB,IAAI,CAAC,CAAC,CAAC;;EAEtCtB,SAAS,CAAC2G,EAAE,CAAC,CAACgL,WAAW,GAAGhP,WAAW,CAACgP,WAAW;EAEnD,IAAI,CAAChP,WAAW,CAACQ,GAAG,CAAC,QAAQ,CAAC,EAAE;IAC9BwD,EAAE,CAACiC,EAAE,CAAC,WAAW,EAAEgJ,wBAAwB,CAAC;IAC5CjL,EAAE,CAACiC,EAAE,CAAC,WAAW,EAAEgJ,wBAAwB,CAAC;EAC9C;AACF,CAAC,CAAC;;AAGF,IAAIA,wBAAwB,GAAGtR,QAAQ,CAAC,UAAUuR,KAAK,EAAE;EACvD,IAAIC,SAAS,GAAG,IAAI;EACpB,IAAIlM,SAAS,GAAGmM,sBAAsB,CAACD,SAAS,EAAED,KAAK,CAACG,OAAO,EAAEH,KAAK,CAACI,OAAO,CAAC;EAC/EjS,SAAS,CAAC8R,SAAS,CAAC,CAAClM,SAAS,GAAGA,SAAS,IAAI,CAAC,GAAGA,SAAS,GAAG,IAAI;AACpE,CAAC,EAAE,EAAE,EAAE,KAAK,CAAC;AAEb,SAASmM,sBAAsB,CAACD,SAAS,EAAE9P,CAAC,EAAEE,CAAC,EAAE;EAC/C,IAAI4O,UAAU,GAAGgB,SAAS,CAACf,YAAY;EACvC,IAAImB,WAAW,GAAG,CAAC,GAAGpB,UAAU;EAChC,IAAIH,MAAM,GAAGmB,SAAS,CAAC9K,KAAK,CAAC2J,MAAM;EACnC,IAAIQ,gBAAgB,GAAGW,SAAS,CAACP,kBAAkB;EACnD,IAAIY,YAAY,GAAGnR,IAAI,CAACwH,GAAG,CAACsJ,SAAS,CAACN,UAAU,GAAG,CAAC,CAAC;EACrD,IAAIY,aAAa,GAAGN,SAAS,CAACjB,YAAY,CAACqB,WAAW,CAAC;EACvDpR,SAAS,CAAC,CAAC,CAAC,GAAGkB,CAAC;EAChBlB,SAAS,CAAC,CAAC,CAAC,GAAGoB,CAAC;EAChB,IAAImQ,cAAc,GAAGvR,SAAS,CAACgQ,UAAU,CAAC;EAC1C,IAAIwB,eAAe,GAAGxR,SAAS,CAAC,CAAC,GAAGgQ,UAAU,CAAC;EAC/C,IAAIyB,cAAc,GAAGF,cAAc,GAAGF,YAAY;EAClD,IAAIK,cAAc,GAAGH,cAAc,GAAGF,YAAY;EAElD,KAAK,IAAIpK,CAAC,GAAG,CAAC,EAAEmC,GAAG,GAAGyG,MAAM,CAACpJ,MAAM,GAAG,CAAC,EAAEQ,CAAC,GAAGmC,GAAG,EAAEnC,CAAC,EAAE,EAAE;IACrD,IAAI0K,EAAE,GAAG1K,CAAC,GAAG,CAAC;IACd,IAAI2K,UAAU,GAAG/B,MAAM,CAAC8B,EAAE,GAAG3B,UAAU,CAAC;IACxC,IAAI6B,WAAW,GAAGhC,MAAM,CAAC8B,EAAE,GAAGP,WAAW,CAAC;IAE1C,IAAIQ,UAAU,IAAIH,cAAc,IAAIG,UAAU,IAAIF,cAAc,KAAKJ,aAAa,IAAIO,WAAW,GAAGL,eAAe,IAAIF,aAAa,IAAIE,eAAe,IAAIK,WAAW,GAAGL,eAAe,IAAIK,WAAW,IAAIL,eAAe,IAAIF,aAAa,CAAC,EAAE;MAC5O,OAAOjB,gBAAgB,CAACpJ,CAAC,CAAC;IAC5B;EACF;EAEA,OAAO,CAAC,CAAC;AACX;AAEA,SAAS2J,aAAa,CAAC/K,EAAE,EAAEhE,WAAW,EAAErB,IAAI,EAAE;EAC5C,IAAIsR,WAAW,GAAGtR,IAAI,CAACuR,SAAS,CAAC,OAAO,CAAC;EACzClM,EAAE,CAACX,QAAQ,CAACzG,MAAM,CAAC,CAAC,CAAC,EAAEqT,WAAW,CAAC,CAAC,CAAC,CAAC;;EAEtCjM,EAAE,CAACiI,KAAK,CAACU,IAAI,GAAG,IAAI;EACpB3I,EAAE,CAACiI,KAAK,CAACkB,MAAM,GAAG8C,WAAW,CAACtD,IAAI;EAClC3I,EAAE,CAACiI,KAAK,CAACuB,SAAS,GAAG7O,IAAI,CAACQ,SAAS,CAAC,UAAU,CAAC;AACjD;AAEA,SAAS2P,uBAAuB,CAAC9K,EAAE,EAAExB,eAAe,EAAE7D,IAAI,EAAE;EAC1D,IAAI4O,WAAW,GAAG/K,eAAe,CAAChC,GAAG,CAAC,aAAa,CAAC,IAAIgC,eAAe,CAAChC,GAAG,CAAC,OAAO,CAAC;EACpF,IAAI2P,SAAS,GAAG3N,eAAe,CAACc,YAAY,EAAE;EAC9CU,EAAE,CAACX,QAAQ,CAAC8M,SAAS,CAAC;EACtBnM,EAAE,CAACiI,KAAK,CAACU,IAAI,GAAG,IAAI;EACpB3I,EAAE,CAACiI,KAAK,CAACkB,MAAM,GAAGI,WAAW;EAC7BvJ,EAAE,CAACiI,KAAK,CAACuB,SAAS,GAAG7O,IAAI,CAACQ,SAAS,CAAC,UAAU,CAAC;AACjD;AAEA,SAAS0F,qBAAqB,CAAChD,oBAAoB,EAAE+B,MAAM,EAAElF,KAAK,EAAE;EAClE,IAAIX,sBAAsB,CAACW,KAAK,EAAE,aAAa,CAAC,EAAE;IAChD,IAAI6L,SAAS,GAAG3G,MAAM;IACtB,IAAIwM,WAAW,GAAG1R,KAAK,CAACG,OAAO,EAAE;IACjC,OAAO;MACLQ,CAAC,EAAEwC,oBAAoB,GAAG0I,SAAS,CAAClL,CAAC,GAAG+Q,WAAW,CAAC/Q,CAAC;MACrDE,CAAC,EAAEsC,oBAAoB,GAAGuO,WAAW,CAAC7Q,CAAC,GAAGgL,SAAS,CAAChL,CAAC;MACrDD,KAAK,EAAEuC,oBAAoB,GAAG0I,SAAS,CAACjL,KAAK,GAAG8Q,WAAW,CAAC9Q,KAAK;MACjEE,MAAM,EAAEqC,oBAAoB,GAAGuO,WAAW,CAAC5Q,MAAM,GAAG+K,SAAS,CAAC/K;IAChE,CAAC;EACH,CAAC,MAAM;IACL,IAAI4Q,WAAW,GAAG1R,KAAK,CAACG,OAAO,EAAE;IACjC,IAAIkM,WAAW,GAAGnH,MAAM;IACxB,OAAO;MACLiI,EAAE,EAAEuE,WAAW,CAACvE,EAAE;MAClBC,EAAE,EAAEsE,WAAW,CAACtE,EAAE;MAClBjC,EAAE,EAAEhI,oBAAoB,GAAGuO,WAAW,CAACvG,EAAE,GAAGkB,WAAW,CAAClB,EAAE;MAC1DC,CAAC,EAAEjI,oBAAoB,GAAGuO,WAAW,CAACtG,CAAC,GAAGiB,WAAW,CAACjB,CAAC;MACvDa,UAAU,EAAE9I,oBAAoB,GAAGkJ,WAAW,CAACJ,UAAU,GAAG,CAAC;MAC7DC,QAAQ,EAAE/I,oBAAoB,GAAGkJ,WAAW,CAACH,QAAQ,GAAGvM,IAAI,CAACgS,EAAE,GAAG;IACpE,CAAC;EACH;AACF;AAEA,SAASjN,kBAAkB,CAAC1E,KAAK,EAAEmD,oBAAoB,EAAE+B,MAAM,EAAE;EAC/D,IAAI0M,UAAU,GAAG5R,KAAK,CAACM,IAAI,KAAK,OAAO,GAAG/B,MAAM,GAAGD,IAAI;EACvD,OAAO,IAAIsT,UAAU,CAAC;IACpBjM,KAAK,EAAEQ,qBAAqB,CAAChD,oBAAoB,EAAE+B,MAAM,EAAElF,KAAK,CAAC;IACjEiQ,MAAM,EAAE,IAAI;IACZvE,EAAE,EAAE;EACN,CAAC,CAAC;AACJ;AAEA,eAAe3K,OAAO"},"metadata":{},"sourceType":"module","externalDependencies":[]}