{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport BoundingRect from 'zrender/lib/core/BoundingRect';\nimport * as bbox from 'zrender/lib/core/bbox';\nimport * as vec2 from 'zrender/lib/core/vector';\nimport * as polygonContain from 'zrender/lib/contain/polygon';\nimport * as matrix from 'zrender/lib/core/matrix';\nvar TMP_TRANSFORM = [];\nvar Region = /** @class */\nfunction () {\n  function Region(name) {\n    this.name = name;\n  }\n  /**\n   * Get center point in data unit. That is,\n   * for GeoJSONRegion, the unit is lat/lng,\n   * for GeoSVGRegion, the unit is SVG local coord.\n   */\n\n  Region.prototype.getCenter = function () {\n    return;\n  };\n  return Region;\n}();\nexport { Region };\nvar GeoJSONRegion = /** @class */\nfunction (_super) {\n  __extends(GeoJSONRegion, _super);\n  function GeoJSONRegion(name, geometries, cp) {\n    var _this = _super.call(this, name) || this;\n    _this.type = 'geoJSON';\n    _this.geometries = geometries;\n    if (!cp) {\n      var rect = _this.getBoundingRect();\n      cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n    } else {\n      cp = [cp[0], cp[1]];\n    }\n    _this._center = cp;\n    return _this;\n  }\n  GeoJSONRegion.prototype.getBoundingRect = function () {\n    var rect = this._rect;\n    if (rect) {\n      return rect;\n    }\n    var MAX_NUMBER = Number.MAX_VALUE;\n    var min = [MAX_NUMBER, MAX_NUMBER];\n    var max = [-MAX_NUMBER, -MAX_NUMBER];\n    var min2 = [];\n    var max2 = [];\n    var geometries = this.geometries;\n    var i = 0;\n    for (; i < geometries.length; i++) {\n      // Only support polygon\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      } // Doesn't consider hole\n\n      var exterior = geometries[i].exterior;\n      bbox.fromPoints(exterior, min2, max2);\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n    return this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  };\n  GeoJSONRegion.prototype.contain = function (coord) {\n    var rect = this.getBoundingRect();\n    var geometries = this.geometries;\n    if (!rect.contain(coord[0], coord[1])) {\n      return false;\n    }\n    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {\n      // Only support polygon.\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      }\n      var exterior = geometries[i].exterior;\n      var interiors = geometries[i].interiors;\n      if (polygonContain.contain(exterior, coord[0], coord[1])) {\n        // Not in the region if point is in the hole.\n        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {\n          if (polygonContain.contain(interiors[k], coord[0], coord[1])) {\n            continue loopGeo;\n          }\n        }\n        return true;\n      }\n    }\n    return false;\n  };\n  GeoJSONRegion.prototype.transformTo = function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var aspect = rect.width / rect.height;\n    if (!width) {\n      width = aspect * height;\n    } else if (!height) {\n      height = width / aspect;\n    }\n    var target = new BoundingRect(x, y, width, height);\n    var transform = rect.calculateTransform(target);\n    var geometries = this.geometries;\n    for (var i = 0; i < geometries.length; i++) {\n      // Only support polygon.\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      }\n      var exterior = geometries[i].exterior;\n      var interiors = geometries[i].interiors;\n      for (var p = 0; p < exterior.length; p++) {\n        vec2.applyTransform(exterior[p], exterior[p], transform);\n      }\n      for (var h = 0; h < (interiors ? interiors.length : 0); h++) {\n        for (var p = 0; p < interiors[h].length; p++) {\n          vec2.applyTransform(interiors[h][p], interiors[h][p], transform);\n        }\n      }\n    }\n    rect = this._rect;\n    rect.copy(target); // Update center\n\n    this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  };\n  GeoJSONRegion.prototype.cloneShallow = function (name) {\n    name == null && (name = this.name);\n    var newRegion = new GeoJSONRegion(name, this.geometries, this._center);\n    newRegion._rect = this._rect;\n    newRegion.transformTo = null; // Simply avoid to be called.\n\n    return newRegion;\n  };\n  GeoJSONRegion.prototype.getCenter = function () {\n    return this._center;\n  };\n  GeoJSONRegion.prototype.setCenter = function (center) {\n    this._center = center;\n  };\n  return GeoJSONRegion;\n}(Region);\nexport { GeoJSONRegion };\nvar GeoSVGRegion = /** @class */\nfunction (_super) {\n  __extends(GeoSVGRegion, _super);\n  function GeoSVGRegion(name, elOnlyForCalculate) {\n    var _this = _super.call(this, name) || this;\n    _this.type = 'geoSVG';\n    _this._elOnlyForCalculate = elOnlyForCalculate;\n    return _this;\n  }\n  GeoSVGRegion.prototype.getCenter = function () {\n    var center = this._center;\n    if (!center) {\n      // In most cases there are no need to calculate this center.\n      // So calculate only when called.\n      center = this._center = this._calculateCenter();\n    }\n    return center;\n  };\n  GeoSVGRegion.prototype._calculateCenter = function () {\n    var el = this._elOnlyForCalculate;\n    var rect = el.getBoundingRect();\n    var center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n    var mat = matrix.identity(TMP_TRANSFORM);\n    var target = el;\n    while (target && !target.isGeoSVGGraphicRoot) {\n      matrix.mul(mat, target.getLocalTransform(), mat);\n      target = target.parent;\n    }\n    matrix.invert(mat, mat);\n    vec2.applyTransform(center, center, mat);\n    return center;\n  };\n  return GeoSVGRegion;\n}(Region);\nexport { GeoSVGRegion };","map":{"version":3,"names":["__extends","BoundingRect","bbox","vec2","polygonContain","matrix","TMP_TRANSFORM","Region","name","prototype","getCenter","GeoJSONRegion","_super","geometries","cp","_this","call","type","rect","getBoundingRect","x","width","y","height","_center","_rect","MAX_NUMBER","Number","MAX_VALUE","min","max","min2","max2","i","length","exterior","fromPoints","contain","coord","loopGeo","len","interiors","k","transformTo","aspect","target","transform","calculateTransform","p","applyTransform","h","copy","cloneShallow","newRegion","setCenter","center","GeoSVGRegion","elOnlyForCalculate","_elOnlyForCalculate","_calculateCenter","el","mat","identity","isGeoSVGGraphicRoot","mul","getLocalTransform","parent","invert"],"sources":["/Users/jiong/Downloads/my-app/node_modules/echarts/lib/coord/geo/Region.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport BoundingRect from 'zrender/lib/core/BoundingRect';\nimport * as bbox from 'zrender/lib/core/bbox';\nimport * as vec2 from 'zrender/lib/core/vector';\nimport * as polygonContain from 'zrender/lib/contain/polygon';\nimport * as matrix from 'zrender/lib/core/matrix';\nvar TMP_TRANSFORM = [];\n\nvar Region =\n/** @class */\nfunction () {\n  function Region(name) {\n    this.name = name;\n  }\n  /**\n   * Get center point in data unit. That is,\n   * for GeoJSONRegion, the unit is lat/lng,\n   * for GeoSVGRegion, the unit is SVG local coord.\n   */\n\n\n  Region.prototype.getCenter = function () {\n    return;\n  };\n\n  return Region;\n}();\n\nexport { Region };\n\nvar GeoJSONRegion =\n/** @class */\nfunction (_super) {\n  __extends(GeoJSONRegion, _super);\n\n  function GeoJSONRegion(name, geometries, cp) {\n    var _this = _super.call(this, name) || this;\n\n    _this.type = 'geoJSON';\n    _this.geometries = geometries;\n\n    if (!cp) {\n      var rect = _this.getBoundingRect();\n\n      cp = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n    } else {\n      cp = [cp[0], cp[1]];\n    }\n\n    _this._center = cp;\n    return _this;\n  }\n\n  GeoJSONRegion.prototype.getBoundingRect = function () {\n    var rect = this._rect;\n\n    if (rect) {\n      return rect;\n    }\n\n    var MAX_NUMBER = Number.MAX_VALUE;\n    var min = [MAX_NUMBER, MAX_NUMBER];\n    var max = [-MAX_NUMBER, -MAX_NUMBER];\n    var min2 = [];\n    var max2 = [];\n    var geometries = this.geometries;\n    var i = 0;\n\n    for (; i < geometries.length; i++) {\n      // Only support polygon\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      } // Doesn't consider hole\n\n\n      var exterior = geometries[i].exterior;\n      bbox.fromPoints(exterior, min2, max2);\n      vec2.min(min, min, min2);\n      vec2.max(max, max, max2);\n    } // No data\n\n\n    if (i === 0) {\n      min[0] = min[1] = max[0] = max[1] = 0;\n    }\n\n    return this._rect = new BoundingRect(min[0], min[1], max[0] - min[0], max[1] - min[1]);\n  };\n\n  GeoJSONRegion.prototype.contain = function (coord) {\n    var rect = this.getBoundingRect();\n    var geometries = this.geometries;\n\n    if (!rect.contain(coord[0], coord[1])) {\n      return false;\n    }\n\n    loopGeo: for (var i = 0, len = geometries.length; i < len; i++) {\n      // Only support polygon.\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geometries[i].exterior;\n      var interiors = geometries[i].interiors;\n\n      if (polygonContain.contain(exterior, coord[0], coord[1])) {\n        // Not in the region if point is in the hole.\n        for (var k = 0; k < (interiors ? interiors.length : 0); k++) {\n          if (polygonContain.contain(interiors[k], coord[0], coord[1])) {\n            continue loopGeo;\n          }\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  GeoJSONRegion.prototype.transformTo = function (x, y, width, height) {\n    var rect = this.getBoundingRect();\n    var aspect = rect.width / rect.height;\n\n    if (!width) {\n      width = aspect * height;\n    } else if (!height) {\n      height = width / aspect;\n    }\n\n    var target = new BoundingRect(x, y, width, height);\n    var transform = rect.calculateTransform(target);\n    var geometries = this.geometries;\n\n    for (var i = 0; i < geometries.length; i++) {\n      // Only support polygon.\n      if (geometries[i].type !== 'polygon') {\n        continue;\n      }\n\n      var exterior = geometries[i].exterior;\n      var interiors = geometries[i].interiors;\n\n      for (var p = 0; p < exterior.length; p++) {\n        vec2.applyTransform(exterior[p], exterior[p], transform);\n      }\n\n      for (var h = 0; h < (interiors ? interiors.length : 0); h++) {\n        for (var p = 0; p < interiors[h].length; p++) {\n          vec2.applyTransform(interiors[h][p], interiors[h][p], transform);\n        }\n      }\n    }\n\n    rect = this._rect;\n    rect.copy(target); // Update center\n\n    this._center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n  };\n\n  GeoJSONRegion.prototype.cloneShallow = function (name) {\n    name == null && (name = this.name);\n    var newRegion = new GeoJSONRegion(name, this.geometries, this._center);\n    newRegion._rect = this._rect;\n    newRegion.transformTo = null; // Simply avoid to be called.\n\n    return newRegion;\n  };\n\n  GeoJSONRegion.prototype.getCenter = function () {\n    return this._center;\n  };\n\n  GeoJSONRegion.prototype.setCenter = function (center) {\n    this._center = center;\n  };\n\n  return GeoJSONRegion;\n}(Region);\n\nexport { GeoJSONRegion };\n\nvar GeoSVGRegion =\n/** @class */\nfunction (_super) {\n  __extends(GeoSVGRegion, _super);\n\n  function GeoSVGRegion(name, elOnlyForCalculate) {\n    var _this = _super.call(this, name) || this;\n\n    _this.type = 'geoSVG';\n    _this._elOnlyForCalculate = elOnlyForCalculate;\n    return _this;\n  }\n\n  GeoSVGRegion.prototype.getCenter = function () {\n    var center = this._center;\n\n    if (!center) {\n      // In most cases there are no need to calculate this center.\n      // So calculate only when called.\n      center = this._center = this._calculateCenter();\n    }\n\n    return center;\n  };\n\n  GeoSVGRegion.prototype._calculateCenter = function () {\n    var el = this._elOnlyForCalculate;\n    var rect = el.getBoundingRect();\n    var center = [rect.x + rect.width / 2, rect.y + rect.height / 2];\n    var mat = matrix.identity(TMP_TRANSFORM);\n    var target = el;\n\n    while (target && !target.isGeoSVGGraphicRoot) {\n      matrix.mul(mat, target.getLocalTransform(), mat);\n      target = target.parent;\n    }\n\n    matrix.invert(mat, mat);\n    vec2.applyTransform(center, center, mat);\n    return center;\n  };\n\n  return GeoSVGRegion;\n}(Region);\n\nexport { GeoSVGRegion };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}