{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME emphasis label position is not same with normal label position\nimport { parsePercent } from '../../util/number';\nimport { Point } from '../../util/graphic';\nimport { each } from 'zrender/lib/core/util';\nimport { limitTurnAngle, limitSurfaceAngle } from '../../label/labelGuideHelper';\nimport { shiftLayoutOnY } from '../../label/labelLayoutHelper';\nvar RADIAN = Math.PI / 180;\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {\n  if (list.length < 2) {\n    return;\n  }\n  ;\n  function recalculateXOnSemiToAlignOnEllipseCurve(semi) {\n    var rB = semi.rB;\n    var rB2 = rB * rB;\n    for (var i = 0; i < semi.list.length; i++) {\n      var item = semi.list[i];\n      var dy = Math.abs(item.label.y - cy); // horizontal r is always same with original r because x is not changed.\n\n      var rA = r + item.len;\n      var rA2 = rA * rA; // Use ellipse implicit function to calculate x\n\n      var dx = Math.sqrt((1 - Math.abs(dy * dy / rB2)) * rA2);\n      item.label.x = cx + (dx + item.len2) * dir;\n    }\n  } // Adjust X based on the shifted y. Make tight labels aligned on an ellipse curve.\n\n  function recalculateX(items) {\n    // Extremes of\n    var topSemi = {\n      list: [],\n      maxY: 0\n    };\n    var bottomSemi = {\n      list: [],\n      maxY: 0\n    };\n    for (var i = 0; i < items.length; i++) {\n      if (items[i].labelAlignTo !== 'none') {\n        continue;\n      }\n      var item = items[i];\n      var semi = item.label.y > cy ? bottomSemi : topSemi;\n      var dy = Math.abs(item.label.y - cy);\n      if (dy > semi.maxY) {\n        var dx = item.label.x - cx - item.len2 * dir; // horizontal r is always same with original r because x is not changed.\n\n        var rA = r + item.len; // Canculate rB based on the topest / bottemest label.\n\n        var rB = Math.abs(dx) < rA ? Math.sqrt(dy * dy / (1 - dx * dx / rA / rA)) : rA;\n        semi.rB = rB;\n        semi.maxY = dy;\n      }\n      semi.list.push(item);\n    }\n    recalculateXOnSemiToAlignOnEllipseCurve(topSemi);\n    recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);\n  }\n  var len = list.length;\n  for (var i = 0; i < len; i++) {\n    if (list[i].position === 'outer' && list[i].labelAlignTo === 'labelLine') {\n      var dx = list[i].label.x - farthestX;\n      list[i].linePoints[1][0] += dx;\n      list[i].label.x = farthestX;\n    }\n  }\n  if (shiftLayoutOnY(list, viewTop, viewTop + viewHeight)) {\n    recalculateX(list);\n  }\n}\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {\n  var leftList = [];\n  var rightList = [];\n  var leftmostX = Number.MAX_VALUE;\n  var rightmostX = -Number.MAX_VALUE;\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var label = labelLayoutList[i].label;\n    if (isPositionCenter(labelLayoutList[i])) {\n      continue;\n    }\n    if (label.x < cx) {\n      leftmostX = Math.min(leftmostX, label.x);\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightmostX = Math.max(rightmostX, label.x);\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var layout = labelLayoutList[i];\n    var label = layout.label;\n    if (isPositionCenter(layout)) {\n      continue;\n    }\n    var linePoints = layout.linePoints;\n    if (linePoints) {\n      var isAlignToEdge = layout.labelAlignTo === 'edge';\n      var realTextWidth = layout.rect.width;\n      var targetTextWidth = void 0;\n      if (isAlignToEdge) {\n        if (label.x < cx) {\n          targetTextWidth = linePoints[2][0] - layout.labelDistance - viewLeft - layout.edgeDistance;\n        } else {\n          targetTextWidth = viewLeft + viewWidth - layout.edgeDistance - linePoints[2][0] - layout.labelDistance;\n        }\n      } else {\n        if (label.x < cx) {\n          targetTextWidth = label.x - viewLeft - layout.bleedMargin;\n        } else {\n          targetTextWidth = viewLeft + viewWidth - label.x - layout.bleedMargin;\n        }\n      }\n      if (targetTextWidth < layout.rect.width) {\n        // TODOTODO\n        // layout.text = textContain.truncateText(layout.text, targetTextWidth, layout.font);\n        layout.label.style.width = targetTextWidth;\n        if (layout.labelAlignTo === 'edge') {\n          realTextWidth = targetTextWidth; // realTextWidth = textContain.getWidth(layout.text, layout.font);\n        }\n      }\n\n      var dist = linePoints[1][0] - linePoints[2][0];\n      if (isAlignToEdge) {\n        if (label.x < cx) {\n          linePoints[2][0] = viewLeft + layout.edgeDistance + realTextWidth + layout.labelDistance;\n        } else {\n          linePoints[2][0] = viewLeft + viewWidth - layout.edgeDistance - realTextWidth - layout.labelDistance;\n        }\n      } else {\n        if (label.x < cx) {\n          linePoints[2][0] = label.x + layout.labelDistance;\n        } else {\n          linePoints[2][0] = label.x - layout.labelDistance;\n        }\n        linePoints[1][0] = linePoints[2][0] + dist;\n      }\n      linePoints[1][1] = linePoints[2][1] = label.y;\n    }\n  }\n}\nfunction isPositionCenter(sectorShape) {\n  // Not change x for center label\n  return sectorShape.position === 'center';\n}\nexport default function pieLabelLayout(seriesModel) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  var minShowLabelRadian = (seriesModel.get('minShowLabelAngle') || 0) * RADIAN;\n  var viewRect = data.getLayout('viewRect');\n  var r = data.getLayout('r');\n  var viewWidth = viewRect.width;\n  var viewLeft = viewRect.x;\n  var viewTop = viewRect.y;\n  var viewHeight = viewRect.height;\n  function setNotShow(el) {\n    el.ignore = true;\n  }\n  function isLabelShown(label) {\n    if (!label.ignore) {\n      return true;\n    }\n    for (var key in label.states) {\n      if (label.states[key].ignore === false) {\n        return true;\n      }\n    }\n    return false;\n  }\n  data.each(function (idx) {\n    var sector = data.getItemGraphicEl(idx);\n    var sectorShape = sector.shape;\n    var label = sector.getTextContent();\n    var labelLine = sector.getTextGuideLine();\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get(['emphasis', 'label', 'position']);\n    var labelDistance = labelModel.get('distanceToLabelLine');\n    var labelAlignTo = labelModel.get('alignTo');\n    var edgeDistance = parsePercent(labelModel.get('edgeDistance'), viewWidth);\n    var bleedMargin = labelModel.get('bleedMargin');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    labelLineLen = parsePercent(labelLineLen, viewWidth);\n    var labelLineLen2 = labelLineModel.get('length2');\n    labelLineLen2 = parsePercent(labelLineLen2, viewWidth);\n    if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {\n      each(label.states, setNotShow);\n      label.ignore = true;\n      return;\n    }\n    if (!isLabelShown(label)) {\n      return;\n    }\n    var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;\n    var nx = Math.cos(midAngle);\n    var ny = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = sectorShape.cx;\n    cy = sectorShape.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n    if (labelPosition === 'center') {\n      textX = sectorShape.cx;\n      textY = sectorShape.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;\n      var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;\n      textX = x1 + nx * 3;\n      textY = y1 + ny * 3;\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + nx * (labelLineLen + r - sectorShape.r);\n        var y2 = y1 + ny * (labelLineLen + r - sectorShape.r);\n        var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n        if (labelAlignTo === 'edge') {\n          // Adjust textX because text align of edge is opposite\n          textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;\n        } else {\n          textX = x3 + (nx < 0 ? -labelDistance : labelDistance);\n        }\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n      textAlign = isLabelInside ? 'center' : labelAlignTo === 'edge' ? nx > 0 ? 'right' : 'left' : nx > 0 ? 'left' : 'right';\n    }\n    var labelRotate;\n    var rotate = labelModel.get('rotate');\n    if (typeof rotate === 'number') {\n      labelRotate = rotate * (Math.PI / 180);\n    } else {\n      labelRotate = rotate ? nx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    }\n    hasLabelRotate = !!labelRotate;\n    label.x = textX;\n    label.y = textY;\n    label.rotation = labelRotate;\n    label.setStyle({\n      verticalAlign: 'middle'\n    }); // Not sectorShape the inside label\n\n    if (!isLabelInside) {\n      var textRect = label.getBoundingRect().clone();\n      textRect.applyTransform(label.getComputedTransform()); // Text has a default 1px stroke. Exclude this.\n\n      var margin = (label.style.margin || 0) + 2.1;\n      textRect.y -= margin / 2;\n      textRect.height += margin;\n      labelLayoutList.push({\n        label: label,\n        labelLine: labelLine,\n        position: labelPosition,\n        len: labelLineLen,\n        len2: labelLineLen2,\n        minTurnAngle: labelLineModel.get('minTurnAngle'),\n        maxSurfaceAngle: labelLineModel.get('maxSurfaceAngle'),\n        surfaceNormal: new Point(nx, ny),\n        linePoints: linePoints,\n        textAlign: textAlign,\n        labelDistance: labelDistance,\n        labelAlignTo: labelAlignTo,\n        edgeDistance: edgeDistance,\n        bleedMargin: bleedMargin,\n        rect: textRect\n      });\n    } else {\n      label.setStyle({\n        align: textAlign\n      });\n      var selectState = label.states.select;\n      if (selectState) {\n        selectState.x += label.x;\n        selectState.y += label.y;\n      }\n    }\n    sector.setTextConfig({\n      inside: isLabelInside\n    });\n  });\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);\n  }\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var layout = labelLayoutList[i];\n    var label = layout.label;\n    var labelLine = layout.labelLine;\n    var notShowLabel = isNaN(label.x) || isNaN(label.y);\n    if (label) {\n      label.setStyle({\n        align: layout.textAlign\n      });\n      if (notShowLabel) {\n        each(label.states, setNotShow);\n        label.ignore = true;\n      }\n      var selectState = label.states.select;\n      if (selectState) {\n        selectState.x += label.x;\n        selectState.y += label.y;\n      }\n    }\n    if (labelLine) {\n      var linePoints = layout.linePoints;\n      if (notShowLabel || !linePoints) {\n        each(labelLine.states, setNotShow);\n        labelLine.ignore = true;\n      } else {\n        limitTurnAngle(linePoints, layout.minTurnAngle);\n        limitSurfaceAngle(linePoints, layout.surfaceNormal, layout.maxSurfaceAngle);\n        labelLine.setShape({\n          points: linePoints\n        }); // Set the anchor to the midpoint of sector\n\n        label.__hostTarget.textGuideLineConfig = {\n          anchor: new Point(linePoints[0][0], linePoints[0][1])\n        };\n      }\n    }\n  }\n}","map":{"version":3,"names":["parsePercent","Point","each","limitTurnAngle","limitSurfaceAngle","shiftLayoutOnY","RADIAN","Math","PI","adjustSingleSide","list","cx","cy","r","dir","viewWidth","viewHeight","viewLeft","viewTop","farthestX","length","recalculateXOnSemiToAlignOnEllipseCurve","semi","rB","rB2","i","item","dy","abs","label","y","rA","len","rA2","dx","sqrt","x","len2","recalculateX","items","topSemi","maxY","bottomSemi","labelAlignTo","push","position","linePoints","avoidOverlap","labelLayoutList","leftList","rightList","leftmostX","Number","MAX_VALUE","rightmostX","isPositionCenter","min","max","layout","isAlignToEdge","realTextWidth","rect","width","targetTextWidth","labelDistance","edgeDistance","bleedMargin","style","dist","sectorShape","pieLabelLayout","seriesModel","data","getData","hasLabelRotate","minShowLabelRadian","get","viewRect","getLayout","height","setNotShow","el","ignore","isLabelShown","key","states","idx","sector","getItemGraphicEl","shape","getTextContent","labelLine","getTextGuideLine","itemModel","getItemModel","labelModel","getModel","labelPosition","labelLineModel","labelLineLen","labelLineLen2","endAngle","startAngle","midAngle","nx","cos","ny","sin","textX","textY","textAlign","isLabelInside","x1","r0","y1","x2","y2","x3","y3","labelRotate","rotate","rotation","setStyle","verticalAlign","textRect","getBoundingRect","clone","applyTransform","getComputedTransform","margin","minTurnAngle","maxSurfaceAngle","surfaceNormal","align","selectState","select","setTextConfig","inside","notShowLabel","isNaN","setShape","points","__hostTarget","textGuideLineConfig","anchor"],"sources":["/Users/jiong/Downloads/my-app/node_modules/echarts/lib/chart/pie/labelLayout.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n// FIXME emphasis label position is not same with normal label position\nimport { parsePercent } from '../../util/number';\nimport { Point } from '../../util/graphic';\nimport { each } from 'zrender/lib/core/util';\nimport { limitTurnAngle, limitSurfaceAngle } from '../../label/labelGuideHelper';\nimport { shiftLayoutOnY } from '../../label/labelLayoutHelper';\nvar RADIAN = Math.PI / 180;\n\nfunction adjustSingleSide(list, cx, cy, r, dir, viewWidth, viewHeight, viewLeft, viewTop, farthestX) {\n  if (list.length < 2) {\n    return;\n  }\n\n  ;\n\n  function recalculateXOnSemiToAlignOnEllipseCurve(semi) {\n    var rB = semi.rB;\n    var rB2 = rB * rB;\n\n    for (var i = 0; i < semi.list.length; i++) {\n      var item = semi.list[i];\n      var dy = Math.abs(item.label.y - cy); // horizontal r is always same with original r because x is not changed.\n\n      var rA = r + item.len;\n      var rA2 = rA * rA; // Use ellipse implicit function to calculate x\n\n      var dx = Math.sqrt((1 - Math.abs(dy * dy / rB2)) * rA2);\n      item.label.x = cx + (dx + item.len2) * dir;\n    }\n  } // Adjust X based on the shifted y. Make tight labels aligned on an ellipse curve.\n\n\n  function recalculateX(items) {\n    // Extremes of\n    var topSemi = {\n      list: [],\n      maxY: 0\n    };\n    var bottomSemi = {\n      list: [],\n      maxY: 0\n    };\n\n    for (var i = 0; i < items.length; i++) {\n      if (items[i].labelAlignTo !== 'none') {\n        continue;\n      }\n\n      var item = items[i];\n      var semi = item.label.y > cy ? bottomSemi : topSemi;\n      var dy = Math.abs(item.label.y - cy);\n\n      if (dy > semi.maxY) {\n        var dx = item.label.x - cx - item.len2 * dir; // horizontal r is always same with original r because x is not changed.\n\n        var rA = r + item.len; // Canculate rB based on the topest / bottemest label.\n\n        var rB = Math.abs(dx) < rA ? Math.sqrt(dy * dy / (1 - dx * dx / rA / rA)) : rA;\n        semi.rB = rB;\n        semi.maxY = dy;\n      }\n\n      semi.list.push(item);\n    }\n\n    recalculateXOnSemiToAlignOnEllipseCurve(topSemi);\n    recalculateXOnSemiToAlignOnEllipseCurve(bottomSemi);\n  }\n\n  var len = list.length;\n\n  for (var i = 0; i < len; i++) {\n    if (list[i].position === 'outer' && list[i].labelAlignTo === 'labelLine') {\n      var dx = list[i].label.x - farthestX;\n      list[i].linePoints[1][0] += dx;\n      list[i].label.x = farthestX;\n    }\n  }\n\n  if (shiftLayoutOnY(list, viewTop, viewTop + viewHeight)) {\n    recalculateX(list);\n  }\n}\n\nfunction avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop) {\n  var leftList = [];\n  var rightList = [];\n  var leftmostX = Number.MAX_VALUE;\n  var rightmostX = -Number.MAX_VALUE;\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var label = labelLayoutList[i].label;\n\n    if (isPositionCenter(labelLayoutList[i])) {\n      continue;\n    }\n\n    if (label.x < cx) {\n      leftmostX = Math.min(leftmostX, label.x);\n      leftList.push(labelLayoutList[i]);\n    } else {\n      rightmostX = Math.max(rightmostX, label.x);\n      rightList.push(labelLayoutList[i]);\n    }\n  }\n\n  adjustSingleSide(rightList, cx, cy, r, 1, viewWidth, viewHeight, viewLeft, viewTop, rightmostX);\n  adjustSingleSide(leftList, cx, cy, r, -1, viewWidth, viewHeight, viewLeft, viewTop, leftmostX);\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var layout = labelLayoutList[i];\n    var label = layout.label;\n\n    if (isPositionCenter(layout)) {\n      continue;\n    }\n\n    var linePoints = layout.linePoints;\n\n    if (linePoints) {\n      var isAlignToEdge = layout.labelAlignTo === 'edge';\n      var realTextWidth = layout.rect.width;\n      var targetTextWidth = void 0;\n\n      if (isAlignToEdge) {\n        if (label.x < cx) {\n          targetTextWidth = linePoints[2][0] - layout.labelDistance - viewLeft - layout.edgeDistance;\n        } else {\n          targetTextWidth = viewLeft + viewWidth - layout.edgeDistance - linePoints[2][0] - layout.labelDistance;\n        }\n      } else {\n        if (label.x < cx) {\n          targetTextWidth = label.x - viewLeft - layout.bleedMargin;\n        } else {\n          targetTextWidth = viewLeft + viewWidth - label.x - layout.bleedMargin;\n        }\n      }\n\n      if (targetTextWidth < layout.rect.width) {\n        // TODOTODO\n        // layout.text = textContain.truncateText(layout.text, targetTextWidth, layout.font);\n        layout.label.style.width = targetTextWidth;\n\n        if (layout.labelAlignTo === 'edge') {\n          realTextWidth = targetTextWidth; // realTextWidth = textContain.getWidth(layout.text, layout.font);\n        }\n      }\n\n      var dist = linePoints[1][0] - linePoints[2][0];\n\n      if (isAlignToEdge) {\n        if (label.x < cx) {\n          linePoints[2][0] = viewLeft + layout.edgeDistance + realTextWidth + layout.labelDistance;\n        } else {\n          linePoints[2][0] = viewLeft + viewWidth - layout.edgeDistance - realTextWidth - layout.labelDistance;\n        }\n      } else {\n        if (label.x < cx) {\n          linePoints[2][0] = label.x + layout.labelDistance;\n        } else {\n          linePoints[2][0] = label.x - layout.labelDistance;\n        }\n\n        linePoints[1][0] = linePoints[2][0] + dist;\n      }\n\n      linePoints[1][1] = linePoints[2][1] = label.y;\n    }\n  }\n}\n\nfunction isPositionCenter(sectorShape) {\n  // Not change x for center label\n  return sectorShape.position === 'center';\n}\n\nexport default function pieLabelLayout(seriesModel) {\n  var data = seriesModel.getData();\n  var labelLayoutList = [];\n  var cx;\n  var cy;\n  var hasLabelRotate = false;\n  var minShowLabelRadian = (seriesModel.get('minShowLabelAngle') || 0) * RADIAN;\n  var viewRect = data.getLayout('viewRect');\n  var r = data.getLayout('r');\n  var viewWidth = viewRect.width;\n  var viewLeft = viewRect.x;\n  var viewTop = viewRect.y;\n  var viewHeight = viewRect.height;\n\n  function setNotShow(el) {\n    el.ignore = true;\n  }\n\n  function isLabelShown(label) {\n    if (!label.ignore) {\n      return true;\n    }\n\n    for (var key in label.states) {\n      if (label.states[key].ignore === false) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  data.each(function (idx) {\n    var sector = data.getItemGraphicEl(idx);\n    var sectorShape = sector.shape;\n    var label = sector.getTextContent();\n    var labelLine = sector.getTextGuideLine();\n    var itemModel = data.getItemModel(idx);\n    var labelModel = itemModel.getModel('label'); // Use position in normal or emphasis\n\n    var labelPosition = labelModel.get('position') || itemModel.get(['emphasis', 'label', 'position']);\n    var labelDistance = labelModel.get('distanceToLabelLine');\n    var labelAlignTo = labelModel.get('alignTo');\n    var edgeDistance = parsePercent(labelModel.get('edgeDistance'), viewWidth);\n    var bleedMargin = labelModel.get('bleedMargin');\n    var labelLineModel = itemModel.getModel('labelLine');\n    var labelLineLen = labelLineModel.get('length');\n    labelLineLen = parsePercent(labelLineLen, viewWidth);\n    var labelLineLen2 = labelLineModel.get('length2');\n    labelLineLen2 = parsePercent(labelLineLen2, viewWidth);\n\n    if (Math.abs(sectorShape.endAngle - sectorShape.startAngle) < minShowLabelRadian) {\n      each(label.states, setNotShow);\n      label.ignore = true;\n      return;\n    }\n\n    if (!isLabelShown(label)) {\n      return;\n    }\n\n    var midAngle = (sectorShape.startAngle + sectorShape.endAngle) / 2;\n    var nx = Math.cos(midAngle);\n    var ny = Math.sin(midAngle);\n    var textX;\n    var textY;\n    var linePoints;\n    var textAlign;\n    cx = sectorShape.cx;\n    cy = sectorShape.cy;\n    var isLabelInside = labelPosition === 'inside' || labelPosition === 'inner';\n\n    if (labelPosition === 'center') {\n      textX = sectorShape.cx;\n      textY = sectorShape.cy;\n      textAlign = 'center';\n    } else {\n      var x1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * nx : sectorShape.r * nx) + cx;\n      var y1 = (isLabelInside ? (sectorShape.r + sectorShape.r0) / 2 * ny : sectorShape.r * ny) + cy;\n      textX = x1 + nx * 3;\n      textY = y1 + ny * 3;\n\n      if (!isLabelInside) {\n        // For roseType\n        var x2 = x1 + nx * (labelLineLen + r - sectorShape.r);\n        var y2 = y1 + ny * (labelLineLen + r - sectorShape.r);\n        var x3 = x2 + (nx < 0 ? -1 : 1) * labelLineLen2;\n        var y3 = y2;\n\n        if (labelAlignTo === 'edge') {\n          // Adjust textX because text align of edge is opposite\n          textX = nx < 0 ? viewLeft + edgeDistance : viewLeft + viewWidth - edgeDistance;\n        } else {\n          textX = x3 + (nx < 0 ? -labelDistance : labelDistance);\n        }\n\n        textY = y3;\n        linePoints = [[x1, y1], [x2, y2], [x3, y3]];\n      }\n\n      textAlign = isLabelInside ? 'center' : labelAlignTo === 'edge' ? nx > 0 ? 'right' : 'left' : nx > 0 ? 'left' : 'right';\n    }\n\n    var labelRotate;\n    var rotate = labelModel.get('rotate');\n\n    if (typeof rotate === 'number') {\n      labelRotate = rotate * (Math.PI / 180);\n    } else {\n      labelRotate = rotate ? nx < 0 ? -midAngle + Math.PI : -midAngle : 0;\n    }\n\n    hasLabelRotate = !!labelRotate;\n    label.x = textX;\n    label.y = textY;\n    label.rotation = labelRotate;\n    label.setStyle({\n      verticalAlign: 'middle'\n    }); // Not sectorShape the inside label\n\n    if (!isLabelInside) {\n      var textRect = label.getBoundingRect().clone();\n      textRect.applyTransform(label.getComputedTransform()); // Text has a default 1px stroke. Exclude this.\n\n      var margin = (label.style.margin || 0) + 2.1;\n      textRect.y -= margin / 2;\n      textRect.height += margin;\n      labelLayoutList.push({\n        label: label,\n        labelLine: labelLine,\n        position: labelPosition,\n        len: labelLineLen,\n        len2: labelLineLen2,\n        minTurnAngle: labelLineModel.get('minTurnAngle'),\n        maxSurfaceAngle: labelLineModel.get('maxSurfaceAngle'),\n        surfaceNormal: new Point(nx, ny),\n        linePoints: linePoints,\n        textAlign: textAlign,\n        labelDistance: labelDistance,\n        labelAlignTo: labelAlignTo,\n        edgeDistance: edgeDistance,\n        bleedMargin: bleedMargin,\n        rect: textRect\n      });\n    } else {\n      label.setStyle({\n        align: textAlign\n      });\n      var selectState = label.states.select;\n\n      if (selectState) {\n        selectState.x += label.x;\n        selectState.y += label.y;\n      }\n    }\n\n    sector.setTextConfig({\n      inside: isLabelInside\n    });\n  });\n\n  if (!hasLabelRotate && seriesModel.get('avoidLabelOverlap')) {\n    avoidOverlap(labelLayoutList, cx, cy, r, viewWidth, viewHeight, viewLeft, viewTop);\n  }\n\n  for (var i = 0; i < labelLayoutList.length; i++) {\n    var layout = labelLayoutList[i];\n    var label = layout.label;\n    var labelLine = layout.labelLine;\n    var notShowLabel = isNaN(label.x) || isNaN(label.y);\n\n    if (label) {\n      label.setStyle({\n        align: layout.textAlign\n      });\n\n      if (notShowLabel) {\n        each(label.states, setNotShow);\n        label.ignore = true;\n      }\n\n      var selectState = label.states.select;\n\n      if (selectState) {\n        selectState.x += label.x;\n        selectState.y += label.y;\n      }\n    }\n\n    if (labelLine) {\n      var linePoints = layout.linePoints;\n\n      if (notShowLabel || !linePoints) {\n        each(labelLine.states, setNotShow);\n        labelLine.ignore = true;\n      } else {\n        limitTurnAngle(linePoints, layout.minTurnAngle);\n        limitSurfaceAngle(linePoints, layout.surfaceNormal, layout.maxSurfaceAngle);\n        labelLine.setShape({\n          points: linePoints\n        }); // Set the anchor to the midpoint of sector\n\n        label.__hostTarget.textGuideLineConfig = {\n          anchor: new Point(linePoints[0][0], linePoints[0][1])\n        };\n      }\n    }\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}