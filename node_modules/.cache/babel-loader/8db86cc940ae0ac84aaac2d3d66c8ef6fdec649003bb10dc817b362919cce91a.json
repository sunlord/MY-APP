{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as pathTool from 'zrender/lib/tool/path';\nimport * as matrix from 'zrender/lib/core/matrix';\nimport * as vector from 'zrender/lib/core/vector';\nimport Path from 'zrender/lib/graphic/Path';\nimport Transformable from 'zrender/lib/core/Transformable';\nimport ZRImage from 'zrender/lib/graphic/Image';\nimport Group from 'zrender/lib/graphic/Group';\nimport ZRText from 'zrender/lib/graphic/Text';\nimport Circle from 'zrender/lib/graphic/shape/Circle';\nimport Ellipse from 'zrender/lib/graphic/shape/Ellipse';\nimport Sector from 'zrender/lib/graphic/shape/Sector';\nimport Ring from 'zrender/lib/graphic/shape/Ring';\nimport Polygon from 'zrender/lib/graphic/shape/Polygon';\nimport Polyline from 'zrender/lib/graphic/shape/Polyline';\nimport Rect from 'zrender/lib/graphic/shape/Rect';\nimport Line from 'zrender/lib/graphic/shape/Line';\nimport BezierCurve from 'zrender/lib/graphic/shape/BezierCurve';\nimport Arc from 'zrender/lib/graphic/shape/Arc';\nimport CompoundPath from 'zrender/lib/graphic/CompoundPath';\nimport LinearGradient from 'zrender/lib/graphic/LinearGradient';\nimport RadialGradient from 'zrender/lib/graphic/RadialGradient';\nimport BoundingRect from 'zrender/lib/core/BoundingRect';\nimport OrientedBoundingRect from 'zrender/lib/core/OrientedBoundingRect';\nimport Point from 'zrender/lib/core/Point';\nimport IncrementalDisplayable from 'zrender/lib/graphic/IncrementalDisplayable';\nimport * as subPixelOptimizeUtil from 'zrender/lib/graphic/helper/subPixelOptimize';\nimport { extend, isArrayLike, map, defaults, isObject, retrieve2, isString, keys, each, hasOwn } from 'zrender/lib/core/util';\nimport { getECData } from './innerStore';\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar _customShapeMap = {};\n/**\n * Extend shape with parameters\n */\n\nexport function extendShape(opts) {\n  return Path.extend(opts);\n}\nvar extendPathFromString = pathTool.extendFromString;\n/**\n * Extend path\n */\n\nexport function extendPath(pathData, opts) {\n  return extendPathFromString(pathData, opts);\n}\n/**\n * Register a user defined shape.\n * The shape class can be fetched by `getShapeClass`\n * This method will overwrite the registered shapes, including\n * the registered built-in shapes, if using the same `name`.\n * The shape can be used in `custom series` and\n * `graphic component` by declaring `{type: name}`.\n *\n * @param name\n * @param ShapeClass Can be generated by `extendShape`.\n */\n\nexport function registerShape(name, ShapeClass) {\n  _customShapeMap[name] = ShapeClass;\n}\n/**\n * Find shape class registered by `registerShape`. Usually used in\n * fetching user defined shape.\n *\n * [Caution]:\n * (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared\n * to use user registered shapes.\n * Because the built-in shape (see `getBuiltInShape`) will be registered by\n * `registerShape` by default. That enables users to get both built-in\n * shapes as well as the shapes belonging to themsleves. But users can overwrite\n * the built-in shapes by using names like 'circle', 'rect' via calling\n * `registerShape`. So the echarts inner featrues should not fetch shapes from here\n * in case that it is overwritten by users, except that some features, like\n * `custom series`, `graphic component`, do it deliberately.\n *\n * (2) In the features like `custom series`, `graphic component`, the user input\n * `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic\n * elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names\n * are reserved names, that is, if some user register a shape named `'image'`,\n * the shape will not be used. If we intending to add some more reserved names\n * in feature, that might bring break changes (disable some existing user shape\n * names). But that case probably rearly happen. So we dont make more mechanism\n * to resolve this issue here.\n *\n * @param name\n * @return The shape class. If not found, return nothing.\n */\n\nexport function getShapeClass(name) {\n  if (_customShapeMap.hasOwnProperty(name)) {\n    return _customShapeMap[name];\n  }\n}\n/**\n * Create a path element from path data string\n * @param pathData\n * @param opts\n * @param rect\n * @param layout 'center' or 'cover' default to be cover\n */\n\nexport function makePath(pathData, opts, rect, layout) {\n  var path = pathTool.createFromString(pathData, opts);\n  if (rect) {\n    if (layout === 'center') {\n      rect = centerGraphic(rect, path.getBoundingRect());\n    }\n    resizePath(path, rect);\n  }\n  return path;\n}\n/**\n * Create a image element from image url\n * @param imageUrl image url\n * @param opts options\n * @param rect constrain rect\n * @param layout 'center' or 'cover'. Default to be 'cover'\n */\n\nexport function makeImage(imageUrl, rect, layout) {\n  var zrImg = new ZRImage({\n    style: {\n      image: imageUrl,\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    },\n    onload: function (img) {\n      if (layout === 'center') {\n        var boundingRect = {\n          width: img.width,\n          height: img.height\n        };\n        zrImg.setStyle(centerGraphic(rect, boundingRect));\n      }\n    }\n  });\n  return zrImg;\n}\n/**\n * Get position of centered element in bounding box.\n *\n * @param  rect         element local bounding box\n * @param  boundingRect constraint bounding box\n * @return element position containing x, y, width, and height\n */\n\nfunction centerGraphic(rect, boundingRect) {\n  // Set rect to center, keep width / height ratio.\n  var aspect = boundingRect.width / boundingRect.height;\n  var width = rect.height * aspect;\n  var height;\n  if (width <= rect.width) {\n    height = rect.height;\n  } else {\n    width = rect.width;\n    height = width / aspect;\n  }\n  var cx = rect.x + rect.width / 2;\n  var cy = rect.y + rect.height / 2;\n  return {\n    x: cx - width / 2,\n    y: cy - height / 2,\n    width: width,\n    height: height\n  };\n}\nexport var mergePath = pathTool.mergePath;\n/**\n * Resize a path to fit the rect\n * @param path\n * @param rect\n */\n\nexport function resizePath(path, rect) {\n  if (!path.applyTransform) {\n    return;\n  }\n  var pathRect = path.getBoundingRect();\n  var m = pathRect.calculateTransform(rect);\n  path.applyTransform(m);\n}\n/**\n * Sub pixel optimize line for canvas\n */\n\nexport function subPixelOptimizeLine(param) {\n  subPixelOptimizeUtil.subPixelOptimizeLine(param.shape, param.shape, param.style);\n  return param;\n}\n/**\n * Sub pixel optimize rect for canvas\n */\n\nexport function subPixelOptimizeRect(param) {\n  subPixelOptimizeUtil.subPixelOptimizeRect(param.shape, param.shape, param.style);\n  return param;\n}\n/**\n * Sub pixel optimize for canvas\n *\n * @param position Coordinate, such as x, y\n * @param lineWidth Should be nonnegative integer.\n * @param positiveOrNegative Default false (negative).\n * @return Optimized position.\n */\n\nexport var subPixelOptimize = subPixelOptimizeUtil.subPixelOptimize;\nfunction animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {\n  var isFrom = false;\n  var removeOpt;\n  if (typeof dataIndex === 'function') {\n    during = cb;\n    cb = dataIndex;\n    dataIndex = null;\n  } else if (isObject(dataIndex)) {\n    cb = dataIndex.cb;\n    during = dataIndex.during;\n    isFrom = dataIndex.isFrom;\n    removeOpt = dataIndex.removeOpt;\n    dataIndex = dataIndex.dataIndex;\n  }\n  var isUpdate = animationType === 'update';\n  var isRemove = animationType === 'remove';\n  var animationPayload; // Check if there is global animation configuration from dataZoom/resize can override the config in option.\n  // If animation is enabled. Will use this animation config in payload.\n  // If animation is disabled. Just ignore it.\n\n  if (animatableModel && animatableModel.ecModel) {\n    var updatePayload = animatableModel.ecModel.getUpdatePayload();\n    animationPayload = updatePayload && updatePayload.animation;\n  }\n  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n  if (!isRemove) {\n    // Must stop the remove animation.\n    el.stopAnimation('remove');\n  }\n  if (animationEnabled) {\n    var duration = void 0;\n    var animationEasing = void 0;\n    var animationDelay = void 0;\n    if (animationPayload) {\n      duration = animationPayload.duration || 0;\n      animationEasing = animationPayload.easing || 'cubicOut';\n      animationDelay = animationPayload.delay || 0;\n    } else if (isRemove) {\n      removeOpt = removeOpt || {};\n      duration = retrieve2(removeOpt.duration, 200);\n      animationEasing = retrieve2(removeOpt.easing, 'cubicOut');\n      animationDelay = 0;\n    } else {\n      duration = animatableModel.getShallow(isUpdate ? 'animationDurationUpdate' : 'animationDuration');\n      animationEasing = animatableModel.getShallow(isUpdate ? 'animationEasingUpdate' : 'animationEasing');\n      animationDelay = animatableModel.getShallow(isUpdate ? 'animationDelayUpdate' : 'animationDelay');\n    }\n    if (typeof animationDelay === 'function') {\n      animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);\n    }\n    if (typeof duration === 'function') {\n      duration = duration(dataIndex);\n    }\n    duration > 0 ? isFrom ? el.animateFrom(props, {\n      duration: duration,\n      delay: animationDelay || 0,\n      easing: animationEasing,\n      done: cb,\n      force: !!cb || !!during,\n      scope: animationType,\n      during: during\n    }) : el.animateTo(props, {\n      duration: duration,\n      delay: animationDelay || 0,\n      easing: animationEasing,\n      done: cb,\n      force: !!cb || !!during,\n      setToFinal: true,\n      scope: animationType,\n      during: during\n    }) : (\n    // FIXME:\n    // If `duration` is 0, only the animation on props\n    // can be stoped, other animation should be continued?\n    // But at present using duration 0 in `animateTo`, `animateFrom`\n    // might cause unexpected behavior.\n    el.stopAnimation(),\n    // If `isFrom`, the props is the \"from\" props.\n    !isFrom && el.attr(props), cb && cb());\n  } else {\n    el.stopAnimation();\n    !isFrom && el.attr(props); // Call during once.\n\n    during && during(1);\n    cb && cb();\n  }\n}\n/**\n * Update graphic element properties with or without animation according to the\n * configuration in series.\n *\n * Caution: this method will stop previous animation.\n * So do not use this method to one element twice before\n * animation starts, unless you know what you are doing.\n * @example\n *     graphic.updateProps(el, {\n *         position: [100, 100]\n *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n *     // Or\n *     graphic.updateProps(el, {\n *         position: [100, 100]\n *     }, seriesModel, function () { console.log('Animation done!'); });\n */\n\nfunction updateProps(el, props,\n// TODO: TYPE AnimatableModel\nanimatableModel, dataIndex, cb, during) {\n  animateOrSetProps('update', el, props, animatableModel, dataIndex, cb, during);\n}\nexport { updateProps };\n/**\n * Init graphic element properties with or without animation according to the\n * configuration in series.\n *\n * Caution: this method will stop previous animation.\n * So do not use this method to one element twice before\n * animation starts, unless you know what you are doing.\n */\n\nexport function initProps(el, props, animatableModel, dataIndex, cb, during) {\n  animateOrSetProps('init', el, props, animatableModel, dataIndex, cb, during);\n}\n/**\n * Remove graphic element\n */\n\nexport function removeElement(el, props, animatableModel, dataIndex, cb, during) {\n  // Don't do remove animation twice.\n  if (isElementRemoved(el)) {\n    return;\n  }\n  animateOrSetProps('remove', el, props, animatableModel, dataIndex, cb, during);\n}\nfunction fadeOutDisplayable(el, animatableModel, dataIndex, done) {\n  el.removeTextContent();\n  el.removeTextGuideLine();\n  removeElement(el, {\n    style: {\n      opacity: 0\n    }\n  }, animatableModel, dataIndex, done);\n}\nexport function removeElementWithFadeOut(el, animatableModel, dataIndex) {\n  function doRemove() {\n    el.parent && el.parent.remove(el);\n  } // Hide label and labelLine first\n  // TODO Also use fade out animation?\n\n  if (!el.isGroup) {\n    fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);\n  } else {\n    el.traverse(function (disp) {\n      if (!disp.isGroup) {\n        // Can invoke doRemove multiple times.\n        fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);\n      }\n    });\n  }\n}\n/**\n * If element is removed.\n * It can determine if element is having remove animation.\n */\n\nexport function isElementRemoved(el) {\n  if (!el.__zr) {\n    return true;\n  }\n  for (var i = 0; i < el.animators.length; i++) {\n    var animator = el.animators[i];\n    if (animator.scope === 'remove') {\n      return true;\n    }\n  }\n  return false;\n}\n/**\n * Get transform matrix of target (param target),\n * in coordinate of its ancestor (param ancestor)\n *\n * @param target\n * @param [ancestor]\n */\n\nexport function getTransform(target, ancestor) {\n  var mat = matrix.identity([]);\n  while (target && target !== ancestor) {\n    matrix.mul(mat, target.getLocalTransform(), mat);\n    target = target.parent;\n  }\n  return mat;\n}\n/**\n * Apply transform to an vertex.\n * @param target [x, y]\n * @param transform Can be:\n *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n * @param invert Whether use invert matrix.\n * @return [x, y]\n */\n\nexport function applyTransform(target, transform, invert) {\n  if (transform && !isArrayLike(transform)) {\n    transform = Transformable.getLocalTransform(transform);\n  }\n  if (invert) {\n    transform = matrix.invert([], transform);\n  }\n  return vector.applyTransform([], target, transform);\n}\n/**\n * @param direction 'left' 'right' 'top' 'bottom'\n * @param transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n * @param invert Whether use invert matrix.\n * @return Transformed direction. 'left' 'right' 'top' 'bottom'\n */\n\nexport function transformDirection(direction, transform, invert) {\n  // Pick a base, ensure that transform result will not be (0, 0).\n  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];\n  vertex = applyTransform(vertex, transform, invert);\n  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n}\nfunction isNotGroup(el) {\n  return !el.isGroup;\n}\nfunction isPath(el) {\n  return el.shape != null;\n}\n/**\n * Apply group transition animation from g1 to g2.\n * If no animatableModel, no animation.\n */\n\nexport function groupTransition(g1, g2, animatableModel) {\n  if (!g1 || !g2) {\n    return;\n  }\n  function getElMap(g) {\n    var elMap = {};\n    g.traverse(function (el) {\n      if (isNotGroup(el) && el.anid) {\n        elMap[el.anid] = el;\n      }\n    });\n    return elMap;\n  }\n  function getAnimatableProps(el) {\n    var obj = {\n      x: el.x,\n      y: el.y,\n      rotation: el.rotation\n    };\n    if (isPath(el)) {\n      obj.shape = extend({}, el.shape);\n    }\n    return obj;\n  }\n  var elMap1 = getElMap(g1);\n  g2.traverse(function (el) {\n    if (isNotGroup(el) && el.anid) {\n      var oldEl = elMap1[el.anid];\n      if (oldEl) {\n        var newProp = getAnimatableProps(el);\n        el.attr(getAnimatableProps(oldEl));\n        updateProps(el, newProp, animatableModel, getECData(el).dataIndex);\n      }\n    }\n  });\n}\nexport function clipPointsByRect(points, rect) {\n  // FIXME: this way migth be incorrect when grpahic clipped by a corner.\n  // and when element have border.\n  return map(points, function (point) {\n    var x = point[0];\n    x = mathMax(x, rect.x);\n    x = mathMin(x, rect.x + rect.width);\n    var y = point[1];\n    y = mathMax(y, rect.y);\n    y = mathMin(y, rect.y + rect.height);\n    return [x, y];\n  });\n}\n/**\n * Return a new clipped rect. If rect size are negative, return undefined.\n */\n\nexport function clipRectByRect(targetRect, rect) {\n  var x = mathMax(targetRect.x, rect.x);\n  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n  var y = mathMax(targetRect.y, rect.y);\n  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height); // If the total rect is cliped, nothing, including the border,\n  // should be painted. So return undefined.\n\n  if (x2 >= x && y2 >= y) {\n    return {\n      x: x,\n      y: y,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\nexport function createIcon(iconStr,\n// Support 'image://' or 'path://' or direct svg path.\nopt, rect) {\n  var innerOpts = extend({\n    rectHover: true\n  }, opt);\n  var style = innerOpts.style = {\n    strokeNoScale: true\n  };\n  rect = rect || {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  };\n  if (iconStr) {\n    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new ZRImage(innerOpts)) : makePath(iconStr.replace('path://', ''), innerOpts, rect, 'center');\n  }\n}\n/**\n * Return `true` if the given line (line `a`) and the given polygon\n * are intersect.\n * Note that we do not count colinear as intersect here because no\n * requirement for that. We could do that if required in future.\n */\n\nexport function linePolygonIntersect(a1x, a1y, a2x, a2y, points) {\n  for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {\n    var p = points[i];\n    if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {\n      return true;\n    }\n    p2 = p;\n  }\n}\n/**\n * Return `true` if the given two lines (line `a` and line `b`)\n * are intersect.\n * Note that we do not count colinear as intersect here because no\n * requirement for that. We could do that if required in future.\n */\n\nexport function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n  // let `vec_m` to be `vec_a2 - vec_a1` and `vec_n` to be `vec_b2 - vec_b1`.\n  var mx = a2x - a1x;\n  var my = a2y - a1y;\n  var nx = b2x - b1x;\n  var ny = b2y - b1y; // `vec_m` and `vec_n` are parallel iff\n  //     exising `k` such that `vec_m = k · vec_n`, equivalent to `vec_m X vec_n = 0`.\n\n  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n  if (nearZero(nmCrossProduct)) {\n    return false;\n  } // `vec_m` and `vec_n` are intersect iff\n  //     existing `p` and `q` in [0, 1] such that `vec_a1 + p * vec_m = vec_b1 + q * vec_n`,\n  //     such that `q = ((vec_a1 - vec_b1) X vec_m) / (vec_n X vec_m)`\n  //           and `p = ((vec_a1 - vec_b1) X vec_n) / (vec_n X vec_m)`.\n\n  var b1a1x = a1x - b1x;\n  var b1a1y = a1y - b1y;\n  var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;\n  if (q < 0 || q > 1) {\n    return false;\n  }\n  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n  if (p < 0 || p > 1) {\n    return false;\n  }\n  return true;\n}\n/**\n * Cross product of 2-dimension vector.\n */\n\nfunction crossProduct2d(x1, y1, x2, y2) {\n  return x1 * y2 - x2 * y1;\n}\nfunction nearZero(val) {\n  return val <= 1e-6 && val >= -1e-6;\n}\nexport function setTooltipConfig(opt) {\n  var itemTooltipOption = opt.itemTooltipOption;\n  var componentModel = opt.componentModel;\n  var itemName = opt.itemName;\n  var itemTooltipOptionObj = isString(itemTooltipOption) ? {\n    formatter: itemTooltipOption\n  } : itemTooltipOption;\n  var mainType = componentModel.mainType;\n  var componentIndex = componentModel.componentIndex;\n  var formatterParams = {\n    componentType: mainType,\n    name: itemName,\n    $vars: ['name']\n  };\n  formatterParams[mainType + 'Index'] = componentIndex;\n  var formatterParamsExtra = opt.formatterParamsExtra;\n  if (formatterParamsExtra) {\n    each(keys(formatterParamsExtra), function (key) {\n      if (!hasOwn(formatterParams, key)) {\n        formatterParams[key] = formatterParamsExtra[key];\n        formatterParams.$vars.push(key);\n      }\n    });\n  }\n  var ecData = getECData(opt.el);\n  ecData.componentMainType = mainType;\n  ecData.componentIndex = componentIndex;\n  ecData.tooltipConfig = {\n    name: itemName,\n    option: defaults({\n      content: itemName,\n      formatterParams: formatterParams\n    }, itemTooltipOptionObj)\n  };\n} // Register built-in shapes. These shapes might be overwirtten\n// by users, although we do not recommend that.\n\nregisterShape('circle', Circle);\nregisterShape('ellipse', Ellipse);\nregisterShape('sector', Sector);\nregisterShape('ring', Ring);\nregisterShape('polygon', Polygon);\nregisterShape('polyline', Polyline);\nregisterShape('rect', Rect);\nregisterShape('line', Line);\nregisterShape('bezierCurve', BezierCurve);\nregisterShape('arc', Arc);\nexport { Group, ZRImage as Image, ZRText as Text, Circle, Ellipse, Sector, Ring, Polygon, Polyline, Rect, Line, BezierCurve, Arc, IncrementalDisplayable, CompoundPath, LinearGradient, RadialGradient, BoundingRect, OrientedBoundingRect, Point, Path };","map":{"version":3,"names":["pathTool","matrix","vector","Path","Transformable","ZRImage","Group","ZRText","Circle","Ellipse","Sector","Ring","Polygon","Polyline","Rect","Line","BezierCurve","Arc","CompoundPath","LinearGradient","RadialGradient","BoundingRect","OrientedBoundingRect","Point","IncrementalDisplayable","subPixelOptimizeUtil","extend","isArrayLike","map","defaults","isObject","retrieve2","isString","keys","each","hasOwn","getECData","mathMax","Math","max","mathMin","min","_customShapeMap","extendShape","opts","extendPathFromString","extendFromString","extendPath","pathData","registerShape","name","ShapeClass","getShapeClass","hasOwnProperty","makePath","rect","layout","path","createFromString","centerGraphic","getBoundingRect","resizePath","makeImage","imageUrl","zrImg","style","image","x","y","width","height","onload","img","boundingRect","setStyle","aspect","cx","cy","mergePath","applyTransform","pathRect","m","calculateTransform","subPixelOptimizeLine","param","shape","subPixelOptimizeRect","subPixelOptimize","animateOrSetProps","animationType","el","props","animatableModel","dataIndex","cb","during","isFrom","removeOpt","isUpdate","isRemove","animationPayload","ecModel","updatePayload","getUpdatePayload","animation","animationEnabled","isAnimationEnabled","stopAnimation","duration","animationEasing","animationDelay","easing","delay","getShallow","getAnimationDelayParams","animateFrom","done","force","scope","animateTo","setToFinal","attr","updateProps","initProps","removeElement","isElementRemoved","fadeOutDisplayable","removeTextContent","removeTextGuideLine","opacity","removeElementWithFadeOut","doRemove","parent","remove","isGroup","traverse","disp","__zr","i","animators","length","animator","getTransform","target","ancestor","mat","identity","mul","getLocalTransform","transform","invert","transformDirection","direction","hBase","abs","vBase","vertex","isNotGroup","isPath","groupTransition","g1","g2","getElMap","g","elMap","anid","getAnimatableProps","obj","rotation","elMap1","oldEl","newProp","clipPointsByRect","points","point","clipRectByRect","targetRect","x2","y2","createIcon","iconStr","opt","innerOpts","rectHover","strokeNoScale","indexOf","slice","replace","linePolygonIntersect","a1x","a1y","a2x","a2y","p2","p","lineLineIntersect","b1x","b1y","b2x","b2y","mx","my","nx","ny","nmCrossProduct","crossProduct2d","nearZero","b1a1x","b1a1y","q","x1","y1","val","setTooltipConfig","itemTooltipOption","componentModel","itemName","itemTooltipOptionObj","formatter","mainType","componentIndex","formatterParams","componentType","$vars","formatterParamsExtra","key","push","ecData","componentMainType","tooltipConfig","option","content","Image","Text"],"sources":["/Users/jiong/Downloads/my-app/node_modules/echarts/lib/util/graphic.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport * as pathTool from 'zrender/lib/tool/path';\nimport * as matrix from 'zrender/lib/core/matrix';\nimport * as vector from 'zrender/lib/core/vector';\nimport Path from 'zrender/lib/graphic/Path';\nimport Transformable from 'zrender/lib/core/Transformable';\nimport ZRImage from 'zrender/lib/graphic/Image';\nimport Group from 'zrender/lib/graphic/Group';\nimport ZRText from 'zrender/lib/graphic/Text';\nimport Circle from 'zrender/lib/graphic/shape/Circle';\nimport Ellipse from 'zrender/lib/graphic/shape/Ellipse';\nimport Sector from 'zrender/lib/graphic/shape/Sector';\nimport Ring from 'zrender/lib/graphic/shape/Ring';\nimport Polygon from 'zrender/lib/graphic/shape/Polygon';\nimport Polyline from 'zrender/lib/graphic/shape/Polyline';\nimport Rect from 'zrender/lib/graphic/shape/Rect';\nimport Line from 'zrender/lib/graphic/shape/Line';\nimport BezierCurve from 'zrender/lib/graphic/shape/BezierCurve';\nimport Arc from 'zrender/lib/graphic/shape/Arc';\nimport CompoundPath from 'zrender/lib/graphic/CompoundPath';\nimport LinearGradient from 'zrender/lib/graphic/LinearGradient';\nimport RadialGradient from 'zrender/lib/graphic/RadialGradient';\nimport BoundingRect from 'zrender/lib/core/BoundingRect';\nimport OrientedBoundingRect from 'zrender/lib/core/OrientedBoundingRect';\nimport Point from 'zrender/lib/core/Point';\nimport IncrementalDisplayable from 'zrender/lib/graphic/IncrementalDisplayable';\nimport * as subPixelOptimizeUtil from 'zrender/lib/graphic/helper/subPixelOptimize';\nimport { extend, isArrayLike, map, defaults, isObject, retrieve2, isString, keys, each, hasOwn } from 'zrender/lib/core/util';\nimport { getECData } from './innerStore';\nvar mathMax = Math.max;\nvar mathMin = Math.min;\nvar _customShapeMap = {};\n/**\n * Extend shape with parameters\n */\n\nexport function extendShape(opts) {\n  return Path.extend(opts);\n}\nvar extendPathFromString = pathTool.extendFromString;\n/**\n * Extend path\n */\n\nexport function extendPath(pathData, opts) {\n  return extendPathFromString(pathData, opts);\n}\n/**\n * Register a user defined shape.\n * The shape class can be fetched by `getShapeClass`\n * This method will overwrite the registered shapes, including\n * the registered built-in shapes, if using the same `name`.\n * The shape can be used in `custom series` and\n * `graphic component` by declaring `{type: name}`.\n *\n * @param name\n * @param ShapeClass Can be generated by `extendShape`.\n */\n\nexport function registerShape(name, ShapeClass) {\n  _customShapeMap[name] = ShapeClass;\n}\n/**\n * Find shape class registered by `registerShape`. Usually used in\n * fetching user defined shape.\n *\n * [Caution]:\n * (1) This method **MUST NOT be used inside echarts !!!**, unless it is prepared\n * to use user registered shapes.\n * Because the built-in shape (see `getBuiltInShape`) will be registered by\n * `registerShape` by default. That enables users to get both built-in\n * shapes as well as the shapes belonging to themsleves. But users can overwrite\n * the built-in shapes by using names like 'circle', 'rect' via calling\n * `registerShape`. So the echarts inner featrues should not fetch shapes from here\n * in case that it is overwritten by users, except that some features, like\n * `custom series`, `graphic component`, do it deliberately.\n *\n * (2) In the features like `custom series`, `graphic component`, the user input\n * `{tpye: 'xxx'}` does not only specify shapes but also specify other graphic\n * elements like `'group'`, `'text'`, `'image'` or event `'path'`. Those names\n * are reserved names, that is, if some user register a shape named `'image'`,\n * the shape will not be used. If we intending to add some more reserved names\n * in feature, that might bring break changes (disable some existing user shape\n * names). But that case probably rearly happen. So we dont make more mechanism\n * to resolve this issue here.\n *\n * @param name\n * @return The shape class. If not found, return nothing.\n */\n\nexport function getShapeClass(name) {\n  if (_customShapeMap.hasOwnProperty(name)) {\n    return _customShapeMap[name];\n  }\n}\n/**\n * Create a path element from path data string\n * @param pathData\n * @param opts\n * @param rect\n * @param layout 'center' or 'cover' default to be cover\n */\n\nexport function makePath(pathData, opts, rect, layout) {\n  var path = pathTool.createFromString(pathData, opts);\n\n  if (rect) {\n    if (layout === 'center') {\n      rect = centerGraphic(rect, path.getBoundingRect());\n    }\n\n    resizePath(path, rect);\n  }\n\n  return path;\n}\n/**\n * Create a image element from image url\n * @param imageUrl image url\n * @param opts options\n * @param rect constrain rect\n * @param layout 'center' or 'cover'. Default to be 'cover'\n */\n\nexport function makeImage(imageUrl, rect, layout) {\n  var zrImg = new ZRImage({\n    style: {\n      image: imageUrl,\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    },\n    onload: function (img) {\n      if (layout === 'center') {\n        var boundingRect = {\n          width: img.width,\n          height: img.height\n        };\n        zrImg.setStyle(centerGraphic(rect, boundingRect));\n      }\n    }\n  });\n  return zrImg;\n}\n/**\n * Get position of centered element in bounding box.\n *\n * @param  rect         element local bounding box\n * @param  boundingRect constraint bounding box\n * @return element position containing x, y, width, and height\n */\n\nfunction centerGraphic(rect, boundingRect) {\n  // Set rect to center, keep width / height ratio.\n  var aspect = boundingRect.width / boundingRect.height;\n  var width = rect.height * aspect;\n  var height;\n\n  if (width <= rect.width) {\n    height = rect.height;\n  } else {\n    width = rect.width;\n    height = width / aspect;\n  }\n\n  var cx = rect.x + rect.width / 2;\n  var cy = rect.y + rect.height / 2;\n  return {\n    x: cx - width / 2,\n    y: cy - height / 2,\n    width: width,\n    height: height\n  };\n}\n\nexport var mergePath = pathTool.mergePath;\n/**\n * Resize a path to fit the rect\n * @param path\n * @param rect\n */\n\nexport function resizePath(path, rect) {\n  if (!path.applyTransform) {\n    return;\n  }\n\n  var pathRect = path.getBoundingRect();\n  var m = pathRect.calculateTransform(rect);\n  path.applyTransform(m);\n}\n/**\n * Sub pixel optimize line for canvas\n */\n\nexport function subPixelOptimizeLine(param) {\n  subPixelOptimizeUtil.subPixelOptimizeLine(param.shape, param.shape, param.style);\n  return param;\n}\n/**\n * Sub pixel optimize rect for canvas\n */\n\nexport function subPixelOptimizeRect(param) {\n  subPixelOptimizeUtil.subPixelOptimizeRect(param.shape, param.shape, param.style);\n  return param;\n}\n/**\n * Sub pixel optimize for canvas\n *\n * @param position Coordinate, such as x, y\n * @param lineWidth Should be nonnegative integer.\n * @param positiveOrNegative Default false (negative).\n * @return Optimized position.\n */\n\nexport var subPixelOptimize = subPixelOptimizeUtil.subPixelOptimize;\n\nfunction animateOrSetProps(animationType, el, props, animatableModel, dataIndex, cb, during) {\n  var isFrom = false;\n  var removeOpt;\n\n  if (typeof dataIndex === 'function') {\n    during = cb;\n    cb = dataIndex;\n    dataIndex = null;\n  } else if (isObject(dataIndex)) {\n    cb = dataIndex.cb;\n    during = dataIndex.during;\n    isFrom = dataIndex.isFrom;\n    removeOpt = dataIndex.removeOpt;\n    dataIndex = dataIndex.dataIndex;\n  }\n\n  var isUpdate = animationType === 'update';\n  var isRemove = animationType === 'remove';\n  var animationPayload; // Check if there is global animation configuration from dataZoom/resize can override the config in option.\n  // If animation is enabled. Will use this animation config in payload.\n  // If animation is disabled. Just ignore it.\n\n  if (animatableModel && animatableModel.ecModel) {\n    var updatePayload = animatableModel.ecModel.getUpdatePayload();\n    animationPayload = updatePayload && updatePayload.animation;\n  }\n\n  var animationEnabled = animatableModel && animatableModel.isAnimationEnabled();\n\n  if (!isRemove) {\n    // Must stop the remove animation.\n    el.stopAnimation('remove');\n  }\n\n  if (animationEnabled) {\n    var duration = void 0;\n    var animationEasing = void 0;\n    var animationDelay = void 0;\n\n    if (animationPayload) {\n      duration = animationPayload.duration || 0;\n      animationEasing = animationPayload.easing || 'cubicOut';\n      animationDelay = animationPayload.delay || 0;\n    } else if (isRemove) {\n      removeOpt = removeOpt || {};\n      duration = retrieve2(removeOpt.duration, 200);\n      animationEasing = retrieve2(removeOpt.easing, 'cubicOut');\n      animationDelay = 0;\n    } else {\n      duration = animatableModel.getShallow(isUpdate ? 'animationDurationUpdate' : 'animationDuration');\n      animationEasing = animatableModel.getShallow(isUpdate ? 'animationEasingUpdate' : 'animationEasing');\n      animationDelay = animatableModel.getShallow(isUpdate ? 'animationDelayUpdate' : 'animationDelay');\n    }\n\n    if (typeof animationDelay === 'function') {\n      animationDelay = animationDelay(dataIndex, animatableModel.getAnimationDelayParams ? animatableModel.getAnimationDelayParams(el, dataIndex) : null);\n    }\n\n    if (typeof duration === 'function') {\n      duration = duration(dataIndex);\n    }\n\n    duration > 0 ? isFrom ? el.animateFrom(props, {\n      duration: duration,\n      delay: animationDelay || 0,\n      easing: animationEasing,\n      done: cb,\n      force: !!cb || !!during,\n      scope: animationType,\n      during: during\n    }) : el.animateTo(props, {\n      duration: duration,\n      delay: animationDelay || 0,\n      easing: animationEasing,\n      done: cb,\n      force: !!cb || !!during,\n      setToFinal: true,\n      scope: animationType,\n      during: during\n    }) : ( // FIXME:\n    // If `duration` is 0, only the animation on props\n    // can be stoped, other animation should be continued?\n    // But at present using duration 0 in `animateTo`, `animateFrom`\n    // might cause unexpected behavior.\n    el.stopAnimation(), // If `isFrom`, the props is the \"from\" props.\n    !isFrom && el.attr(props), cb && cb());\n  } else {\n    el.stopAnimation();\n    !isFrom && el.attr(props); // Call during once.\n\n    during && during(1);\n    cb && cb();\n  }\n}\n/**\n * Update graphic element properties with or without animation according to the\n * configuration in series.\n *\n * Caution: this method will stop previous animation.\n * So do not use this method to one element twice before\n * animation starts, unless you know what you are doing.\n * @example\n *     graphic.updateProps(el, {\n *         position: [100, 100]\n *     }, seriesModel, dataIndex, function () { console.log('Animation done!'); });\n *     // Or\n *     graphic.updateProps(el, {\n *         position: [100, 100]\n *     }, seriesModel, function () { console.log('Animation done!'); });\n */\n\n\nfunction updateProps(el, props, // TODO: TYPE AnimatableModel\nanimatableModel, dataIndex, cb, during) {\n  animateOrSetProps('update', el, props, animatableModel, dataIndex, cb, during);\n}\n\nexport { updateProps };\n/**\n * Init graphic element properties with or without animation according to the\n * configuration in series.\n *\n * Caution: this method will stop previous animation.\n * So do not use this method to one element twice before\n * animation starts, unless you know what you are doing.\n */\n\nexport function initProps(el, props, animatableModel, dataIndex, cb, during) {\n  animateOrSetProps('init', el, props, animatableModel, dataIndex, cb, during);\n}\n/**\n * Remove graphic element\n */\n\nexport function removeElement(el, props, animatableModel, dataIndex, cb, during) {\n  // Don't do remove animation twice.\n  if (isElementRemoved(el)) {\n    return;\n  }\n\n  animateOrSetProps('remove', el, props, animatableModel, dataIndex, cb, during);\n}\n\nfunction fadeOutDisplayable(el, animatableModel, dataIndex, done) {\n  el.removeTextContent();\n  el.removeTextGuideLine();\n  removeElement(el, {\n    style: {\n      opacity: 0\n    }\n  }, animatableModel, dataIndex, done);\n}\n\nexport function removeElementWithFadeOut(el, animatableModel, dataIndex) {\n  function doRemove() {\n    el.parent && el.parent.remove(el);\n  } // Hide label and labelLine first\n  // TODO Also use fade out animation?\n\n\n  if (!el.isGroup) {\n    fadeOutDisplayable(el, animatableModel, dataIndex, doRemove);\n  } else {\n    el.traverse(function (disp) {\n      if (!disp.isGroup) {\n        // Can invoke doRemove multiple times.\n        fadeOutDisplayable(disp, animatableModel, dataIndex, doRemove);\n      }\n    });\n  }\n}\n/**\n * If element is removed.\n * It can determine if element is having remove animation.\n */\n\nexport function isElementRemoved(el) {\n  if (!el.__zr) {\n    return true;\n  }\n\n  for (var i = 0; i < el.animators.length; i++) {\n    var animator = el.animators[i];\n\n    if (animator.scope === 'remove') {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n * Get transform matrix of target (param target),\n * in coordinate of its ancestor (param ancestor)\n *\n * @param target\n * @param [ancestor]\n */\n\nexport function getTransform(target, ancestor) {\n  var mat = matrix.identity([]);\n\n  while (target && target !== ancestor) {\n    matrix.mul(mat, target.getLocalTransform(), mat);\n    target = target.parent;\n  }\n\n  return mat;\n}\n/**\n * Apply transform to an vertex.\n * @param target [x, y]\n * @param transform Can be:\n *      + Transform matrix: like [1, 0, 0, 1, 0, 0]\n *      + {position, rotation, scale}, the same as `zrender/Transformable`.\n * @param invert Whether use invert matrix.\n * @return [x, y]\n */\n\nexport function applyTransform(target, transform, invert) {\n  if (transform && !isArrayLike(transform)) {\n    transform = Transformable.getLocalTransform(transform);\n  }\n\n  if (invert) {\n    transform = matrix.invert([], transform);\n  }\n\n  return vector.applyTransform([], target, transform);\n}\n/**\n * @param direction 'left' 'right' 'top' 'bottom'\n * @param transform Transform matrix: like [1, 0, 0, 1, 0, 0]\n * @param invert Whether use invert matrix.\n * @return Transformed direction. 'left' 'right' 'top' 'bottom'\n */\n\nexport function transformDirection(direction, transform, invert) {\n  // Pick a base, ensure that transform result will not be (0, 0).\n  var hBase = transform[4] === 0 || transform[5] === 0 || transform[0] === 0 ? 1 : Math.abs(2 * transform[4] / transform[0]);\n  var vBase = transform[4] === 0 || transform[5] === 0 || transform[2] === 0 ? 1 : Math.abs(2 * transform[4] / transform[2]);\n  var vertex = [direction === 'left' ? -hBase : direction === 'right' ? hBase : 0, direction === 'top' ? -vBase : direction === 'bottom' ? vBase : 0];\n  vertex = applyTransform(vertex, transform, invert);\n  return Math.abs(vertex[0]) > Math.abs(vertex[1]) ? vertex[0] > 0 ? 'right' : 'left' : vertex[1] > 0 ? 'bottom' : 'top';\n}\n\nfunction isNotGroup(el) {\n  return !el.isGroup;\n}\n\nfunction isPath(el) {\n  return el.shape != null;\n}\n/**\n * Apply group transition animation from g1 to g2.\n * If no animatableModel, no animation.\n */\n\n\nexport function groupTransition(g1, g2, animatableModel) {\n  if (!g1 || !g2) {\n    return;\n  }\n\n  function getElMap(g) {\n    var elMap = {};\n    g.traverse(function (el) {\n      if (isNotGroup(el) && el.anid) {\n        elMap[el.anid] = el;\n      }\n    });\n    return elMap;\n  }\n\n  function getAnimatableProps(el) {\n    var obj = {\n      x: el.x,\n      y: el.y,\n      rotation: el.rotation\n    };\n\n    if (isPath(el)) {\n      obj.shape = extend({}, el.shape);\n    }\n\n    return obj;\n  }\n\n  var elMap1 = getElMap(g1);\n  g2.traverse(function (el) {\n    if (isNotGroup(el) && el.anid) {\n      var oldEl = elMap1[el.anid];\n\n      if (oldEl) {\n        var newProp = getAnimatableProps(el);\n        el.attr(getAnimatableProps(oldEl));\n        updateProps(el, newProp, animatableModel, getECData(el).dataIndex);\n      }\n    }\n  });\n}\nexport function clipPointsByRect(points, rect) {\n  // FIXME: this way migth be incorrect when grpahic clipped by a corner.\n  // and when element have border.\n  return map(points, function (point) {\n    var x = point[0];\n    x = mathMax(x, rect.x);\n    x = mathMin(x, rect.x + rect.width);\n    var y = point[1];\n    y = mathMax(y, rect.y);\n    y = mathMin(y, rect.y + rect.height);\n    return [x, y];\n  });\n}\n/**\n * Return a new clipped rect. If rect size are negative, return undefined.\n */\n\nexport function clipRectByRect(targetRect, rect) {\n  var x = mathMax(targetRect.x, rect.x);\n  var x2 = mathMin(targetRect.x + targetRect.width, rect.x + rect.width);\n  var y = mathMax(targetRect.y, rect.y);\n  var y2 = mathMin(targetRect.y + targetRect.height, rect.y + rect.height); // If the total rect is cliped, nothing, including the border,\n  // should be painted. So return undefined.\n\n  if (x2 >= x && y2 >= y) {\n    return {\n      x: x,\n      y: y,\n      width: x2 - x,\n      height: y2 - y\n    };\n  }\n}\nexport function createIcon(iconStr, // Support 'image://' or 'path://' or direct svg path.\nopt, rect) {\n  var innerOpts = extend({\n    rectHover: true\n  }, opt);\n  var style = innerOpts.style = {\n    strokeNoScale: true\n  };\n  rect = rect || {\n    x: -1,\n    y: -1,\n    width: 2,\n    height: 2\n  };\n\n  if (iconStr) {\n    return iconStr.indexOf('image://') === 0 ? (style.image = iconStr.slice(8), defaults(style, rect), new ZRImage(innerOpts)) : makePath(iconStr.replace('path://', ''), innerOpts, rect, 'center');\n  }\n}\n/**\n * Return `true` if the given line (line `a`) and the given polygon\n * are intersect.\n * Note that we do not count colinear as intersect here because no\n * requirement for that. We could do that if required in future.\n */\n\nexport function linePolygonIntersect(a1x, a1y, a2x, a2y, points) {\n  for (var i = 0, p2 = points[points.length - 1]; i < points.length; i++) {\n    var p = points[i];\n\n    if (lineLineIntersect(a1x, a1y, a2x, a2y, p[0], p[1], p2[0], p2[1])) {\n      return true;\n    }\n\n    p2 = p;\n  }\n}\n/**\n * Return `true` if the given two lines (line `a` and line `b`)\n * are intersect.\n * Note that we do not count colinear as intersect here because no\n * requirement for that. We could do that if required in future.\n */\n\nexport function lineLineIntersect(a1x, a1y, a2x, a2y, b1x, b1y, b2x, b2y) {\n  // let `vec_m` to be `vec_a2 - vec_a1` and `vec_n` to be `vec_b2 - vec_b1`.\n  var mx = a2x - a1x;\n  var my = a2y - a1y;\n  var nx = b2x - b1x;\n  var ny = b2y - b1y; // `vec_m` and `vec_n` are parallel iff\n  //     exising `k` such that `vec_m = k · vec_n`, equivalent to `vec_m X vec_n = 0`.\n\n  var nmCrossProduct = crossProduct2d(nx, ny, mx, my);\n\n  if (nearZero(nmCrossProduct)) {\n    return false;\n  } // `vec_m` and `vec_n` are intersect iff\n  //     existing `p` and `q` in [0, 1] such that `vec_a1 + p * vec_m = vec_b1 + q * vec_n`,\n  //     such that `q = ((vec_a1 - vec_b1) X vec_m) / (vec_n X vec_m)`\n  //           and `p = ((vec_a1 - vec_b1) X vec_n) / (vec_n X vec_m)`.\n\n\n  var b1a1x = a1x - b1x;\n  var b1a1y = a1y - b1y;\n  var q = crossProduct2d(b1a1x, b1a1y, mx, my) / nmCrossProduct;\n\n  if (q < 0 || q > 1) {\n    return false;\n  }\n\n  var p = crossProduct2d(b1a1x, b1a1y, nx, ny) / nmCrossProduct;\n\n  if (p < 0 || p > 1) {\n    return false;\n  }\n\n  return true;\n}\n/**\n * Cross product of 2-dimension vector.\n */\n\nfunction crossProduct2d(x1, y1, x2, y2) {\n  return x1 * y2 - x2 * y1;\n}\n\nfunction nearZero(val) {\n  return val <= 1e-6 && val >= -1e-6;\n}\n\nexport function setTooltipConfig(opt) {\n  var itemTooltipOption = opt.itemTooltipOption;\n  var componentModel = opt.componentModel;\n  var itemName = opt.itemName;\n  var itemTooltipOptionObj = isString(itemTooltipOption) ? {\n    formatter: itemTooltipOption\n  } : itemTooltipOption;\n  var mainType = componentModel.mainType;\n  var componentIndex = componentModel.componentIndex;\n  var formatterParams = {\n    componentType: mainType,\n    name: itemName,\n    $vars: ['name']\n  };\n  formatterParams[mainType + 'Index'] = componentIndex;\n  var formatterParamsExtra = opt.formatterParamsExtra;\n\n  if (formatterParamsExtra) {\n    each(keys(formatterParamsExtra), function (key) {\n      if (!hasOwn(formatterParams, key)) {\n        formatterParams[key] = formatterParamsExtra[key];\n        formatterParams.$vars.push(key);\n      }\n    });\n  }\n\n  var ecData = getECData(opt.el);\n  ecData.componentMainType = mainType;\n  ecData.componentIndex = componentIndex;\n  ecData.tooltipConfig = {\n    name: itemName,\n    option: defaults({\n      content: itemName,\n      formatterParams: formatterParams\n    }, itemTooltipOptionObj)\n  };\n} // Register built-in shapes. These shapes might be overwirtten\n// by users, although we do not recommend that.\n\nregisterShape('circle', Circle);\nregisterShape('ellipse', Ellipse);\nregisterShape('sector', Sector);\nregisterShape('ring', Ring);\nregisterShape('polygon', Polygon);\nregisterShape('polyline', Polyline);\nregisterShape('rect', Rect);\nregisterShape('line', Line);\nregisterShape('bezierCurve', BezierCurve);\nregisterShape('arc', Arc);\nexport { Group, ZRImage as Image, ZRText as Text, Circle, Ellipse, Sector, Ring, Polygon, Polyline, Rect, Line, BezierCurve, Arc, IncrementalDisplayable, CompoundPath, LinearGradient, RadialGradient, BoundingRect, OrientedBoundingRect, Point, Path };"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}