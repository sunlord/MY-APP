{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport { hasOwn, assert, isString, retrieve2, retrieve3, defaults, each, keys, isArrayLike, bind, isFunction, eqNaN, indexOf, clone } from 'zrender/lib/core/util';\nimport * as graphicUtil from '../../util/graphic';\nimport { setDefaultStateProxy, enableHoverEmphasis } from '../../util/states';\nimport * as labelStyleHelper from '../../label/labelStyle';\nimport { getDefaultLabel } from '../helper/labelHelper';\nimport createListFromArray from '../helper/createListFromArray';\nimport { getLayoutOnAxis } from '../../layout/barGrid';\nimport DataDiffer from '../../data/DataDiffer';\nimport SeriesModel from '../../model/Series';\nimport ChartView from '../../view/Chart';\nimport { createClipPath } from '../helper/createClipPathFromCoordSys';\nimport prepareCartesian2d from '../../coord/cartesian/prepareCustom';\nimport prepareGeo from '../../coord/geo/prepareCustom';\nimport prepareSingleAxis from '../../coord/single/prepareCustom';\nimport preparePolar from '../../coord/polar/prepareCustom';\nimport prepareCalendar from '../../coord/calendar/prepareCustom';\nimport { makeInner, normalizeToArray } from '../../util/model';\nimport { convertToEC4StyleForCustomSerise, isEC4CompatibleStyle, convertFromEC4CompatibleStyle, warnDeprecated } from '../../util/styleCompat';\nimport Transformable from 'zrender/lib/core/Transformable';\nimport { cloneValue } from 'zrender/lib/animation/Animator';\nimport { warn, throwError } from '../../util/log';\nimport { combine, isInAnyMorphing, morphPath, isCombiningPath, separate } from 'zrender/lib/tool/morphPath';\nimport * as matrix from 'zrender/lib/core/matrix';\nimport { createOrUpdatePatternFromDecal } from '../../util/decal';\nvar inner = makeInner();\nvar TRANSFORM_PROPS = {\n  x: 1,\n  y: 1,\n  scaleX: 1,\n  scaleY: 1,\n  originX: 1,\n  originY: 1,\n  rotation: 1\n};\nvar transformPropNamesStr = keys(TRANSFORM_PROPS).join(', ');\n; // Also compat with ec4, where\n// `visual('color') visual('borderColor')` is supported.\n\nvar STYLE_VISUAL_TYPE = {\n  color: 'fill',\n  borderColor: 'stroke'\n};\nvar NON_STYLE_VISUAL_PROPS = {\n  symbol: 1,\n  symbolSize: 1,\n  symbolKeepAspect: 1,\n  legendIcon: 1,\n  visualMeta: 1,\n  liftZ: 1,\n  decal: 1\n};\nvar EMPHASIS = 'emphasis';\nvar NORMAL = 'normal';\nvar BLUR = 'blur';\nvar SELECT = 'select';\nvar STATES = [NORMAL, EMPHASIS, BLUR, SELECT];\nvar PATH_ITEM_STYLE = {\n  normal: ['itemStyle'],\n  emphasis: [EMPHASIS, 'itemStyle'],\n  blur: [BLUR, 'itemStyle'],\n  select: [SELECT, 'itemStyle']\n};\nvar PATH_LABEL = {\n  normal: ['label'],\n  emphasis: [EMPHASIS, 'label'],\n  blur: [BLUR, 'label'],\n  select: [SELECT, 'label']\n}; // Use prefix to avoid index to be the same as el.name,\n// which will cause weird update animation.\n\nvar GROUP_DIFF_PREFIX = 'e\\0\\0';\nvar attachedTxInfoTmp = {\n  normal: {},\n  emphasis: {},\n  blur: {},\n  select: {}\n};\nvar LEGACY_TRANSFORM_PROPS = {\n  position: ['x', 'y'],\n  scale: ['scaleX', 'scaleY'],\n  origin: ['originX', 'originY']\n};\nvar tmpTransformable = new Transformable();\n/**\n * To reduce total package size of each coordinate systems, the modules `prepareCustom`\n * of each coordinate systems are not required by each coordinate systems directly, but\n * required by the module `custom`.\n *\n * prepareInfoForCustomSeries {Function}: optional\n *     @return {Object} {coordSys: {...}, api: {\n *         coord: function (data, clamp) {}, // return point in global.\n *         size: function (dataSize, dataItem) {} // return size of each axis in coordSys.\n *     }}\n */\n\nvar prepareCustoms = {\n  cartesian2d: prepareCartesian2d,\n  geo: prepareGeo,\n  singleAxis: prepareSingleAxis,\n  polar: preparePolar,\n  calendar: prepareCalendar\n};\nvar CustomSeriesModel = /** @class */\nfunction (_super) {\n  __extends(CustomSeriesModel, _super);\n  function CustomSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = CustomSeriesModel.type;\n    return _this;\n  }\n  CustomSeriesModel.prototype.optionUpdated = function () {\n    this.currentZLevel = this.get('zlevel', true);\n    this.currentZ = this.get('z', true);\n  };\n  CustomSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  };\n  CustomSeriesModel.prototype.getDataParams = function (dataIndex, dataType, el) {\n    var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);\n    el && (params.info = inner(el).info);\n    return params;\n  };\n  CustomSeriesModel.type = 'series.custom';\n  CustomSeriesModel.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar'];\n  CustomSeriesModel.defaultOption = {\n    coordinateSystem: 'cartesian2d',\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    // Custom series will not clip by default.\n    // Some case will use custom series to draw label\n    // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight\n    clip: false // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // Polar coordinate system\n    // polarIndex: 0,\n    // Geo coordinate system\n    // geoIndex: 0,\n  };\n\n  return CustomSeriesModel;\n}(SeriesModel);\nvar CustomSeriesView = /** @class */\nfunction (_super) {\n  __extends(CustomSeriesView, _super);\n  function CustomSeriesView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = CustomSeriesView.type;\n    return _this;\n  }\n  CustomSeriesView.prototype.render = function (customSeries, ecModel, api, payload) {\n    var oldData = this._data;\n    var data = customSeries.getData();\n    var group = this.group;\n    var renderItem = makeRenderItem(customSeries, data, ecModel, api);\n    if (!oldData) {\n      // Previous render is incremental render or first render.\n      // Needs remove the incremental rendered elements.\n      group.removeAll();\n    } // By default, merge mode is applied. In most cases, custom series is\n    // used in the scenario that data amount is not large but graphic elements\n    // is complicated, where merge mode is probably necessary for optimization.\n    // For example, reuse graphic elements and only update the transform when\n    // roam or data zoom according to `actionType`.\n\n    var transOpt = customSeries.__transientTransitionOpt; // Enable user to disable transition animation by both set\n    // `from` and `to` dimension as `null`/`undefined`.\n\n    if (transOpt && (transOpt.from == null || transOpt.to == null)) {\n      oldData && oldData.each(function (oldIdx) {\n        doRemoveEl(oldData.getItemGraphicEl(oldIdx), customSeries, group);\n      });\n      data.each(function (newIdx) {\n        createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data, null);\n      });\n    } else {\n      var morphPreparation_1 = new MorphPreparation(customSeries, transOpt);\n      var diffMode = transOpt ? 'multiple' : 'oneToOne';\n      new DataDiffer(oldData ? oldData.getIndices() : [], data.getIndices(), createGetKey(oldData, diffMode, transOpt && transOpt.from), createGetKey(data, diffMode, transOpt && transOpt.to), null, diffMode).add(function (newIdx) {\n        createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data, null);\n      }).remove(function (oldIdx) {\n        doRemoveEl(oldData.getItemGraphicEl(oldIdx), customSeries, group);\n      }).update(function (newIdx, oldIdx) {\n        morphPreparation_1.reset('oneToOne');\n        var oldEl = oldData.getItemGraphicEl(oldIdx);\n        morphPreparation_1.findAndAddFrom(oldEl); // PENDING:\n        // if may morph, currently we alway recreate the whole el.\n        // because if reuse some of the el in the group tree, the old el has to\n        // be removed from the group, and consequently we can not calculate\n        // the \"global transition\" of the old element.\n        // But is there performance issue?\n\n        if (morphPreparation_1.hasFrom()) {\n          removeElementDirectly(oldEl, group);\n          oldEl = null;\n        }\n        createOrUpdateItem(api, oldEl, newIdx, renderItem(newIdx, payload), customSeries, group, data, morphPreparation_1);\n        morphPreparation_1.applyMorphing();\n      }).updateManyToOne(function (newIdx, oldIndices) {\n        morphPreparation_1.reset('manyToOne');\n        for (var i = 0; i < oldIndices.length; i++) {\n          var oldEl = oldData.getItemGraphicEl(oldIndices[i]);\n          morphPreparation_1.findAndAddFrom(oldEl);\n          removeElementDirectly(oldEl, group);\n        }\n        createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data, morphPreparation_1);\n        morphPreparation_1.applyMorphing();\n      }).updateOneToMany(function (newIndices, oldIdx) {\n        morphPreparation_1.reset('oneToMany');\n        var newLen = newIndices.length;\n        var oldEl = oldData.getItemGraphicEl(oldIdx);\n        morphPreparation_1.findAndAddFrom(oldEl);\n        removeElementDirectly(oldEl, group);\n        for (var i = 0; i < newLen; i++) {\n          createOrUpdateItem(api, null, newIndices[i], renderItem(newIndices[i], payload), customSeries, group, data, morphPreparation_1);\n        }\n        morphPreparation_1.applyMorphing();\n      }).execute();\n    } // Do clipping\n\n    var clipPath = customSeries.get('clip', true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null;\n    if (clipPath) {\n      group.setClipPath(clipPath);\n    } else {\n      group.removeClipPath();\n    }\n    this._data = data;\n  };\n  CustomSeriesView.prototype.incrementalPrepareRender = function (customSeries, ecModel, api) {\n    this.group.removeAll();\n    this._data = null;\n  };\n  CustomSeriesView.prototype.incrementalRender = function (params, customSeries, ecModel, api, payload) {\n    var data = customSeries.getData();\n    var renderItem = makeRenderItem(customSeries, data, ecModel, api);\n    function setIncrementalAndHoverLayer(el) {\n      if (!el.isGroup) {\n        el.incremental = true;\n        el.ensureState('emphasis').hoverLayer = true;\n      }\n    }\n    for (var idx = params.start; idx < params.end; idx++) {\n      var el = createOrUpdateItem(null, null, idx, renderItem(idx, payload), customSeries, this.group, data, null);\n      el && el.traverse(setIncrementalAndHoverLayer);\n    }\n  };\n  CustomSeriesView.prototype.filterForExposedEvent = function (eventType, query, targetEl, packedEvent) {\n    var elementName = query.element;\n    if (elementName == null || targetEl.name === elementName) {\n      return true;\n    } // Enable to give a name on a group made by `renderItem`, and listen\n    // events that triggerd by its descendents.\n\n    while ((targetEl = targetEl.__hostTarget || targetEl.parent) && targetEl !== this.group) {\n      if (targetEl.name === elementName) {\n        return true;\n      }\n    }\n    return false;\n  };\n  CustomSeriesView.type = 'custom';\n  return CustomSeriesView;\n}(ChartView);\nfunction createGetKey(data, diffMode, dimension) {\n  if (!data) {\n    return;\n  }\n  if (diffMode === 'oneToOne') {\n    return function (rawIdx, dataIndex) {\n      return data.getId(dataIndex);\n    };\n  }\n  var diffByDimName = data.getDimension(dimension);\n  var dimInfo = data.getDimensionInfo(diffByDimName);\n  if (!dimInfo) {\n    var errMsg = '';\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = dimension + \" is not a valid dimension.\";\n    }\n    throwError(errMsg);\n  }\n  var ordinalMeta = dimInfo.ordinalMeta;\n  return function (rawIdx, dataIndex) {\n    var key = data.get(diffByDimName, dataIndex);\n    if (ordinalMeta) {\n      key = ordinalMeta.categories[key];\n    }\n    return key == null || eqNaN(key) ? rawIdx + '' : '_ec_' + key;\n  };\n}\nfunction createEl(elOption) {\n  var graphicType = elOption.type;\n  var el; // Those graphic elements are not shapes. They should not be\n  // overwritten by users, so do them first.\n\n  if (graphicType === 'path') {\n    var shape = elOption.shape; // Using pathRect brings convenience to users sacle svg path.\n\n    var pathRect = shape.width != null && shape.height != null ? {\n      x: shape.x || 0,\n      y: shape.y || 0,\n      width: shape.width,\n      height: shape.height\n    } : null;\n    var pathData = getPathData(shape); // Path is also used for icon, so layout 'center' by default.\n\n    el = graphicUtil.makePath(pathData, null, pathRect, shape.layout || 'center');\n    inner(el).customPathData = pathData;\n  } else if (graphicType === 'image') {\n    el = new graphicUtil.Image({});\n    inner(el).customImagePath = elOption.style.image;\n  } else if (graphicType === 'text') {\n    el = new graphicUtil.Text({}); // inner(el).customText = (elOption.style as TextStyleProps).text;\n  } else if (graphicType === 'group') {\n    el = new graphicUtil.Group();\n  } else if (graphicType === 'compoundPath') {\n    throw new Error('\"compoundPath\" is not supported yet.');\n  } else {\n    var Clz = graphicUtil.getShapeClass(graphicType);\n    if (!Clz) {\n      var errMsg = '';\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'graphic type \"' + graphicType + '\" can not be found.';\n      }\n      throwError(errMsg);\n    }\n    el = new Clz();\n  }\n  inner(el).customGraphicType = graphicType;\n  el.name = elOption.name; // Compat ec4: the default z2 lift is 1. If changing the number,\n  // some cases probably be broken: hierarchy layout along z, like circle packing,\n  // where emphasis only intending to modify color/border rather than lift z2.\n\n  el.z2EmphasisLift = 1;\n  el.z2SelectLift = 1;\n  return el;\n}\n/**\n * ----------------------------------------------------------\n * [STRATEGY_MERGE] Merge properties or erase all properties:\n *\n * Based on the fact that the existing zr element probably be reused, we now consider whether\n * merge or erase all properties to the exsiting elements.\n * That is, if a certain props is not specified in the lastest return of `renderItem`:\n * + \"Merge\" means that do not modify the value on the existing element.\n * + \"Erase all\" means that use a default value to the existing element.\n *\n * \"Merge\" might bring some unexpected state retaining for users and \"erase all\" seams to be\n * more safe. \"erase all\" force users to specify all of the props each time, which is recommanded\n * in most cases.\n * But \"erase all\" theoretically disables the chance of performance optimization (e.g., just\n * generete shape and style at the first time rather than always do that).\n * So we still use \"merge\" rather than \"erase all\". If users need \"erase all\", they can\n * simple always set all of the props each time.\n * Some \"object-like\" config like `textConfig`, `textContent`, `style` which are not needed for\n * every elment, so we replace them only when user specify them. And the that is a total replace.\n *\n * TODO: there is no hint of 'isFirst' to users. So the performance enhancement can not be\n * performed yet. Consider the case:\n * (1) setOption to \"mergeChildren\" with a smaller children count\n * (2) Use dataZoom to make an item disappear.\n * (3) User dataZoom to make the item display again. At that time, renderItem need to return the\n * full option rather than partial option to recreate the element.\n *\n * ----------------------------------------------\n * [STRATEGY_NULL] `hasOwnProperty` or `== null`:\n *\n * Ditinguishing \"own property\" probably bring little trouble to user when make el options.\n * So we  trade a {xx: null} or {xx: undefined} as \"not specified\" if possible rather than\n * \"set them to null/undefined\". In most cases, props can not be cleared. Some typicall\n * clearable props like `style`/`textConfig`/`textContent` we enable `false` to means\n * \"clear\". In some othere special cases that the prop is able to set as null/undefined,\n * but not suitable to use `false`, `hasOwnProperty` is checked.\n *\n * ---------------------------------------------\n * [STRATEGY_TRANSITION] The rule of transition:\n * + For props on the root level of a element:\n *      If there is no `transition` specified, tansform props will be transitioned by default,\n *      which is the same as the previous setting in echarts4 and suitable for the scenario\n *      of dataZoom change.\n *      If `transition` specified, only the specified props will be transitioned.\n * + For props in `shape` and `style`:\n *      Only props specified in `transition` will be transitioned.\n * + Break:\n *      Since ec5, do not make transition to shape by default, because it might result in\n *      performance issue (especially `points` of polygon) and do not necessary in most cases.\n *\n * @return if `isMorphTo`, return `allPropsFinal`.\n */\n\nfunction updateElNormal(\n// Can be null/undefined\napi, el,\n// Whether be a morph target.\nisMorphTo, dataIndex, elOption, styleOpt, attachedTxInfo, seriesModel, isInit, isTextContent) {\n  var transFromProps = {};\n  var allPropsFinal = {};\n  var elDisplayable = el.isGroup ? null : el; // If be \"morph to\", delay the `updateElNormal` when all of the els in\n  // this data item processed. Because at that time we can get all of the\n  // \"morph from\" and make correct separate/combine.\n\n  !isMorphTo && prepareShapeOrExtraTransitionFrom('shape', el, null, elOption, transFromProps, isInit);\n  prepareShapeOrExtraAllPropsFinal('shape', elOption, allPropsFinal);\n  !isMorphTo && prepareShapeOrExtraTransitionFrom('extra', el, null, elOption, transFromProps, isInit);\n  prepareShapeOrExtraAllPropsFinal('extra', elOption, allPropsFinal);\n  !isMorphTo && prepareTransformTransitionFrom(el, null, elOption, transFromProps, isInit);\n  prepareTransformAllPropsFinal(elOption, allPropsFinal);\n  var txCfgOpt = attachedTxInfo && attachedTxInfo.normal.cfg;\n  if (txCfgOpt) {\n    // PENDING: whether use user object directly rather than clone?\n    // TODO:5.0 textConfig transition animation?\n    el.setTextConfig(txCfgOpt);\n  }\n  if (el.type === 'text' && styleOpt) {\n    var textOptionStyle = styleOpt; // Compatible with ec4: if `textFill` or `textStroke` exists use them.\n\n    hasOwn(textOptionStyle, 'textFill') && (textOptionStyle.fill = textOptionStyle.textFill);\n    hasOwn(textOptionStyle, 'textStroke') && (textOptionStyle.stroke = textOptionStyle.textStroke);\n  }\n  if (styleOpt) {\n    var decalPattern = void 0;\n    var decalObj = isPath(el) ? styleOpt.decal : null;\n    if (api && decalObj) {\n      decalObj.dirty = true;\n      decalPattern = createOrUpdatePatternFromDecal(decalObj, api);\n    } // Always overwrite in case user specify this prop.\n\n    styleOpt.__decalPattern = decalPattern;\n  }\n  !isMorphTo && prepareStyleTransitionFrom(el, null, elOption, styleOpt, transFromProps, isInit);\n  if (elDisplayable) {\n    hasOwn(elOption, 'invisible') && (elDisplayable.invisible = elOption.invisible);\n  } // If `isMorphTo`, we should not update these props to el directly, otherwise,\n  // when applying morph finally, the original prop are missing for making \"animation from\".\n\n  if (!isMorphTo) {\n    applyPropsFinal(el, allPropsFinal, styleOpt);\n    applyTransitionFrom(el, dataIndex, elOption, seriesModel, transFromProps, isInit);\n  } // Merge by default.\n\n  hasOwn(elOption, 'silent') && (el.silent = elOption.silent);\n  hasOwn(elOption, 'ignore') && (el.ignore = elOption.ignore);\n  if (!isTextContent) {\n    // `elOption.info` enables user to mount some info on\n    // elements and use them in event handlers.\n    // Update them only when user specified, otherwise, remain.\n    hasOwn(elOption, 'info') && (inner(el).info = elOption.info);\n  }\n  styleOpt ? el.dirty() : el.markRedraw();\n  return isMorphTo ? allPropsFinal : null;\n}\nfunction applyPropsFinal(el,\n// Can be null/undefined\nallPropsFinal, styleOpt) {\n  var elDisplayable = el.isGroup ? null : el;\n  if (elDisplayable && styleOpt) {\n    var decalPattern = styleOpt.__decalPattern;\n    var originalDecalObj = void 0;\n    if (decalPattern) {\n      originalDecalObj = styleOpt.decal;\n      styleOpt.decal = decalPattern;\n    } // PENDING: here the input style object is used directly.\n    // Good for performance but bad for compatibility control.\n\n    elDisplayable.useStyle(styleOpt);\n    if (decalPattern) {\n      styleOpt.decal = originalDecalObj;\n    } // When style object changed, how to trade the existing animation?\n    // It is probably conplicated and not needed to cover all the cases.\n    // But still need consider the case:\n    // (1) When using init animation on `style.opacity`, and before the animation\n    //     ended users triggers an update by mousewhell. At that time the init\n    //     animation should better be continued rather than terminated.\n    //     So after `useStyle` called, we should change the animation target manually\n    //     to continue the effect of the init animation.\n    // (2) PENDING: If the previous animation targeted at a `val1`, and currently we need\n    //     to update the value to `val2` and no animation declared, should be terminate\n    //     the previous animation or just modify the target of the animation?\n    //     Therotically That will happen not only on `style` but also on `shape` and\n    //     `transfrom` props. But we haven't handle this case at present yet.\n    // (3) PENDING: Is it proper to visit `animators` and `targetName`?\n\n    var animators = elDisplayable.animators;\n    for (var i = 0; i < animators.length; i++) {\n      var animator = animators[i]; // targetName is the \"topKey\".\n\n      if (animator.targetName === 'style') {\n        animator.changeTarget(elDisplayable.style);\n      }\n    }\n  } // Set el to the final state firstly.\n\n  allPropsFinal && el.attr(allPropsFinal);\n}\nfunction applyTransitionFrom(el, dataIndex, elOption, seriesModel,\n// Can be null/undefined\ntransFromProps, isInit) {\n  if (transFromProps) {\n    // Do not use `el.updateDuringAnimation` here becuase `el.updateDuringAnimation` will\n    // be called mutiple time in each animation frame. For example, if both \"transform\" props\n    // and shape props and style props changed, it will generate three animator and called\n    // one-by-one in each animation frame.\n    // We use the during in `animateTo/From` params.\n    var userDuring = elOption.during; // For simplicity, if during not specified, the previous during will not work any more.\n\n    inner(el).userDuring = userDuring;\n    var cfgDuringCall = userDuring ? bind(duringCall, {\n      el: el,\n      userDuring: userDuring\n    }) : null;\n    var cfg = {\n      dataIndex: dataIndex,\n      isFrom: true,\n      during: cfgDuringCall\n    };\n    isInit ? graphicUtil.initProps(el, transFromProps, seriesModel, cfg) : graphicUtil.updateProps(el, transFromProps, seriesModel, cfg);\n  }\n} // See [STRATEGY_TRANSITION]\n\nfunction prepareShapeOrExtraTransitionFrom(mainAttr, el, morphFromEl, elOption, transFromProps, isInit) {\n  var attrOpt = elOption[mainAttr];\n  if (!attrOpt) {\n    return;\n  }\n  var elPropsInAttr = el[mainAttr];\n  var transFromPropsInAttr;\n  var enterFrom = attrOpt.enterFrom;\n  if (isInit && enterFrom) {\n    !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n    var enterFromKeys = keys(enterFrom);\n    for (var i = 0; i < enterFromKeys.length; i++) {\n      // `enterFrom` props are not necessarily also declared in `shape`/`style`/...,\n      // for example, `opacity` can only declared in `enterFrom` but not in `style`.\n      var key = enterFromKeys[i]; // Do not clone, animator will perform that clone.\n\n      transFromPropsInAttr[key] = enterFrom[key];\n    }\n  }\n  if (!isInit && elPropsInAttr // Just ignore shape animation in morphing.\n  && !(morphFromEl != null && mainAttr === 'shape')) {\n    if (attrOpt.transition) {\n      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n      var transitionKeys = normalizeToArray(attrOpt.transition);\n      for (var i = 0; i < transitionKeys.length; i++) {\n        var key = transitionKeys[i];\n        var elVal = elPropsInAttr[key];\n        if (process.env.NODE_ENV !== 'production') {\n          checkNonStyleTansitionRefer(key, attrOpt[key], elVal);\n        } // Do not clone, see `checkNonStyleTansitionRefer`.\n\n        transFromPropsInAttr[key] = elVal;\n      }\n    } else if (indexOf(elOption.transition, mainAttr) >= 0) {\n      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n      var elPropsInAttrKeys = keys(elPropsInAttr);\n      for (var i = 0; i < elPropsInAttrKeys.length; i++) {\n        var key = elPropsInAttrKeys[i];\n        var elVal = elPropsInAttr[key];\n        if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {\n          transFromPropsInAttr[key] = elVal;\n        }\n      }\n    }\n  }\n  var leaveTo = attrOpt.leaveTo;\n  if (leaveTo) {\n    var leaveToProps = getOrCreateLeaveToPropsFromEl(el);\n    var leaveToPropsInAttr = leaveToProps[mainAttr] || (leaveToProps[mainAttr] = {});\n    var leaveToKeys = keys(leaveTo);\n    for (var i = 0; i < leaveToKeys.length; i++) {\n      var key = leaveToKeys[i];\n      leaveToPropsInAttr[key] = leaveTo[key];\n    }\n  }\n}\nfunction prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {\n  var attrOpt = elOption[mainAttr];\n  if (!attrOpt) {\n    return;\n  }\n  var allPropsInAttr = allProps[mainAttr] = {};\n  var keysInAttr = keys(attrOpt);\n  for (var i = 0; i < keysInAttr.length; i++) {\n    var key = keysInAttr[i]; // To avoid share one object with different element, and\n    // to avoid user modify the object inexpectedly, have to clone.\n\n    allPropsInAttr[key] = cloneValue(attrOpt[key]);\n  }\n} // See [STRATEGY_TRANSITION].\n\nfunction prepareTransformTransitionFrom(el, morphFromEl, elOption, transFromProps, isInit) {\n  var enterFrom = elOption.enterFrom;\n  if (isInit && enterFrom) {\n    var enterFromKeys = keys(enterFrom);\n    for (var i = 0; i < enterFromKeys.length; i++) {\n      var key = enterFromKeys[i];\n      if (process.env.NODE_ENV !== 'production') {\n        checkTransformPropRefer(key, 'el.enterFrom');\n      } // Do not clone, animator will perform that clone.\n\n      transFromProps[key] = enterFrom[key];\n    }\n  }\n  if (!isInit) {\n    // If morphing, force transition all transform props.\n    // otherwise might have incorrect morphing animation.\n    if (morphFromEl) {\n      var fromTransformable = calcOldElLocalTransformBasedOnNewElParent(morphFromEl, el);\n      setTransformPropToTransitionFrom(transFromProps, 'x', fromTransformable);\n      setTransformPropToTransitionFrom(transFromProps, 'y', fromTransformable);\n      setTransformPropToTransitionFrom(transFromProps, 'scaleX', fromTransformable);\n      setTransformPropToTransitionFrom(transFromProps, 'scaleY', fromTransformable);\n      setTransformPropToTransitionFrom(transFromProps, 'originX', fromTransformable);\n      setTransformPropToTransitionFrom(transFromProps, 'originY', fromTransformable);\n      setTransformPropToTransitionFrom(transFromProps, 'rotation', fromTransformable);\n    } else if (elOption.transition) {\n      var transitionKeys = normalizeToArray(elOption.transition);\n      for (var i = 0; i < transitionKeys.length; i++) {\n        var key = transitionKeys[i];\n        if (key === 'style' || key === 'shape' || key === 'extra') {\n          continue;\n        }\n        var elVal = el[key];\n        if (process.env.NODE_ENV !== 'production') {\n          checkTransformPropRefer(key, 'el.transition');\n          checkNonStyleTansitionRefer(key, elOption[key], elVal);\n        } // Do not clone, see `checkNonStyleTansitionRefer`.\n\n        transFromProps[key] = elVal;\n      }\n    } // This default transition see [STRATEGY_TRANSITION]\n    else {\n      setTransformPropToTransitionFrom(transFromProps, 'x', el);\n      setTransformPropToTransitionFrom(transFromProps, 'y', el);\n    }\n  }\n  var leaveTo = elOption.leaveTo;\n  if (leaveTo) {\n    var leaveToProps = getOrCreateLeaveToPropsFromEl(el);\n    var leaveToKeys = keys(leaveTo);\n    for (var i = 0; i < leaveToKeys.length; i++) {\n      var key = leaveToKeys[i];\n      if (process.env.NODE_ENV !== 'production') {\n        checkTransformPropRefer(key, 'el.leaveTo');\n      }\n      leaveToProps[key] = leaveTo[key];\n    }\n  }\n}\nfunction prepareTransformAllPropsFinal(elOption, allProps) {\n  setLagecyTransformProp(elOption, allProps, 'position');\n  setLagecyTransformProp(elOption, allProps, 'scale');\n  setLagecyTransformProp(elOption, allProps, 'origin');\n  setTransformProp(elOption, allProps, 'x');\n  setTransformProp(elOption, allProps, 'y');\n  setTransformProp(elOption, allProps, 'scaleX');\n  setTransformProp(elOption, allProps, 'scaleY');\n  setTransformProp(elOption, allProps, 'originX');\n  setTransformProp(elOption, allProps, 'originY');\n  setTransformProp(elOption, allProps, 'rotation');\n} // See [STRATEGY_TRANSITION].\n\nfunction prepareStyleTransitionFrom(el, morphFromEl, elOption, styleOpt, transFromProps, isInit) {\n  if (!styleOpt) {\n    return;\n  } // At present in \"many-to-one\"/\"one-to-many\" case, to not support \"many\" have\n  // different styles and make style transitions. That might be a rare case.\n\n  var fromEl = morphFromEl || el;\n  var fromElStyle = fromEl.style;\n  var transFromStyleProps;\n  var enterFrom = styleOpt.enterFrom;\n  if (isInit && enterFrom) {\n    var enterFromKeys = keys(enterFrom);\n    !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n    for (var i = 0; i < enterFromKeys.length; i++) {\n      var key = enterFromKeys[i]; // Do not clone, animator will perform that clone.\n\n      transFromStyleProps[key] = enterFrom[key];\n    }\n  }\n  if (!isInit && fromElStyle) {\n    if (styleOpt.transition) {\n      var transitionKeys = normalizeToArray(styleOpt.transition);\n      !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n      for (var i = 0; i < transitionKeys.length; i++) {\n        var key = transitionKeys[i];\n        var elVal = fromElStyle[key]; // Do not clone, see `checkNonStyleTansitionRefer`.\n\n        transFromStyleProps[key] = elVal;\n      }\n    } else if (el.getAnimationStyleProps && indexOf(elOption.transition, 'style') >= 0) {\n      var animationProps = el.getAnimationStyleProps();\n      var animationStyleProps = animationProps ? animationProps.style : null;\n      if (animationStyleProps) {\n        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n        var styleKeys = keys(styleOpt);\n        for (var i = 0; i < styleKeys.length; i++) {\n          var key = styleKeys[i];\n          if (animationStyleProps[key]) {\n            var elVal = fromElStyle[key];\n            transFromStyleProps[key] = elVal;\n          }\n        }\n      }\n    }\n  }\n  var leaveTo = styleOpt.leaveTo;\n  if (leaveTo) {\n    var leaveToKeys = keys(leaveTo);\n    var leaveToProps = getOrCreateLeaveToPropsFromEl(el);\n    var leaveToStyleProps = leaveToProps.style || (leaveToProps.style = {});\n    for (var i = 0; i < leaveToKeys.length; i++) {\n      var key = leaveToKeys[i];\n      leaveToStyleProps[key] = leaveTo[key];\n    }\n  }\n}\n/**\n * If make \"transform\"(x/y/scaleX/scaleY/orient/originX/originY) transition between\n * two path elements that have different hierarchy, before we retrieve the \"from\" props,\n * we have to calculate the local transition of the \"oldPath\" based on the parent of\n * the \"newPath\".\n * At present, the case only happend in \"morphing\". Without morphing, the transform\n * transition are all between elements in the same hierarchy, where this kind of process\n * is not needed.\n *\n * [CAVEAT]:\n * This method makes sense only if: (very tricky)\n * (1) \"newEl\" has been added to its final parent.\n * (2) Local transform props of \"newPath.parent\" are not at their final value but already\n * have been at the \"from value\".\n *     This is currently ensured by:\n *     (2.1) \"graphicUtil.animationFrom\", which will set the element to the \"from value\"\n *     immediately.\n *     (2.2) \"morph\" option is not allowed to be set on Group, so all of the groups have\n *     been finished their \"updateElNormal\" when calling this method in morphing process.\n */\n\nfunction calcOldElLocalTransformBasedOnNewElParent(oldEl, newEl) {\n  if (!oldEl || oldEl === newEl || oldEl.parent === newEl.parent) {\n    return oldEl;\n  } // Not sure oldEl is rendered (may have \"lazyUpdate\"),\n  // so always call `getComputedTransform`.\n\n  var tmpM = tmpTransformable.transform || (tmpTransformable.transform = matrix.identity([]));\n  var oldGlobalTransform = oldEl.getComputedTransform();\n  oldGlobalTransform ? matrix.copy(tmpM, oldGlobalTransform) : matrix.identity(tmpM);\n  var newParent = newEl.parent;\n  if (newParent) {\n    newParent.getComputedTransform();\n  }\n  tmpTransformable.originX = oldEl.originX;\n  tmpTransformable.originY = oldEl.originY;\n  tmpTransformable.parent = newParent;\n  tmpTransformable.decomposeTransform();\n  return tmpTransformable;\n}\nvar checkNonStyleTansitionRefer;\nif (process.env.NODE_ENV !== 'production') {\n  checkNonStyleTansitionRefer = function (propName, optVal, elVal) {\n    if (!isArrayLike(optVal)) {\n      assert(optVal != null && isFinite(optVal), 'Prop `' + propName + '` must refer to a finite number or ArrayLike for transition.');\n    } else {\n      // Try not to copy array for performance, but if user use the same object in different\n      // call of `renderItem`, it will casue animation transition fail.\n      assert(optVal !== elVal, 'Prop `' + propName + '` must use different Array object each time for transition.');\n    }\n  };\n}\nfunction isNonStyleTransitionEnabled(optVal, elVal) {\n  // The same as `checkNonStyleTansitionRefer`.\n  return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;\n}\nvar checkTransformPropRefer;\nif (process.env.NODE_ENV !== 'production') {\n  checkTransformPropRefer = function (key, usedIn) {\n    assert(hasOwn(TRANSFORM_PROPS, key), 'Prop `' + key + '` is not a permitted in `' + usedIn + '`. ' + 'Only `' + keys(TRANSFORM_PROPS).join('`, `') + '` are permitted.');\n  };\n}\nfunction getOrCreateLeaveToPropsFromEl(el) {\n  var innerEl = inner(el);\n  return innerEl.leaveToProps || (innerEl.leaveToProps = {});\n} // Use it to avoid it be exposed to user.\n\nvar tmpDuringScope = {};\nvar customDuringAPI = {\n  // Usually other props do not need to be changed in animation during.\n  setTransform: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(hasOwn(TRANSFORM_PROPS, key), 'Only ' + transformPropNamesStr + ' available in `setTransform`.');\n    }\n    tmpDuringScope.el[key] = val;\n    return this;\n  },\n  getTransform: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(hasOwn(TRANSFORM_PROPS, key), 'Only ' + transformPropNamesStr + ' available in `getTransform`.');\n    }\n    return tmpDuringScope.el[key];\n  },\n  setShape: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var shape = tmpDuringScope.el.shape || (tmpDuringScope.el.shape = {});\n    shape[key] = val;\n    tmpDuringScope.isShapeDirty = true;\n    return this;\n  },\n  getShape: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var shape = tmpDuringScope.el.shape;\n    if (shape) {\n      return shape[key];\n    }\n  },\n  setStyle: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var style = tmpDuringScope.el.style;\n    if (style) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (eqNaN(val)) {\n          warn('style.' + key + ' must not be assigned with NaN.');\n        }\n      }\n      style[key] = val;\n      tmpDuringScope.isStyleDirty = true;\n    }\n    return this;\n  },\n  getStyle: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var style = tmpDuringScope.el.style;\n    if (style) {\n      return style[key];\n    }\n  },\n  setExtra: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});\n    extra[key] = val;\n    return this;\n  },\n  getExtra: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n    var extra = tmpDuringScope.el.extra;\n    if (extra) {\n      return extra[key];\n    }\n  }\n};\nfunction assertNotReserved(key) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (key === 'transition' || key === 'enterFrom' || key === 'leaveTo') {\n      throw new Error('key must not be \"' + key + '\"');\n    }\n  }\n}\nfunction duringCall() {\n  // Do not provide \"percent\" until some requirements come.\n  // Because consider thies case:\n  // enterFrom: {x: 100, y: 30}, transition: 'x'.\n  // And enter duration is different from update duration.\n  // Thus it might be confused about the meaning of \"percent\" in during callback.\n  var scope = this;\n  var el = scope.el;\n  if (!el) {\n    return;\n  } // If el is remove from zr by reason like legend, during still need to called,\n  // becuase el will be added back to zr and the prop value should not be incorrect.\n\n  var newstUserDuring = inner(el).userDuring;\n  var scopeUserDuring = scope.userDuring; // Ensured a during is only called once in each animation frame.\n  // If a during is called multiple times in one frame, maybe some users' calulation logic\n  // might be wrong (not sure whether this usage exists).\n  // The case of a during might be called twice can be: by default there is a animator for\n  // 'x', 'y' when init. Before the init animation finished, call `setOption` to start\n  // another animators for 'style'/'shape'/'extra'.\n\n  if (newstUserDuring !== scopeUserDuring) {\n    // release\n    scope.el = scope.userDuring = null;\n    return;\n  }\n  tmpDuringScope.el = el;\n  tmpDuringScope.isShapeDirty = false;\n  tmpDuringScope.isStyleDirty = false; // Give no `this` to user in \"during\" calling.\n\n  scopeUserDuring(customDuringAPI);\n  if (tmpDuringScope.isShapeDirty && el.dirtyShape) {\n    el.dirtyShape();\n  }\n  if (tmpDuringScope.isStyleDirty && el.dirtyStyle) {\n    el.dirtyStyle();\n  } // markRedraw() will be called by default in during.\n  // FIXME `this.markRedraw();` directly ?\n  // FIXME: if in future meet the case that some prop will be both modified in `during` and `state`,\n  // consider the issue that the prop might be incorrect when return to \"normal\" state.\n}\n\nfunction updateElOnState(state, el, elStateOpt, styleOpt, attachedTxInfo, isRoot, isTextContent) {\n  var elDisplayable = el.isGroup ? null : el;\n  var txCfgOpt = attachedTxInfo && attachedTxInfo[state].cfg; // PENDING:5.0 support customize scale change and transition animation?\n\n  if (elDisplayable) {\n    // By default support auto lift color when hover whether `emphasis` specified.\n    var stateObj = elDisplayable.ensureState(state);\n    if (styleOpt === false) {\n      var existingEmphasisState = elDisplayable.getState(state);\n      if (existingEmphasisState) {\n        existingEmphasisState.style = null;\n      }\n    } else {\n      // style is needed to enable defaut emphasis.\n      stateObj.style = styleOpt || null;\n    } // If `elOption.styleEmphasis` or `elOption.emphasis.style` is `false`,\n    // remove hover style.\n    // If `elOption.textConfig` or `elOption.emphasis.textConfig` is null/undefined, it does not\n    // make sense. So for simplicity, we do not ditinguish `hasOwnProperty` and null/undefined.\n\n    if (txCfgOpt) {\n      stateObj.textConfig = txCfgOpt;\n    }\n    setDefaultStateProxy(elDisplayable);\n  }\n}\nfunction updateZ(el, elOption, seriesModel, attachedTxInfo) {\n  // Group not support textContent and not support z yet.\n  if (el.isGroup) {\n    return;\n  }\n  var elDisplayable = el;\n  var currentZ = seriesModel.currentZ;\n  var currentZLevel = seriesModel.currentZLevel; // Always erase.\n\n  elDisplayable.z = currentZ;\n  elDisplayable.zlevel = currentZLevel; // z2 must not be null/undefined, otherwise sort error may occur.\n\n  var optZ2 = elOption.z2;\n  optZ2 != null && (elDisplayable.z2 = optZ2 || 0);\n  for (var i = 0; i < STATES.length; i++) {\n    updateZForEachState(elDisplayable, elOption, STATES[i]);\n  }\n}\nfunction updateZForEachState(elDisplayable, elOption, state) {\n  var isNormal = state === NORMAL;\n  var elStateOpt = isNormal ? elOption : retrieveStateOption(elOption, state);\n  var optZ2 = elStateOpt ? elStateOpt.z2 : null;\n  var stateObj;\n  if (optZ2 != null) {\n    // Do not `ensureState` until required.\n    stateObj = isNormal ? elDisplayable : elDisplayable.ensureState(state);\n    stateObj.z2 = optZ2 || 0;\n  }\n}\nfunction setLagecyTransformProp(elOption, targetProps, legacyName, fromTransformable // If provided, retrieve from the element.\n) {\n  var legacyArr = elOption[legacyName];\n  var xyName = LEGACY_TRANSFORM_PROPS[legacyName];\n  if (legacyArr) {\n    if (fromTransformable) {\n      targetProps[xyName[0]] = fromTransformable[xyName[0]];\n      targetProps[xyName[1]] = fromTransformable[xyName[1]];\n    } else {\n      targetProps[xyName[0]] = legacyArr[0];\n      targetProps[xyName[1]] = legacyArr[1];\n    }\n  }\n}\nfunction setTransformProp(elOption, allProps, name, fromTransformable // If provided, retrieve from the element.\n) {\n  if (elOption[name] != null) {\n    allProps[name] = fromTransformable ? fromTransformable[name] : elOption[name];\n  }\n}\nfunction setTransformPropToTransitionFrom(transitionFrom, name, fromTransformable // If provided, retrieve from the element.\n) {\n  if (fromTransformable) {\n    transitionFrom[name] = fromTransformable[name];\n  }\n}\nfunction makeRenderItem(customSeries, data, ecModel, api) {\n  var renderItem = customSeries.get('renderItem');\n  var coordSys = customSeries.coordinateSystem;\n  var prepareResult = {};\n  if (coordSys) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(renderItem, 'series.render is required.');\n      assert(coordSys.prepareCustoms || prepareCustoms[coordSys.type], 'This coordSys does not support custom series.');\n    } // `coordSys.prepareCustoms` is used for external coord sys like bmap.\n\n    prepareResult = coordSys.prepareCustoms ? coordSys.prepareCustoms(coordSys) : prepareCustoms[coordSys.type](coordSys);\n  }\n  var userAPI = defaults({\n    getWidth: api.getWidth,\n    getHeight: api.getHeight,\n    getZr: api.getZr,\n    getDevicePixelRatio: api.getDevicePixelRatio,\n    value: value,\n    style: style,\n    ordinalRawValue: ordinalRawValue,\n    styleEmphasis: styleEmphasis,\n    visual: visual,\n    barLayout: barLayout,\n    currentSeriesIndices: currentSeriesIndices,\n    font: font\n  }, prepareResult.api || {});\n  var userParams = {\n    // The life cycle of context: current round of rendering.\n    // The global life cycle is probably not necessary, because\n    // user can store global status by themselves.\n    context: {},\n    seriesId: customSeries.id,\n    seriesName: customSeries.name,\n    seriesIndex: customSeries.seriesIndex,\n    coordSys: prepareResult.coordSys,\n    dataInsideLength: data.count(),\n    encode: wrapEncodeDef(customSeries.getData())\n  }; // If someday intending to refactor them to a class, should consider do not\n  // break change: currently these attribute member are encapsulated in a closure\n  // so that do not need to force user to call these method with a scope.\n  // Do not support call `api` asynchronously without dataIndexInside input.\n\n  var currDataIndexInside;\n  var currItemModel;\n  var currItemStyleModels = {};\n  var currLabelModels = {};\n  var seriesItemStyleModels = {};\n  var seriesLabelModels = {};\n  for (var i = 0; i < STATES.length; i++) {\n    var stateName = STATES[i];\n    seriesItemStyleModels[stateName] = customSeries.getModel(PATH_ITEM_STYLE[stateName]);\n    seriesLabelModels[stateName] = customSeries.getModel(PATH_LABEL[stateName]);\n  }\n  function getItemModel(dataIndexInside) {\n    return dataIndexInside === currDataIndexInside ? currItemModel || (currItemModel = data.getItemModel(dataIndexInside)) : data.getItemModel(dataIndexInside);\n  }\n  function getItemStyleModel(dataIndexInside, state) {\n    return !data.hasItemOption ? seriesItemStyleModels[state] : dataIndexInside === currDataIndexInside ? currItemStyleModels[state] || (currItemStyleModels[state] = getItemModel(dataIndexInside).getModel(PATH_ITEM_STYLE[state])) : getItemModel(dataIndexInside).getModel(PATH_ITEM_STYLE[state]);\n  }\n  function getLabelModel(dataIndexInside, state) {\n    return !data.hasItemOption ? seriesLabelModels[state] : dataIndexInside === currDataIndexInside ? currLabelModels[state] || (currLabelModels[state] = getItemModel(dataIndexInside).getModel(PATH_LABEL[state])) : getItemModel(dataIndexInside).getModel(PATH_LABEL[state]);\n  }\n  return function (dataIndexInside, payload) {\n    currDataIndexInside = dataIndexInside;\n    currItemModel = null;\n    currItemStyleModels = {};\n    currLabelModels = {};\n    return renderItem && renderItem(defaults({\n      dataIndexInside: dataIndexInside,\n      dataIndex: data.getRawIndex(dataIndexInside),\n      // Can be used for optimization when zoom or roam.\n      actionType: payload ? payload.type : null\n    }, userParams), userAPI);\n  };\n  /**\n   * @public\n   * @param dim by default 0.\n   * @param dataIndexInside by default `currDataIndexInside`.\n   */\n\n  function value(dim, dataIndexInside) {\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n    return data.get(data.getDimension(dim || 0), dataIndexInside);\n  }\n  /**\n   * @public\n   * @param dim by default 0.\n   * @param dataIndexInside by default `currDataIndexInside`.\n   */\n\n  function ordinalRawValue(dim, dataIndexInside) {\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n    var dimInfo = data.getDimensionInfo(dim || 0);\n    if (!dimInfo) {\n      return;\n    }\n    var val = data.get(dimInfo.name, dataIndexInside);\n    var ordinalMeta = dimInfo && dimInfo.ordinalMeta;\n    return ordinalMeta ? ordinalMeta.categories[val] : val;\n  }\n  /**\n   * @deprecated The orgininal intention of `api.style` is enable to set itemStyle\n   * like other series. But it not necessary and not easy to give a strict definition\n   * of what it return. And since echarts5 it needs to be make compat work. So\n   * deprecates it since echarts5.\n   *\n   * By default, `visual` is applied to style (to support visualMap).\n   * `visual.color` is applied at `fill`. If user want apply visual.color on `stroke`,\n   * it can be implemented as:\n   * `api.style({stroke: api.visual('color'), fill: null})`;\n   *\n   * [Compat]: since ec5, RectText has been separated from its hosts el.\n   * so `api.style()` will only return the style from `itemStyle` but not handle `label`\n   * any more. But `series.label` config is never published in doc.\n   * We still compat it in `api.style()`. But not encourage to use it and will still not\n   * to pulish it to doc.\n   * @public\n   * @param dataIndexInside by default `currDataIndexInside`.\n   */\n\n  function style(userProps, dataIndexInside) {\n    if (process.env.NODE_ENV !== 'production') {\n      warnDeprecated('api.style', 'Please write literal style directly instead.');\n    }\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n    var style = data.getItemVisual(dataIndexInside, 'style');\n    var visualColor = style && style.fill;\n    var opacity = style && style.opacity;\n    var itemStyle = getItemStyleModel(dataIndexInside, NORMAL).getItemStyle();\n    visualColor != null && (itemStyle.fill = visualColor);\n    opacity != null && (itemStyle.opacity = opacity);\n    var opt = {\n      inheritColor: isString(visualColor) ? visualColor : '#000'\n    };\n    var labelModel = getLabelModel(dataIndexInside, NORMAL); // Now that the feture of \"auto adjust text fill/stroke\" has been migrated to zrender\n    // since ec5, we should set `isAttached` as `false` here and make compat in\n    // `convertToEC4StyleForCustomSerise`.\n\n    var textStyle = labelStyleHelper.createTextStyle(labelModel, null, opt, false, true);\n    textStyle.text = labelModel.getShallow('show') ? retrieve2(customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;\n    var textConfig = labelStyleHelper.createTextConfig(labelModel, opt, false);\n    preFetchFromExtra(userProps, itemStyle);\n    itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);\n    userProps && applyUserPropsAfter(itemStyle, userProps);\n    itemStyle.legacy = true;\n    return itemStyle;\n  }\n  /**\n   * @deprecated The reason see `api.style()`\n   * @public\n   * @param dataIndexInside by default `currDataIndexInside`.\n   */\n\n  function styleEmphasis(userProps, dataIndexInside) {\n    if (process.env.NODE_ENV !== 'production') {\n      warnDeprecated('api.styleEmphasis', 'Please write literal style directly instead.');\n    }\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n    var itemStyle = getItemStyleModel(dataIndexInside, EMPHASIS).getItemStyle();\n    var labelModel = getLabelModel(dataIndexInside, EMPHASIS);\n    var textStyle = labelStyleHelper.createTextStyle(labelModel, null, null, true, true);\n    textStyle.text = labelModel.getShallow('show') ? retrieve3(customSeries.getFormattedLabel(dataIndexInside, EMPHASIS), customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;\n    var textConfig = labelStyleHelper.createTextConfig(labelModel, null, true);\n    preFetchFromExtra(userProps, itemStyle);\n    itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);\n    userProps && applyUserPropsAfter(itemStyle, userProps);\n    itemStyle.legacy = true;\n    return itemStyle;\n  }\n  function applyUserPropsAfter(itemStyle, extra) {\n    for (var key in extra) {\n      if (hasOwn(extra, key)) {\n        itemStyle[key] = extra[key];\n      }\n    }\n  }\n  function preFetchFromExtra(extra, itemStyle) {\n    // A trick to retrieve those props firstly, which are used to\n    // apply auto inside fill/stroke in `convertToEC4StyleForCustomSerise`.\n    // (It's not reasonable but only for a degree of compat)\n    if (extra) {\n      extra.textFill && (itemStyle.textFill = extra.textFill);\n      extra.textPosition && (itemStyle.textPosition = extra.textPosition);\n    }\n  }\n  /**\n   * @public\n   * @param dataIndexInside by default `currDataIndexInside`.\n   */\n\n  function visual(visualType, dataIndexInside) {\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n    if (hasOwn(STYLE_VISUAL_TYPE, visualType)) {\n      var style_1 = data.getItemVisual(dataIndexInside, 'style');\n      return style_1 ? style_1[STYLE_VISUAL_TYPE[visualType]] : null;\n    } // Only support these visuals. Other visual might be inner tricky\n    // for performance (like `style`), do not expose to users.\n\n    if (hasOwn(NON_STYLE_VISUAL_PROPS, visualType)) {\n      return data.getItemVisual(dataIndexInside, visualType);\n    }\n  }\n  /**\n   * @public\n   * @return If not support, return undefined.\n   */\n\n  function barLayout(opt) {\n    if (coordSys.type === 'cartesian2d') {\n      var baseAxis = coordSys.getBaseAxis();\n      return getLayoutOnAxis(defaults({\n        axis: baseAxis\n      }, opt));\n    }\n  }\n  /**\n   * @public\n   */\n\n  function currentSeriesIndices() {\n    return ecModel.getCurrentSeriesIndices();\n  }\n  /**\n   * @public\n   * @return font string\n   */\n\n  function font(opt) {\n    return labelStyleHelper.getFont(opt, ecModel);\n  }\n}\nfunction wrapEncodeDef(data) {\n  var encodeDef = {};\n  each(data.dimensions, function (dimName, dataDimIndex) {\n    var dimInfo = data.getDimensionInfo(dimName);\n    if (!dimInfo.isExtraCoord) {\n      var coordDim = dimInfo.coordDim;\n      var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];\n      dataDims[dimInfo.coordDimIndex] = dataDimIndex;\n    }\n  });\n  return encodeDef;\n}\nfunction createOrUpdateItem(api, el, dataIndex, elOption, seriesModel, group, data, morphPreparation) {\n  // [Rule]\n  // If `renderItem` returns `null`/`undefined`/`false`, remove the previous el if existing.\n  //     (It seems that violate the \"merge\" principle, but most of users probably intuitively\n  //     regard \"return;\" as \"show nothing element whatever\", so make a exception to meet the\n  //     most cases.)\n  // The rule or \"merge\" see [STRATEGY_MERGE].\n  // If `elOption` is `null`/`undefined`/`false` (when `renderItem` returns nothing).\n  if (!elOption) {\n    removeElementDirectly(el, group);\n    return;\n  }\n  el = doCreateOrUpdateEl(api, el, dataIndex, elOption, seriesModel, group, true, morphPreparation);\n  el && data.setItemGraphicEl(dataIndex, el);\n  el && enableHoverEmphasis(el, elOption.focus, elOption.blurScope);\n  return el;\n}\nfunction doCreateOrUpdateEl(api, el, dataIndex, elOption, seriesModel, group, isRoot, morphPreparation) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(elOption, 'should not have an null/undefined element setting');\n  }\n  var toBeReplacedIdx = -1;\n  if (el && doesElNeedRecreate(el, elOption) // || (\n  //     // PENDING: even in one-to-one mapping case, if el is marked as morph,\n  //     // do not sure whether the el will be mapped to another el with different\n  //     // hierarchy in Group tree. So always recreate el rather than reuse the el.\n  //     morphPreparation && morphPreparation.isOneToOneFrom(el)\n  // )\n  ) {\n    // Should keep at the original index, otherwise \"merge by index\" will be incorrect.\n    toBeReplacedIdx = group.childrenRef().indexOf(el);\n    el = null;\n  }\n  var elIsNewCreated = !el;\n  if (!el) {\n    el = createEl(elOption);\n  } else {\n    // FIMXE:NEXT unified clearState?\n    // If in some case the performance issue arised, consider\n    // do not clearState but update cached normal state directly.\n    el.clearStates();\n  }\n  var canMorph = inner(el).canMorph = elOption.morph && isPath(el);\n  var thisElIsMorphTo = canMorph && morphPreparation && morphPreparation.hasFrom(); // Use update animation when morph is enabled.\n\n  var isInit = elIsNewCreated && !thisElIsMorphTo;\n  attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null;\n  attachedTxInfoTmp.isLegacy = false;\n  doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfoTmp);\n  doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit);\n  var pendingAllPropsFinal = updateElNormal(api, el, thisElIsMorphTo, dataIndex, elOption, elOption.style, attachedTxInfoTmp, seriesModel, isInit, false);\n  if (thisElIsMorphTo) {\n    morphPreparation.addTo(el, elOption, dataIndex, pendingAllPropsFinal);\n  }\n  for (var i = 0; i < STATES.length; i++) {\n    var stateName = STATES[i];\n    if (stateName !== NORMAL) {\n      var otherStateOpt = retrieveStateOption(elOption, stateName);\n      var otherStyleOpt = retrieveStyleOptionOnState(elOption, otherStateOpt, stateName);\n      updateElOnState(stateName, el, otherStateOpt, otherStyleOpt, attachedTxInfoTmp, isRoot, false);\n    }\n  }\n  updateZ(el, elOption, seriesModel, attachedTxInfoTmp);\n  if (elOption.type === 'group') {\n    mergeChildren(api, el, dataIndex, elOption, seriesModel, morphPreparation);\n  }\n  if (toBeReplacedIdx >= 0) {\n    group.replaceAt(el, toBeReplacedIdx);\n  } else {\n    group.add(el);\n  }\n  return el;\n} // `el` must not be null/undefined.\n\nfunction doesElNeedRecreate(el, elOption) {\n  var elInner = inner(el);\n  var elOptionType = elOption.type;\n  var elOptionShape = elOption.shape;\n  var elOptionStyle = elOption.style;\n  return (\n    // If `elOptionType` is `null`, follow the merge principle.\n    elOptionType != null && elOptionType !== elInner.customGraphicType || elOptionType === 'path' && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== elInner.customPathData || elOptionType === 'image' && hasOwn(elOptionStyle, 'image') && elOptionStyle.image !== elInner.customImagePath // // FIXME test and remove this restriction?\n    // || (elOptionType === 'text'\n    //     && hasOwn(elOptionStyle, 'text')\n    //     && (elOptionStyle as TextStyleProps).text !== elInner.customText\n    // )\n  );\n}\n\nfunction doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit) {\n  // Based on the \"merge\" principle, if no clipPath provided,\n  // do nothing. The exists clip will be totally removed only if\n  // `el.clipPath` is `false`. Otherwise it will be merged/replaced.\n  var clipPathOpt = elOption.clipPath;\n  if (clipPathOpt === false) {\n    if (el && el.getClipPath()) {\n      el.removeClipPath();\n    }\n  } else if (clipPathOpt) {\n    var clipPath = el.getClipPath();\n    if (clipPath && doesElNeedRecreate(clipPath, clipPathOpt)) {\n      clipPath = null;\n    }\n    if (!clipPath) {\n      clipPath = createEl(clipPathOpt);\n      if (process.env.NODE_ENV !== 'production') {\n        assert(clipPath instanceof graphicUtil.Path, 'Only any type of `path` can be used in `clipPath`, rather than ' + clipPath.type + '.');\n      }\n      el.setClipPath(clipPath);\n    }\n    updateElNormal(null, clipPath, null, dataIndex, clipPathOpt, null, null, seriesModel, isInit, false);\n  } // If not define `clipPath` in option, do nothing unnecessary.\n}\n\nfunction doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfo) {\n  // group do not support textContent temporarily untill necessary.\n  if (el.isGroup) {\n    return;\n  } // Normal must be called before emphasis, for `isLegacy` detection.\n\n  processTxInfo(elOption, null, attachedTxInfo);\n  processTxInfo(elOption, EMPHASIS, attachedTxInfo); // If `elOption.textConfig` or `elOption.textContent` is null/undefined, it does not make sence.\n  // So for simplicity, if \"elOption hasOwnProperty of them but be null/undefined\", we do not\n  // trade them as set to null to el.\n  // Especially:\n  // `elOption.textContent: false` means remove textContent.\n  // `elOption.textContent.emphasis.style: false` means remove the style from emphasis state.\n\n  var txConOptNormal = attachedTxInfo.normal.conOpt;\n  var txConOptEmphasis = attachedTxInfo.emphasis.conOpt;\n  var txConOptBlur = attachedTxInfo.blur.conOpt;\n  var txConOptSelect = attachedTxInfo.select.conOpt;\n  if (txConOptNormal != null || txConOptEmphasis != null || txConOptSelect != null || txConOptBlur != null) {\n    var textContent = el.getTextContent();\n    if (txConOptNormal === false) {\n      textContent && el.removeTextContent();\n    } else {\n      txConOptNormal = attachedTxInfo.normal.conOpt = txConOptNormal || {\n        type: 'text'\n      };\n      if (!textContent) {\n        textContent = createEl(txConOptNormal);\n        el.setTextContent(textContent);\n      } else {\n        // If in some case the performance issue arised, consider\n        // do not clearState but update cached normal state directly.\n        textContent.clearStates();\n      }\n      var txConStlOptNormal = txConOptNormal && txConOptNormal.style;\n      updateElNormal(null, textContent, null, dataIndex, txConOptNormal, txConStlOptNormal, null, seriesModel, isInit, true);\n      for (var i = 0; i < STATES.length; i++) {\n        var stateName = STATES[i];\n        if (stateName !== NORMAL) {\n          var txConOptOtherState = attachedTxInfo[stateName].conOpt;\n          updateElOnState(stateName, textContent, txConOptOtherState, retrieveStyleOptionOnState(txConOptNormal, txConOptOtherState, stateName), null, false, true);\n        }\n      }\n      txConStlOptNormal ? textContent.dirty() : textContent.markRedraw();\n    }\n  }\n}\nfunction processTxInfo(elOption, state, attachedTxInfo) {\n  var stateOpt = !state ? elOption : retrieveStateOption(elOption, state);\n  var styleOpt = !state ? elOption.style : retrieveStyleOptionOnState(elOption, stateOpt, EMPHASIS);\n  var elType = elOption.type;\n  var txCfg = stateOpt ? stateOpt.textConfig : null;\n  var txConOptNormal = elOption.textContent;\n  var txConOpt = !txConOptNormal ? null : !state ? txConOptNormal : retrieveStateOption(txConOptNormal, state);\n  if (styleOpt && (\n  // Because emphasis style has little info to detect legacy,\n  // if normal is legacy, emphasis is trade as legacy.\n  attachedTxInfo.isLegacy || isEC4CompatibleStyle(styleOpt, elType, !!txCfg, !!txConOpt))) {\n    attachedTxInfo.isLegacy = true;\n    var convertResult = convertFromEC4CompatibleStyle(styleOpt, elType, !state); // Explicitly specified `textConfig` and `textContent` has higher priority than\n    // the ones generated by legacy style. Otherwise if users use them and `api.style`\n    // at the same time, they not both work and hardly to known why.\n\n    if (!txCfg && convertResult.textConfig) {\n      txCfg = convertResult.textConfig;\n    }\n    if (!txConOpt && convertResult.textContent) {\n      txConOpt = convertResult.textContent;\n    }\n  }\n  if (!state && txConOpt) {\n    var txConOptNormal_1 = txConOpt; // `textContent: {type: 'text'}`, the \"type\" is easy to be missing. So we tolerate it.\n\n    !txConOptNormal_1.type && (txConOptNormal_1.type = 'text');\n    if (process.env.NODE_ENV !== 'production') {\n      // Do not tolerate incorret type for forward compat.\n      txConOptNormal_1.type !== 'text' && assert(txConOptNormal_1.type === 'text', 'textContent.type must be \"text\"');\n    }\n  }\n  var info = !state ? attachedTxInfo.normal : attachedTxInfo[state];\n  info.cfg = txCfg;\n  info.conOpt = txConOpt;\n}\nfunction retrieveStateOption(elOption, state) {\n  return !state ? elOption : elOption ? elOption[state] : null;\n}\nfunction retrieveStyleOptionOnState(stateOptionNormal, stateOption, state) {\n  var style = stateOption && stateOption.style;\n  if (style == null && state === EMPHASIS && stateOptionNormal) {\n    style = stateOptionNormal.styleEmphasis;\n  }\n  return style;\n} // Usage:\n// (1) By default, `elOption.$mergeChildren` is `'byIndex'`, which indicates that\n//     the existing children will not be removed, and enables the feature that\n//     update some of the props of some of the children simply by construct\n//     the returned children of `renderItem` like:\n//     `var children = group.children = []; children[3] = {opacity: 0.5};`\n// (2) If `elOption.$mergeChildren` is `'byName'`, add/update/remove children\n//     by child.name. But that might be lower performance.\n// (3) If `elOption.$mergeChildren` is `false`, the existing children will be\n//     replaced totally.\n// (4) If `!elOption.children`, following the \"merge\" principle, nothing will happen.\n//\n// For implementation simpleness, do not provide a direct way to remove sinlge\n// child (otherwise the total indicies of the children array have to be modified).\n// User can remove a single child by set its `ignore` as `true`.\n\nfunction mergeChildren(api, el, dataIndex, elOption, seriesModel, morphPreparation) {\n  var newChildren = elOption.children;\n  var newLen = newChildren ? newChildren.length : 0;\n  var mergeChildren = elOption.$mergeChildren; // `diffChildrenByName` has been deprecated.\n\n  var byName = mergeChildren === 'byName' || elOption.diffChildrenByName;\n  var notMerge = mergeChildren === false; // For better performance on roam update, only enter if necessary.\n\n  if (!newLen && !byName && !notMerge) {\n    return;\n  }\n  if (byName) {\n    diffGroupChildren({\n      api: api,\n      oldChildren: el.children() || [],\n      newChildren: newChildren || [],\n      dataIndex: dataIndex,\n      seriesModel: seriesModel,\n      group: el,\n      morphPreparation: morphPreparation\n    });\n    return;\n  }\n  notMerge && el.removeAll(); // Mapping children of a group simply by index, which\n  // might be better performance.\n\n  var index = 0;\n  for (; index < newLen; index++) {\n    newChildren[index] && doCreateOrUpdateEl(api, el.childAt(index), dataIndex, newChildren[index], seriesModel, el, false, morphPreparation);\n  }\n  for (var i = el.childCount() - 1; i >= index; i--) {\n    // Do not supprot leave elements that are not mentioned in the latest\n    // `renderItem` return. Otherwise users may not have a clear and simple\n    // concept that how to contorl all of the elements.\n    doRemoveEl(el.childAt(i), seriesModel, el);\n  }\n}\nfunction diffGroupChildren(context) {\n  new DataDiffer(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();\n}\nfunction getKey(item, idx) {\n  var name = item && item.name;\n  return name != null ? name : GROUP_DIFF_PREFIX + idx;\n}\nfunction processAddUpdate(newIndex, oldIndex) {\n  var context = this.context;\n  var childOption = newIndex != null ? context.newChildren[newIndex] : null;\n  var child = oldIndex != null ? context.oldChildren[oldIndex] : null;\n  doCreateOrUpdateEl(context.api, child, context.dataIndex, childOption, context.seriesModel, context.group, false, context.morphPreparation);\n}\nfunction processRemove(oldIndex) {\n  var context = this.context;\n  var child = context.oldChildren[oldIndex];\n  doRemoveEl(child, context.seriesModel, context.group);\n}\nfunction doRemoveEl(el, seriesModel, group) {\n  if (el) {\n    var leaveToProps = inner(el).leaveToProps;\n    leaveToProps ? graphicUtil.updateProps(el, leaveToProps, seriesModel, {\n      cb: function () {\n        group.remove(el);\n      }\n    }) : group.remove(el);\n  }\n}\n/**\n * @return SVG Path data.\n */\n\nfunction getPathData(shape) {\n  // \"d\" follows the SVG convention.\n  return shape && (shape.pathData || shape.d);\n}\nfunction hasOwnPathData(shape) {\n  return shape && (hasOwn(shape, 'pathData') || hasOwn(shape, 'd'));\n}\nfunction isPath(el) {\n  return el && el instanceof graphicUtil.Path;\n}\nfunction removeElementDirectly(el, group) {\n  el && group.remove(el);\n}\n/**\n * Any morph-potential el should added by `morphPreparation.addTo(el)`.\n * And they may apply morph or not when `morphPreparation.applyMorphing()`.\n * But at least, all of the \"to\" elements will apply all of the updates\n * as `doCreateOrUpdateItem` did.\n */\n\nvar MorphPreparation = /** @class */\nfunction () {\n  function MorphPreparation(seriesModel, transOpt) {\n    this._fromList = [];\n    this._toList = [];\n    this._toElOptionList = [];\n    this._allPropsFinalList = [];\n    this._toDataIndices = []; // Key: `toDataIndex`, not `toIdx`\n\n    this._morphConfigList = [];\n    this._seriesModel = seriesModel;\n    this._transOpt = transOpt;\n  }\n  MorphPreparation.prototype.hasFrom = function () {\n    return !!this._fromList.length;\n  }; // isOneToOneFrom(el: Element): boolean {\n  //     if (el && inner(el).canMorph) {\n  //         const fromList = this._fromList;\n  //         for (let i = 0; i < fromList.length; i++) {\n  //             if (fromList[i] === el) {\n  //                 return true;\n  //             }\n  //         }\n  //     }\n  // }\n\n  MorphPreparation.prototype.findAndAddFrom = function (el) {\n    if (!el) {\n      return;\n    }\n    if (inner(el).canMorph) {\n      this._fromList.push(el);\n    }\n    if (el.isGroup) {\n      var children = el.childrenRef();\n      for (var i = 0; i < children.length; i++) {\n        this.findAndAddFrom(children[i]);\n      }\n    }\n  };\n  MorphPreparation.prototype.addTo = function (path, elOption, dataIndex, allPropsFinal) {\n    if (path) {\n      this._toList.push(path);\n      this._toElOptionList.push(elOption);\n      this._toDataIndices.push(dataIndex);\n      this._allPropsFinalList.push(allPropsFinal);\n    }\n  };\n  MorphPreparation.prototype.applyMorphing = function () {\n    // [MORPHING_LOGIC_HINT]\n    // Pay attention to the order:\n    // (A) Apply `allPropsFinal` and `styleOption` to \"to\".\n    //     (Then \"to\" becomes to the final state.)\n    // (B) Apply `morphPath`/`combine`/`separate`.\n    //     (Based on the current state of \"from\" and the final state of \"to\".)\n    //     (Then we may get \"from.subList\" or \"to.subList\".)\n    // (C) Copy the related props from \"from\" to \"from.subList\", from \"to\" to \"to.subList\".\n    // (D) Collect `transitionFromProps` for \"to\" and \"to.subList\"\n    //     (Based on \"from\" or \"from.subList\".)\n    // (E) Apply `transitionFromProps` to \"to\" and \"to.subList\"\n    //     (It might change the prop values to the first frame value.)\n    // Case_I:\n    //     If (D) should be after (C), we use sequence: A - B - C - D - E\n    // Case_II:\n    //     If (A) should be after (D), we use sequence: D - A - B - C - E\n    // [MORPHING_LOGIC_HINT]\n    // zrender `morphPath`/`combine`/`separate` only manages the shape animation.\n    // Other props (like transfrom, style transition) will handled in echarts).\n    // [MORPHING_LOGIC_HINT]\n    // Make sure `applyPropsFinal` always be called for \"to\".\n    var type = this._type;\n    var fromList = this._fromList;\n    var toList = this._toList;\n    var toListLen = toList.length;\n    var fromListLen = fromList.length;\n    if (!fromListLen || !toListLen) {\n      return;\n    }\n    if (type === 'oneToOne') {\n      // In one-to-one case, we by default apply a simple rule:\n      // map \"from\" and \"to\" one by one.\n      // For this case: old_data_item_el and new_data_item_el\n      // has the same hierarchy of group tree but only some path type changed.\n      for (var toIdx = 0; toIdx < toListLen; toIdx++) {\n        this._oneToOneForSingleTo(toIdx, toIdx);\n      }\n    } else if (type === 'manyToOne') {\n      // A rough strategy: if there are more than one \"to\", we simply divide \"fromList\" equally.\n      var fromSingleSegLen = Math.max(1, Math.floor(fromListLen / toListLen));\n      for (var toIdx = 0, fromIdxStart = 0; toIdx < toListLen; toIdx++, fromIdxStart += fromSingleSegLen) {\n        var fromCount = toIdx + 1 >= toListLen ? fromListLen - fromIdxStart : fromSingleSegLen;\n        this._manyToOneForSingleTo(toIdx, fromIdxStart >= fromListLen ? null : fromIdxStart, fromCount);\n      }\n    } else if (type === 'oneToMany') {\n      // A rough strategy: if there are more than one \"from\", we simply divide \"toList\" equally.\n      var toSingleSegLen = Math.max(1, Math.floor(toListLen / fromListLen));\n      for (var toIdxStart = 0, fromIdx = 0; toIdxStart < toListLen; toIdxStart += toSingleSegLen, fromIdx++) {\n        var toCount = toIdxStart + toSingleSegLen >= toListLen ? toListLen - toIdxStart : toSingleSegLen;\n        this._oneToManyForSingleFrom(toIdxStart, toCount, fromIdx >= fromListLen ? null : fromIdx);\n      }\n    }\n  };\n  MorphPreparation.prototype._oneToOneForSingleTo = function (\n  // \"to\" must NOT be null/undefined.\n  toIdx,\n  // May `fromIdx >= this._fromList.length`\n  fromIdx) {\n    var to = this._toList[toIdx];\n    var toElOption = this._toElOptionList[toIdx];\n    var toDataIndex = this._toDataIndices[toIdx];\n    var allPropsFinal = this._allPropsFinalList[toIdx];\n    var from = this._fromList[fromIdx];\n    var elAnimationConfig = this._getOrCreateMorphConfig(toDataIndex);\n    var morphDuration = elAnimationConfig.duration;\n    if (from && isCombiningPath(from)) {\n      applyPropsFinal(to, allPropsFinal, toElOption.style);\n      if (morphDuration) {\n        var combineResult = combine([from], to, elAnimationConfig, copyPropsWhenDivided);\n        this._processResultIndividuals(combineResult, toIdx, null);\n      } // The target el will not be displayed and transition from multiple path.\n      // transition on the target el does not make sense.\n    } else {\n      var morphFrom = morphDuration // from === to usually happen in scenarios where internal update like\n      // \"dataZoom\", \"legendToggle\" happen. If from is not in any morphing,\n      // we do not need to call `morphPath`.\n      && from && (from !== to || isInAnyMorphing(from)) ? from : null; // See [Case_II] above.\n      // In this case, there is probably `from === to`. And the `transitionFromProps` collecting\n      // does not depends on morphing. So we collect `transitionFromProps` first.\n\n      var transFromProps = {};\n      prepareShapeOrExtraTransitionFrom('shape', to, morphFrom, toElOption, transFromProps, false);\n      prepareShapeOrExtraTransitionFrom('extra', to, morphFrom, toElOption, transFromProps, false);\n      prepareTransformTransitionFrom(to, morphFrom, toElOption, transFromProps, false);\n      prepareStyleTransitionFrom(to, morphFrom, toElOption, toElOption.style, transFromProps, false);\n      applyPropsFinal(to, allPropsFinal, toElOption.style);\n      if (morphFrom) {\n        morphPath(morphFrom, to, elAnimationConfig);\n      }\n      applyTransitionFrom(to, toDataIndex, toElOption, this._seriesModel, transFromProps, false);\n    }\n  };\n  MorphPreparation.prototype._manyToOneForSingleTo = function (\n  // \"to\" must NOT be null/undefined.\n  toIdx,\n  // May be null.\n  fromIdxStart, fromCount) {\n    var to = this._toList[toIdx];\n    var toElOption = this._toElOptionList[toIdx];\n    var allPropsFinal = this._allPropsFinalList[toIdx];\n    applyPropsFinal(to, allPropsFinal, toElOption.style);\n    var elAnimationConfig = this._getOrCreateMorphConfig(this._toDataIndices[toIdx]);\n    if (elAnimationConfig.duration && fromIdxStart != null) {\n      var combineFromList = [];\n      for (var fromIdx = fromIdxStart; fromIdx < fromCount; fromIdx++) {\n        combineFromList.push(this._fromList[fromIdx]);\n      }\n      var combineResult = combine(combineFromList, to, elAnimationConfig, copyPropsWhenDivided);\n      this._processResultIndividuals(combineResult, toIdx, null);\n    }\n  };\n  MorphPreparation.prototype._oneToManyForSingleFrom = function (\n  // \"to\" must NOT be null/undefined.\n  toIdxStart, toCount,\n  // May be null\n  fromIdx) {\n    var from = fromIdx == null ? null : this._fromList[fromIdx];\n    var toList = this._toList;\n    var separateToList = [];\n    for (var toIdx = toIdxStart; toIdx < toCount; toIdx++) {\n      var to = toList[toIdx];\n      applyPropsFinal(to, this._allPropsFinalList[toIdx], this._toElOptionList[toIdx].style);\n      separateToList.push(to);\n    }\n    var elAnimationConfig = this._getOrCreateMorphConfig(this._toDataIndices[toIdxStart]);\n    if (elAnimationConfig.duration && from) {\n      var separateResult = separate(from, separateToList, elAnimationConfig, copyPropsWhenDivided);\n      this._processResultIndividuals(separateResult, toIdxStart, toCount);\n    }\n  };\n  MorphPreparation.prototype._processResultIndividuals = function (combineSeparateResult, toIdxStart, toCount) {\n    var isSeparate = toCount != null;\n    for (var i = 0; i < combineSeparateResult.count; i++) {\n      var fromIndividual = combineSeparateResult.fromIndividuals[i];\n      var toIndividual = combineSeparateResult.toIndividuals[i]; // Here it's a trick:\n      // For \"combine\" case, all of the `toIndividuals` map to the same `toIdx`.\n      // For \"separate\" case, the `toIndividuals` map to some certain segment of `_toList` accurately.\n\n      var toIdx = toIdxStart + (isSeparate ? i : 0);\n      var toElOption = this._toElOptionList[toIdx];\n      var dataIndex = this._toDataIndices[toIdx];\n      var transFromProps = {};\n      prepareTransformTransitionFrom(toIndividual, fromIndividual, toElOption, transFromProps, false);\n      prepareStyleTransitionFrom(toIndividual, fromIndividual, toElOption, toElOption.style, transFromProps, false);\n      applyTransitionFrom(toIndividual, dataIndex, toElOption, this._seriesModel, transFromProps, false);\n    }\n  };\n  MorphPreparation.prototype._getOrCreateMorphConfig = function (dataIndex) {\n    var morphConfigList = this._morphConfigList;\n    var config = morphConfigList[dataIndex];\n    if (config) {\n      return config;\n    }\n    var duration;\n    var easing;\n    var delay;\n    var seriesModel = this._seriesModel;\n    var transOpt = this._transOpt;\n    if (seriesModel.isAnimationEnabled()) {\n      // PENDING: refactor? this is the same logic as `src/util/graphic.ts#animateOrSetProps`.\n      var animationPayload = void 0;\n      if (seriesModel && seriesModel.ecModel) {\n        var updatePayload = seriesModel.ecModel.getUpdatePayload();\n        animationPayload = updatePayload && updatePayload.animation;\n      }\n      if (animationPayload) {\n        duration = animationPayload.duration || 0;\n        easing = animationPayload.easing || 'cubicOut';\n        delay = animationPayload.delay || 0;\n      } else {\n        easing = seriesModel.get('animationEasingUpdate');\n        var delayOption = seriesModel.get('animationDelayUpdate');\n        delay = isFunction(delayOption) ? delayOption(dataIndex) : delayOption;\n        var durationOption = seriesModel.get('animationDurationUpdate');\n        duration = isFunction(durationOption) ? durationOption(dataIndex) : durationOption;\n      }\n    }\n    config = {\n      duration: duration || 0,\n      delay: delay,\n      easing: easing,\n      dividingMethod: transOpt ? transOpt.dividingMethod : null\n    };\n    morphConfigList[dataIndex] = config;\n    return config;\n  };\n  MorphPreparation.prototype.reset = function (type) {\n    // `this._morphConfigList` can be kept. It only related to `dataIndex`.\n    this._type = type;\n    this._fromList.length = this._toList.length = this._toElOptionList.length = this._allPropsFinalList.length = this._toDataIndices.length = 0;\n  };\n  return MorphPreparation;\n}();\nfunction copyPropsWhenDivided(srcPath, tarPath, willClone) {\n  // Do not copy transform props.\n  // Sub paths are transfrom based on their host path.\n  // tarPath.x = srcPath.x;\n  // tarPath.y = srcPath.y;\n  // tarPath.scaleX = srcPath.scaleX;\n  // tarPath.scaleY = srcPath.scaleY;\n  // tarPath.originX = srcPath.originX;\n  // tarPath.originY = srcPath.originY;\n  // If just carry the style, will not be modifed, so do not copy.\n  tarPath.style = willClone ? clone(srcPath.style) : srcPath.style;\n  tarPath.zlevel = srcPath.zlevel;\n  tarPath.z = srcPath.z;\n  tarPath.z2 = srcPath.z2;\n}\nexport function install(registers) {\n  registers.registerChartView(CustomSeriesView);\n  registers.registerSeriesModel(CustomSeriesModel);\n}","map":{"version":3,"names":["__extends","hasOwn","assert","isString","retrieve2","retrieve3","defaults","each","keys","isArrayLike","bind","isFunction","eqNaN","indexOf","clone","graphicUtil","setDefaultStateProxy","enableHoverEmphasis","labelStyleHelper","getDefaultLabel","createListFromArray","getLayoutOnAxis","DataDiffer","SeriesModel","ChartView","createClipPath","prepareCartesian2d","prepareGeo","prepareSingleAxis","preparePolar","prepareCalendar","makeInner","normalizeToArray","convertToEC4StyleForCustomSerise","isEC4CompatibleStyle","convertFromEC4CompatibleStyle","warnDeprecated","Transformable","cloneValue","warn","throwError","combine","isInAnyMorphing","morphPath","isCombiningPath","separate","matrix","createOrUpdatePatternFromDecal","inner","TRANSFORM_PROPS","x","y","scaleX","scaleY","originX","originY","rotation","transformPropNamesStr","join","STYLE_VISUAL_TYPE","color","borderColor","NON_STYLE_VISUAL_PROPS","symbol","symbolSize","symbolKeepAspect","legendIcon","visualMeta","liftZ","decal","EMPHASIS","NORMAL","BLUR","SELECT","STATES","PATH_ITEM_STYLE","normal","emphasis","blur","select","PATH_LABEL","GROUP_DIFF_PREFIX","attachedTxInfoTmp","LEGACY_TRANSFORM_PROPS","position","scale","origin","tmpTransformable","prepareCustoms","cartesian2d","geo","singleAxis","polar","calendar","CustomSeriesModel","_super","_this","apply","arguments","type","prototype","optionUpdated","currentZLevel","get","currentZ","getInitialData","option","ecModel","getSource","getDataParams","dataIndex","dataType","el","params","call","info","dependencies","defaultOption","coordinateSystem","zlevel","z","legendHoverLink","clip","CustomSeriesView","render","customSeries","api","payload","oldData","_data","data","getData","group","renderItem","makeRenderItem","removeAll","transOpt","__transientTransitionOpt","from","to","oldIdx","doRemoveEl","getItemGraphicEl","newIdx","createOrUpdateItem","morphPreparation_1","MorphPreparation","diffMode","getIndices","createGetKey","add","remove","update","reset","oldEl","findAndAddFrom","hasFrom","removeElementDirectly","applyMorphing","updateManyToOne","oldIndices","i","length","updateOneToMany","newIndices","newLen","execute","clipPath","setClipPath","removeClipPath","incrementalPrepareRender","incrementalRender","setIncrementalAndHoverLayer","isGroup","incremental","ensureState","hoverLayer","idx","start","end","traverse","filterForExposedEvent","eventType","query","targetEl","packedEvent","elementName","element","name","__hostTarget","parent","dimension","rawIdx","getId","diffByDimName","getDimension","dimInfo","getDimensionInfo","errMsg","process","env","NODE_ENV","ordinalMeta","key","categories","createEl","elOption","graphicType","shape","pathRect","width","height","pathData","getPathData","makePath","layout","customPathData","Image","customImagePath","style","image","Text","Group","Error","Clz","getShapeClass","customGraphicType","z2EmphasisLift","z2SelectLift","updateElNormal","isMorphTo","styleOpt","attachedTxInfo","seriesModel","isInit","isTextContent","transFromProps","allPropsFinal","elDisplayable","prepareShapeOrExtraTransitionFrom","prepareShapeOrExtraAllPropsFinal","prepareTransformTransitionFrom","prepareTransformAllPropsFinal","txCfgOpt","cfg","setTextConfig","textOptionStyle","fill","textFill","stroke","textStroke","decalPattern","decalObj","isPath","dirty","__decalPattern","prepareStyleTransitionFrom","invisible","applyPropsFinal","applyTransitionFrom","silent","ignore","markRedraw","originalDecalObj","useStyle","animators","animator","targetName","changeTarget","attr","userDuring","during","cfgDuringCall","duringCall","isFrom","initProps","updateProps","mainAttr","morphFromEl","attrOpt","elPropsInAttr","transFromPropsInAttr","enterFrom","enterFromKeys","transition","transitionKeys","elVal","checkNonStyleTansitionRefer","elPropsInAttrKeys","isNonStyleTransitionEnabled","leaveTo","leaveToProps","getOrCreateLeaveToPropsFromEl","leaveToPropsInAttr","leaveToKeys","allProps","allPropsInAttr","keysInAttr","checkTransformPropRefer","fromTransformable","calcOldElLocalTransformBasedOnNewElParent","setTransformPropToTransitionFrom","setLagecyTransformProp","setTransformProp","fromEl","fromElStyle","transFromStyleProps","getAnimationStyleProps","animationProps","animationStyleProps","styleKeys","leaveToStyleProps","newEl","tmpM","transform","identity","oldGlobalTransform","getComputedTransform","copy","newParent","decomposeTransform","propName","optVal","isFinite","usedIn","innerEl","tmpDuringScope","customDuringAPI","setTransform","val","getTransform","setShape","assertNotReserved","isShapeDirty","getShape","setStyle","isStyleDirty","getStyle","setExtra","extra","getExtra","scope","newstUserDuring","scopeUserDuring","dirtyShape","dirtyStyle","updateElOnState","state","elStateOpt","isRoot","stateObj","existingEmphasisState","getState","textConfig","updateZ","optZ2","z2","updateZForEachState","isNormal","retrieveStateOption","targetProps","legacyName","legacyArr","xyName","transitionFrom","coordSys","prepareResult","userAPI","getWidth","getHeight","getZr","getDevicePixelRatio","value","ordinalRawValue","styleEmphasis","visual","barLayout","currentSeriesIndices","font","userParams","context","seriesId","id","seriesName","seriesIndex","dataInsideLength","count","encode","wrapEncodeDef","currDataIndexInside","currItemModel","currItemStyleModels","currLabelModels","seriesItemStyleModels","seriesLabelModels","stateName","getModel","getItemModel","dataIndexInside","getItemStyleModel","hasItemOption","getLabelModel","getRawIndex","actionType","dim","userProps","getItemVisual","visualColor","opacity","itemStyle","getItemStyle","opt","inheritColor","labelModel","textStyle","createTextStyle","text","getShallow","getFormattedLabel","createTextConfig","preFetchFromExtra","applyUserPropsAfter","legacy","textPosition","visualType","style_1","baseAxis","getBaseAxis","axis","getCurrentSeriesIndices","getFont","encodeDef","dimensions","dimName","dataDimIndex","isExtraCoord","coordDim","dataDims","coordDimIndex","morphPreparation","doCreateOrUpdateEl","setItemGraphicEl","focus","blurScope","toBeReplacedIdx","doesElNeedRecreate","childrenRef","elIsNewCreated","clearStates","canMorph","morph","thisElIsMorphTo","conOpt","isLegacy","doCreateOrUpdateAttachedTx","doCreateOrUpdateClipPath","pendingAllPropsFinal","addTo","otherStateOpt","otherStyleOpt","retrieveStyleOptionOnState","mergeChildren","replaceAt","elInner","elOptionType","elOptionShape","elOptionStyle","hasOwnPathData","clipPathOpt","getClipPath","Path","processTxInfo","txConOptNormal","txConOptEmphasis","txConOptBlur","txConOptSelect","textContent","getTextContent","removeTextContent","setTextContent","txConStlOptNormal","txConOptOtherState","stateOpt","elType","txCfg","txConOpt","convertResult","txConOptNormal_1","stateOptionNormal","stateOption","newChildren","children","$mergeChildren","byName","diffChildrenByName","notMerge","diffGroupChildren","oldChildren","index","childAt","childCount","getKey","processAddUpdate","processRemove","item","newIndex","oldIndex","childOption","child","cb","d","_fromList","_toList","_toElOptionList","_allPropsFinalList","_toDataIndices","_morphConfigList","_seriesModel","_transOpt","push","path","_type","fromList","toList","toListLen","fromListLen","toIdx","_oneToOneForSingleTo","fromSingleSegLen","Math","max","floor","fromIdxStart","fromCount","_manyToOneForSingleTo","toSingleSegLen","toIdxStart","fromIdx","toCount","_oneToManyForSingleFrom","toElOption","toDataIndex","elAnimationConfig","_getOrCreateMorphConfig","morphDuration","duration","combineResult","copyPropsWhenDivided","_processResultIndividuals","morphFrom","combineFromList","separateToList","separateResult","combineSeparateResult","isSeparate","fromIndividual","fromIndividuals","toIndividual","toIndividuals","morphConfigList","config","easing","delay","isAnimationEnabled","animationPayload","updatePayload","getUpdatePayload","animation","delayOption","durationOption","dividingMethod","srcPath","tarPath","willClone","install","registers","registerChartView","registerSeriesModel"],"sources":["/Users/jiong/Downloads/my-app/node_modules/echarts/lib/chart/custom/install.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n\n/**\n * AUTO-GENERATED FILE. DO NOT MODIFY.\n */\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nimport { __extends } from \"tslib\";\nimport { hasOwn, assert, isString, retrieve2, retrieve3, defaults, each, keys, isArrayLike, bind, isFunction, eqNaN, indexOf, clone } from 'zrender/lib/core/util';\nimport * as graphicUtil from '../../util/graphic';\nimport { setDefaultStateProxy, enableHoverEmphasis } from '../../util/states';\nimport * as labelStyleHelper from '../../label/labelStyle';\nimport { getDefaultLabel } from '../helper/labelHelper';\nimport createListFromArray from '../helper/createListFromArray';\nimport { getLayoutOnAxis } from '../../layout/barGrid';\nimport DataDiffer from '../../data/DataDiffer';\nimport SeriesModel from '../../model/Series';\nimport ChartView from '../../view/Chart';\nimport { createClipPath } from '../helper/createClipPathFromCoordSys';\nimport prepareCartesian2d from '../../coord/cartesian/prepareCustom';\nimport prepareGeo from '../../coord/geo/prepareCustom';\nimport prepareSingleAxis from '../../coord/single/prepareCustom';\nimport preparePolar from '../../coord/polar/prepareCustom';\nimport prepareCalendar from '../../coord/calendar/prepareCustom';\nimport { makeInner, normalizeToArray } from '../../util/model';\nimport { convertToEC4StyleForCustomSerise, isEC4CompatibleStyle, convertFromEC4CompatibleStyle, warnDeprecated } from '../../util/styleCompat';\nimport Transformable from 'zrender/lib/core/Transformable';\nimport { cloneValue } from 'zrender/lib/animation/Animator';\nimport { warn, throwError } from '../../util/log';\nimport { combine, isInAnyMorphing, morphPath, isCombiningPath, separate } from 'zrender/lib/tool/morphPath';\nimport * as matrix from 'zrender/lib/core/matrix';\nimport { createOrUpdatePatternFromDecal } from '../../util/decal';\nvar inner = makeInner();\nvar TRANSFORM_PROPS = {\n  x: 1,\n  y: 1,\n  scaleX: 1,\n  scaleY: 1,\n  originX: 1,\n  originY: 1,\n  rotation: 1\n};\nvar transformPropNamesStr = keys(TRANSFORM_PROPS).join(', ');\n; // Also compat with ec4, where\n// `visual('color') visual('borderColor')` is supported.\n\nvar STYLE_VISUAL_TYPE = {\n  color: 'fill',\n  borderColor: 'stroke'\n};\nvar NON_STYLE_VISUAL_PROPS = {\n  symbol: 1,\n  symbolSize: 1,\n  symbolKeepAspect: 1,\n  legendIcon: 1,\n  visualMeta: 1,\n  liftZ: 1,\n  decal: 1\n};\nvar EMPHASIS = 'emphasis';\nvar NORMAL = 'normal';\nvar BLUR = 'blur';\nvar SELECT = 'select';\nvar STATES = [NORMAL, EMPHASIS, BLUR, SELECT];\nvar PATH_ITEM_STYLE = {\n  normal: ['itemStyle'],\n  emphasis: [EMPHASIS, 'itemStyle'],\n  blur: [BLUR, 'itemStyle'],\n  select: [SELECT, 'itemStyle']\n};\nvar PATH_LABEL = {\n  normal: ['label'],\n  emphasis: [EMPHASIS, 'label'],\n  blur: [BLUR, 'label'],\n  select: [SELECT, 'label']\n}; // Use prefix to avoid index to be the same as el.name,\n// which will cause weird update animation.\n\nvar GROUP_DIFF_PREFIX = 'e\\0\\0';\nvar attachedTxInfoTmp = {\n  normal: {},\n  emphasis: {},\n  blur: {},\n  select: {}\n};\nvar LEGACY_TRANSFORM_PROPS = {\n  position: ['x', 'y'],\n  scale: ['scaleX', 'scaleY'],\n  origin: ['originX', 'originY']\n};\nvar tmpTransformable = new Transformable();\n/**\n * To reduce total package size of each coordinate systems, the modules `prepareCustom`\n * of each coordinate systems are not required by each coordinate systems directly, but\n * required by the module `custom`.\n *\n * prepareInfoForCustomSeries {Function}: optional\n *     @return {Object} {coordSys: {...}, api: {\n *         coord: function (data, clamp) {}, // return point in global.\n *         size: function (dataSize, dataItem) {} // return size of each axis in coordSys.\n *     }}\n */\n\nvar prepareCustoms = {\n  cartesian2d: prepareCartesian2d,\n  geo: prepareGeo,\n  singleAxis: prepareSingleAxis,\n  polar: preparePolar,\n  calendar: prepareCalendar\n};\n\nvar CustomSeriesModel =\n/** @class */\nfunction (_super) {\n  __extends(CustomSeriesModel, _super);\n\n  function CustomSeriesModel() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = CustomSeriesModel.type;\n    return _this;\n  }\n\n  CustomSeriesModel.prototype.optionUpdated = function () {\n    this.currentZLevel = this.get('zlevel', true);\n    this.currentZ = this.get('z', true);\n  };\n\n  CustomSeriesModel.prototype.getInitialData = function (option, ecModel) {\n    return createListFromArray(this.getSource(), this);\n  };\n\n  CustomSeriesModel.prototype.getDataParams = function (dataIndex, dataType, el) {\n    var params = _super.prototype.getDataParams.call(this, dataIndex, dataType);\n\n    el && (params.info = inner(el).info);\n    return params;\n  };\n\n  CustomSeriesModel.type = 'series.custom';\n  CustomSeriesModel.dependencies = ['grid', 'polar', 'geo', 'singleAxis', 'calendar'];\n  CustomSeriesModel.defaultOption = {\n    coordinateSystem: 'cartesian2d',\n    zlevel: 0,\n    z: 2,\n    legendHoverLink: true,\n    // Custom series will not clip by default.\n    // Some case will use custom series to draw label\n    // For example https://echarts.apache.org/examples/en/editor.html?c=custom-gantt-flight\n    clip: false // Cartesian coordinate system\n    // xAxisIndex: 0,\n    // yAxisIndex: 0,\n    // Polar coordinate system\n    // polarIndex: 0,\n    // Geo coordinate system\n    // geoIndex: 0,\n\n  };\n  return CustomSeriesModel;\n}(SeriesModel);\n\nvar CustomSeriesView =\n/** @class */\nfunction (_super) {\n  __extends(CustomSeriesView, _super);\n\n  function CustomSeriesView() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n\n    _this.type = CustomSeriesView.type;\n    return _this;\n  }\n\n  CustomSeriesView.prototype.render = function (customSeries, ecModel, api, payload) {\n    var oldData = this._data;\n    var data = customSeries.getData();\n    var group = this.group;\n    var renderItem = makeRenderItem(customSeries, data, ecModel, api);\n\n    if (!oldData) {\n      // Previous render is incremental render or first render.\n      // Needs remove the incremental rendered elements.\n      group.removeAll();\n    } // By default, merge mode is applied. In most cases, custom series is\n    // used in the scenario that data amount is not large but graphic elements\n    // is complicated, where merge mode is probably necessary for optimization.\n    // For example, reuse graphic elements and only update the transform when\n    // roam or data zoom according to `actionType`.\n\n\n    var transOpt = customSeries.__transientTransitionOpt; // Enable user to disable transition animation by both set\n    // `from` and `to` dimension as `null`/`undefined`.\n\n    if (transOpt && (transOpt.from == null || transOpt.to == null)) {\n      oldData && oldData.each(function (oldIdx) {\n        doRemoveEl(oldData.getItemGraphicEl(oldIdx), customSeries, group);\n      });\n      data.each(function (newIdx) {\n        createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data, null);\n      });\n    } else {\n      var morphPreparation_1 = new MorphPreparation(customSeries, transOpt);\n      var diffMode = transOpt ? 'multiple' : 'oneToOne';\n      new DataDiffer(oldData ? oldData.getIndices() : [], data.getIndices(), createGetKey(oldData, diffMode, transOpt && transOpt.from), createGetKey(data, diffMode, transOpt && transOpt.to), null, diffMode).add(function (newIdx) {\n        createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data, null);\n      }).remove(function (oldIdx) {\n        doRemoveEl(oldData.getItemGraphicEl(oldIdx), customSeries, group);\n      }).update(function (newIdx, oldIdx) {\n        morphPreparation_1.reset('oneToOne');\n        var oldEl = oldData.getItemGraphicEl(oldIdx);\n        morphPreparation_1.findAndAddFrom(oldEl); // PENDING:\n        // if may morph, currently we alway recreate the whole el.\n        // because if reuse some of the el in the group tree, the old el has to\n        // be removed from the group, and consequently we can not calculate\n        // the \"global transition\" of the old element.\n        // But is there performance issue?\n\n        if (morphPreparation_1.hasFrom()) {\n          removeElementDirectly(oldEl, group);\n          oldEl = null;\n        }\n\n        createOrUpdateItem(api, oldEl, newIdx, renderItem(newIdx, payload), customSeries, group, data, morphPreparation_1);\n        morphPreparation_1.applyMorphing();\n      }).updateManyToOne(function (newIdx, oldIndices) {\n        morphPreparation_1.reset('manyToOne');\n\n        for (var i = 0; i < oldIndices.length; i++) {\n          var oldEl = oldData.getItemGraphicEl(oldIndices[i]);\n          morphPreparation_1.findAndAddFrom(oldEl);\n          removeElementDirectly(oldEl, group);\n        }\n\n        createOrUpdateItem(api, null, newIdx, renderItem(newIdx, payload), customSeries, group, data, morphPreparation_1);\n        morphPreparation_1.applyMorphing();\n      }).updateOneToMany(function (newIndices, oldIdx) {\n        morphPreparation_1.reset('oneToMany');\n        var newLen = newIndices.length;\n        var oldEl = oldData.getItemGraphicEl(oldIdx);\n        morphPreparation_1.findAndAddFrom(oldEl);\n        removeElementDirectly(oldEl, group);\n\n        for (var i = 0; i < newLen; i++) {\n          createOrUpdateItem(api, null, newIndices[i], renderItem(newIndices[i], payload), customSeries, group, data, morphPreparation_1);\n        }\n\n        morphPreparation_1.applyMorphing();\n      }).execute();\n    } // Do clipping\n\n\n    var clipPath = customSeries.get('clip', true) ? createClipPath(customSeries.coordinateSystem, false, customSeries) : null;\n\n    if (clipPath) {\n      group.setClipPath(clipPath);\n    } else {\n      group.removeClipPath();\n    }\n\n    this._data = data;\n  };\n\n  CustomSeriesView.prototype.incrementalPrepareRender = function (customSeries, ecModel, api) {\n    this.group.removeAll();\n    this._data = null;\n  };\n\n  CustomSeriesView.prototype.incrementalRender = function (params, customSeries, ecModel, api, payload) {\n    var data = customSeries.getData();\n    var renderItem = makeRenderItem(customSeries, data, ecModel, api);\n\n    function setIncrementalAndHoverLayer(el) {\n      if (!el.isGroup) {\n        el.incremental = true;\n        el.ensureState('emphasis').hoverLayer = true;\n      }\n    }\n\n    for (var idx = params.start; idx < params.end; idx++) {\n      var el = createOrUpdateItem(null, null, idx, renderItem(idx, payload), customSeries, this.group, data, null);\n      el && el.traverse(setIncrementalAndHoverLayer);\n    }\n  };\n\n  CustomSeriesView.prototype.filterForExposedEvent = function (eventType, query, targetEl, packedEvent) {\n    var elementName = query.element;\n\n    if (elementName == null || targetEl.name === elementName) {\n      return true;\n    } // Enable to give a name on a group made by `renderItem`, and listen\n    // events that triggerd by its descendents.\n\n\n    while ((targetEl = targetEl.__hostTarget || targetEl.parent) && targetEl !== this.group) {\n      if (targetEl.name === elementName) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  CustomSeriesView.type = 'custom';\n  return CustomSeriesView;\n}(ChartView);\n\nfunction createGetKey(data, diffMode, dimension) {\n  if (!data) {\n    return;\n  }\n\n  if (diffMode === 'oneToOne') {\n    return function (rawIdx, dataIndex) {\n      return data.getId(dataIndex);\n    };\n  }\n\n  var diffByDimName = data.getDimension(dimension);\n  var dimInfo = data.getDimensionInfo(diffByDimName);\n\n  if (!dimInfo) {\n    var errMsg = '';\n\n    if (process.env.NODE_ENV !== 'production') {\n      errMsg = dimension + \" is not a valid dimension.\";\n    }\n\n    throwError(errMsg);\n  }\n\n  var ordinalMeta = dimInfo.ordinalMeta;\n  return function (rawIdx, dataIndex) {\n    var key = data.get(diffByDimName, dataIndex);\n\n    if (ordinalMeta) {\n      key = ordinalMeta.categories[key];\n    }\n\n    return key == null || eqNaN(key) ? rawIdx + '' : '_ec_' + key;\n  };\n}\n\nfunction createEl(elOption) {\n  var graphicType = elOption.type;\n  var el; // Those graphic elements are not shapes. They should not be\n  // overwritten by users, so do them first.\n\n  if (graphicType === 'path') {\n    var shape = elOption.shape; // Using pathRect brings convenience to users sacle svg path.\n\n    var pathRect = shape.width != null && shape.height != null ? {\n      x: shape.x || 0,\n      y: shape.y || 0,\n      width: shape.width,\n      height: shape.height\n    } : null;\n    var pathData = getPathData(shape); // Path is also used for icon, so layout 'center' by default.\n\n    el = graphicUtil.makePath(pathData, null, pathRect, shape.layout || 'center');\n    inner(el).customPathData = pathData;\n  } else if (graphicType === 'image') {\n    el = new graphicUtil.Image({});\n    inner(el).customImagePath = elOption.style.image;\n  } else if (graphicType === 'text') {\n    el = new graphicUtil.Text({}); // inner(el).customText = (elOption.style as TextStyleProps).text;\n  } else if (graphicType === 'group') {\n    el = new graphicUtil.Group();\n  } else if (graphicType === 'compoundPath') {\n    throw new Error('\"compoundPath\" is not supported yet.');\n  } else {\n    var Clz = graphicUtil.getShapeClass(graphicType);\n\n    if (!Clz) {\n      var errMsg = '';\n\n      if (process.env.NODE_ENV !== 'production') {\n        errMsg = 'graphic type \"' + graphicType + '\" can not be found.';\n      }\n\n      throwError(errMsg);\n    }\n\n    el = new Clz();\n  }\n\n  inner(el).customGraphicType = graphicType;\n  el.name = elOption.name; // Compat ec4: the default z2 lift is 1. If changing the number,\n  // some cases probably be broken: hierarchy layout along z, like circle packing,\n  // where emphasis only intending to modify color/border rather than lift z2.\n\n  el.z2EmphasisLift = 1;\n  el.z2SelectLift = 1;\n  return el;\n}\n/**\n * ----------------------------------------------------------\n * [STRATEGY_MERGE] Merge properties or erase all properties:\n *\n * Based on the fact that the existing zr element probably be reused, we now consider whether\n * merge or erase all properties to the exsiting elements.\n * That is, if a certain props is not specified in the lastest return of `renderItem`:\n * + \"Merge\" means that do not modify the value on the existing element.\n * + \"Erase all\" means that use a default value to the existing element.\n *\n * \"Merge\" might bring some unexpected state retaining for users and \"erase all\" seams to be\n * more safe. \"erase all\" force users to specify all of the props each time, which is recommanded\n * in most cases.\n * But \"erase all\" theoretically disables the chance of performance optimization (e.g., just\n * generete shape and style at the first time rather than always do that).\n * So we still use \"merge\" rather than \"erase all\". If users need \"erase all\", they can\n * simple always set all of the props each time.\n * Some \"object-like\" config like `textConfig`, `textContent`, `style` which are not needed for\n * every elment, so we replace them only when user specify them. And the that is a total replace.\n *\n * TODO: there is no hint of 'isFirst' to users. So the performance enhancement can not be\n * performed yet. Consider the case:\n * (1) setOption to \"mergeChildren\" with a smaller children count\n * (2) Use dataZoom to make an item disappear.\n * (3) User dataZoom to make the item display again. At that time, renderItem need to return the\n * full option rather than partial option to recreate the element.\n *\n * ----------------------------------------------\n * [STRATEGY_NULL] `hasOwnProperty` or `== null`:\n *\n * Ditinguishing \"own property\" probably bring little trouble to user when make el options.\n * So we  trade a {xx: null} or {xx: undefined} as \"not specified\" if possible rather than\n * \"set them to null/undefined\". In most cases, props can not be cleared. Some typicall\n * clearable props like `style`/`textConfig`/`textContent` we enable `false` to means\n * \"clear\". In some othere special cases that the prop is able to set as null/undefined,\n * but not suitable to use `false`, `hasOwnProperty` is checked.\n *\n * ---------------------------------------------\n * [STRATEGY_TRANSITION] The rule of transition:\n * + For props on the root level of a element:\n *      If there is no `transition` specified, tansform props will be transitioned by default,\n *      which is the same as the previous setting in echarts4 and suitable for the scenario\n *      of dataZoom change.\n *      If `transition` specified, only the specified props will be transitioned.\n * + For props in `shape` and `style`:\n *      Only props specified in `transition` will be transitioned.\n * + Break:\n *      Since ec5, do not make transition to shape by default, because it might result in\n *      performance issue (especially `points` of polygon) and do not necessary in most cases.\n *\n * @return if `isMorphTo`, return `allPropsFinal`.\n */\n\n\nfunction updateElNormal( // Can be null/undefined\napi, el, // Whether be a morph target.\nisMorphTo, dataIndex, elOption, styleOpt, attachedTxInfo, seriesModel, isInit, isTextContent) {\n  var transFromProps = {};\n  var allPropsFinal = {};\n  var elDisplayable = el.isGroup ? null : el; // If be \"morph to\", delay the `updateElNormal` when all of the els in\n  // this data item processed. Because at that time we can get all of the\n  // \"morph from\" and make correct separate/combine.\n\n  !isMorphTo && prepareShapeOrExtraTransitionFrom('shape', el, null, elOption, transFromProps, isInit);\n  prepareShapeOrExtraAllPropsFinal('shape', elOption, allPropsFinal);\n  !isMorphTo && prepareShapeOrExtraTransitionFrom('extra', el, null, elOption, transFromProps, isInit);\n  prepareShapeOrExtraAllPropsFinal('extra', elOption, allPropsFinal);\n  !isMorphTo && prepareTransformTransitionFrom(el, null, elOption, transFromProps, isInit);\n  prepareTransformAllPropsFinal(elOption, allPropsFinal);\n  var txCfgOpt = attachedTxInfo && attachedTxInfo.normal.cfg;\n\n  if (txCfgOpt) {\n    // PENDING: whether use user object directly rather than clone?\n    // TODO:5.0 textConfig transition animation?\n    el.setTextConfig(txCfgOpt);\n  }\n\n  if (el.type === 'text' && styleOpt) {\n    var textOptionStyle = styleOpt; // Compatible with ec4: if `textFill` or `textStroke` exists use them.\n\n    hasOwn(textOptionStyle, 'textFill') && (textOptionStyle.fill = textOptionStyle.textFill);\n    hasOwn(textOptionStyle, 'textStroke') && (textOptionStyle.stroke = textOptionStyle.textStroke);\n  }\n\n  if (styleOpt) {\n    var decalPattern = void 0;\n    var decalObj = isPath(el) ? styleOpt.decal : null;\n\n    if (api && decalObj) {\n      decalObj.dirty = true;\n      decalPattern = createOrUpdatePatternFromDecal(decalObj, api);\n    } // Always overwrite in case user specify this prop.\n\n\n    styleOpt.__decalPattern = decalPattern;\n  }\n\n  !isMorphTo && prepareStyleTransitionFrom(el, null, elOption, styleOpt, transFromProps, isInit);\n\n  if (elDisplayable) {\n    hasOwn(elOption, 'invisible') && (elDisplayable.invisible = elOption.invisible);\n  } // If `isMorphTo`, we should not update these props to el directly, otherwise,\n  // when applying morph finally, the original prop are missing for making \"animation from\".\n\n\n  if (!isMorphTo) {\n    applyPropsFinal(el, allPropsFinal, styleOpt);\n    applyTransitionFrom(el, dataIndex, elOption, seriesModel, transFromProps, isInit);\n  } // Merge by default.\n\n\n  hasOwn(elOption, 'silent') && (el.silent = elOption.silent);\n  hasOwn(elOption, 'ignore') && (el.ignore = elOption.ignore);\n\n  if (!isTextContent) {\n    // `elOption.info` enables user to mount some info on\n    // elements and use them in event handlers.\n    // Update them only when user specified, otherwise, remain.\n    hasOwn(elOption, 'info') && (inner(el).info = elOption.info);\n  }\n\n  styleOpt ? el.dirty() : el.markRedraw();\n  return isMorphTo ? allPropsFinal : null;\n}\n\nfunction applyPropsFinal(el, // Can be null/undefined\nallPropsFinal, styleOpt) {\n  var elDisplayable = el.isGroup ? null : el;\n\n  if (elDisplayable && styleOpt) {\n    var decalPattern = styleOpt.__decalPattern;\n    var originalDecalObj = void 0;\n\n    if (decalPattern) {\n      originalDecalObj = styleOpt.decal;\n      styleOpt.decal = decalPattern;\n    } // PENDING: here the input style object is used directly.\n    // Good for performance but bad for compatibility control.\n\n\n    elDisplayable.useStyle(styleOpt);\n\n    if (decalPattern) {\n      styleOpt.decal = originalDecalObj;\n    } // When style object changed, how to trade the existing animation?\n    // It is probably conplicated and not needed to cover all the cases.\n    // But still need consider the case:\n    // (1) When using init animation on `style.opacity`, and before the animation\n    //     ended users triggers an update by mousewhell. At that time the init\n    //     animation should better be continued rather than terminated.\n    //     So after `useStyle` called, we should change the animation target manually\n    //     to continue the effect of the init animation.\n    // (2) PENDING: If the previous animation targeted at a `val1`, and currently we need\n    //     to update the value to `val2` and no animation declared, should be terminate\n    //     the previous animation or just modify the target of the animation?\n    //     Therotically That will happen not only on `style` but also on `shape` and\n    //     `transfrom` props. But we haven't handle this case at present yet.\n    // (3) PENDING: Is it proper to visit `animators` and `targetName`?\n\n\n    var animators = elDisplayable.animators;\n\n    for (var i = 0; i < animators.length; i++) {\n      var animator = animators[i]; // targetName is the \"topKey\".\n\n      if (animator.targetName === 'style') {\n        animator.changeTarget(elDisplayable.style);\n      }\n    }\n  } // Set el to the final state firstly.\n\n\n  allPropsFinal && el.attr(allPropsFinal);\n}\n\nfunction applyTransitionFrom(el, dataIndex, elOption, seriesModel, // Can be null/undefined\ntransFromProps, isInit) {\n  if (transFromProps) {\n    // Do not use `el.updateDuringAnimation` here becuase `el.updateDuringAnimation` will\n    // be called mutiple time in each animation frame. For example, if both \"transform\" props\n    // and shape props and style props changed, it will generate three animator and called\n    // one-by-one in each animation frame.\n    // We use the during in `animateTo/From` params.\n    var userDuring = elOption.during; // For simplicity, if during not specified, the previous during will not work any more.\n\n    inner(el).userDuring = userDuring;\n    var cfgDuringCall = userDuring ? bind(duringCall, {\n      el: el,\n      userDuring: userDuring\n    }) : null;\n    var cfg = {\n      dataIndex: dataIndex,\n      isFrom: true,\n      during: cfgDuringCall\n    };\n    isInit ? graphicUtil.initProps(el, transFromProps, seriesModel, cfg) : graphicUtil.updateProps(el, transFromProps, seriesModel, cfg);\n  }\n} // See [STRATEGY_TRANSITION]\n\n\nfunction prepareShapeOrExtraTransitionFrom(mainAttr, el, morphFromEl, elOption, transFromProps, isInit) {\n  var attrOpt = elOption[mainAttr];\n\n  if (!attrOpt) {\n    return;\n  }\n\n  var elPropsInAttr = el[mainAttr];\n  var transFromPropsInAttr;\n  var enterFrom = attrOpt.enterFrom;\n\n  if (isInit && enterFrom) {\n    !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n    var enterFromKeys = keys(enterFrom);\n\n    for (var i = 0; i < enterFromKeys.length; i++) {\n      // `enterFrom` props are not necessarily also declared in `shape`/`style`/...,\n      // for example, `opacity` can only declared in `enterFrom` but not in `style`.\n      var key = enterFromKeys[i]; // Do not clone, animator will perform that clone.\n\n      transFromPropsInAttr[key] = enterFrom[key];\n    }\n  }\n\n  if (!isInit && elPropsInAttr // Just ignore shape animation in morphing.\n  && !(morphFromEl != null && mainAttr === 'shape')) {\n    if (attrOpt.transition) {\n      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n      var transitionKeys = normalizeToArray(attrOpt.transition);\n\n      for (var i = 0; i < transitionKeys.length; i++) {\n        var key = transitionKeys[i];\n        var elVal = elPropsInAttr[key];\n\n        if (process.env.NODE_ENV !== 'production') {\n          checkNonStyleTansitionRefer(key, attrOpt[key], elVal);\n        } // Do not clone, see `checkNonStyleTansitionRefer`.\n\n\n        transFromPropsInAttr[key] = elVal;\n      }\n    } else if (indexOf(elOption.transition, mainAttr) >= 0) {\n      !transFromPropsInAttr && (transFromPropsInAttr = transFromProps[mainAttr] = {});\n      var elPropsInAttrKeys = keys(elPropsInAttr);\n\n      for (var i = 0; i < elPropsInAttrKeys.length; i++) {\n        var key = elPropsInAttrKeys[i];\n        var elVal = elPropsInAttr[key];\n\n        if (isNonStyleTransitionEnabled(attrOpt[key], elVal)) {\n          transFromPropsInAttr[key] = elVal;\n        }\n      }\n    }\n  }\n\n  var leaveTo = attrOpt.leaveTo;\n\n  if (leaveTo) {\n    var leaveToProps = getOrCreateLeaveToPropsFromEl(el);\n    var leaveToPropsInAttr = leaveToProps[mainAttr] || (leaveToProps[mainAttr] = {});\n    var leaveToKeys = keys(leaveTo);\n\n    for (var i = 0; i < leaveToKeys.length; i++) {\n      var key = leaveToKeys[i];\n      leaveToPropsInAttr[key] = leaveTo[key];\n    }\n  }\n}\n\nfunction prepareShapeOrExtraAllPropsFinal(mainAttr, elOption, allProps) {\n  var attrOpt = elOption[mainAttr];\n\n  if (!attrOpt) {\n    return;\n  }\n\n  var allPropsInAttr = allProps[mainAttr] = {};\n  var keysInAttr = keys(attrOpt);\n\n  for (var i = 0; i < keysInAttr.length; i++) {\n    var key = keysInAttr[i]; // To avoid share one object with different element, and\n    // to avoid user modify the object inexpectedly, have to clone.\n\n    allPropsInAttr[key] = cloneValue(attrOpt[key]);\n  }\n} // See [STRATEGY_TRANSITION].\n\n\nfunction prepareTransformTransitionFrom(el, morphFromEl, elOption, transFromProps, isInit) {\n  var enterFrom = elOption.enterFrom;\n\n  if (isInit && enterFrom) {\n    var enterFromKeys = keys(enterFrom);\n\n    for (var i = 0; i < enterFromKeys.length; i++) {\n      var key = enterFromKeys[i];\n\n      if (process.env.NODE_ENV !== 'production') {\n        checkTransformPropRefer(key, 'el.enterFrom');\n      } // Do not clone, animator will perform that clone.\n\n\n      transFromProps[key] = enterFrom[key];\n    }\n  }\n\n  if (!isInit) {\n    // If morphing, force transition all transform props.\n    // otherwise might have incorrect morphing animation.\n    if (morphFromEl) {\n      var fromTransformable = calcOldElLocalTransformBasedOnNewElParent(morphFromEl, el);\n      setTransformPropToTransitionFrom(transFromProps, 'x', fromTransformable);\n      setTransformPropToTransitionFrom(transFromProps, 'y', fromTransformable);\n      setTransformPropToTransitionFrom(transFromProps, 'scaleX', fromTransformable);\n      setTransformPropToTransitionFrom(transFromProps, 'scaleY', fromTransformable);\n      setTransformPropToTransitionFrom(transFromProps, 'originX', fromTransformable);\n      setTransformPropToTransitionFrom(transFromProps, 'originY', fromTransformable);\n      setTransformPropToTransitionFrom(transFromProps, 'rotation', fromTransformable);\n    } else if (elOption.transition) {\n      var transitionKeys = normalizeToArray(elOption.transition);\n\n      for (var i = 0; i < transitionKeys.length; i++) {\n        var key = transitionKeys[i];\n\n        if (key === 'style' || key === 'shape' || key === 'extra') {\n          continue;\n        }\n\n        var elVal = el[key];\n\n        if (process.env.NODE_ENV !== 'production') {\n          checkTransformPropRefer(key, 'el.transition');\n          checkNonStyleTansitionRefer(key, elOption[key], elVal);\n        } // Do not clone, see `checkNonStyleTansitionRefer`.\n\n\n        transFromProps[key] = elVal;\n      }\n    } // This default transition see [STRATEGY_TRANSITION]\n    else {\n        setTransformPropToTransitionFrom(transFromProps, 'x', el);\n        setTransformPropToTransitionFrom(transFromProps, 'y', el);\n      }\n  }\n\n  var leaveTo = elOption.leaveTo;\n\n  if (leaveTo) {\n    var leaveToProps = getOrCreateLeaveToPropsFromEl(el);\n    var leaveToKeys = keys(leaveTo);\n\n    for (var i = 0; i < leaveToKeys.length; i++) {\n      var key = leaveToKeys[i];\n\n      if (process.env.NODE_ENV !== 'production') {\n        checkTransformPropRefer(key, 'el.leaveTo');\n      }\n\n      leaveToProps[key] = leaveTo[key];\n    }\n  }\n}\n\nfunction prepareTransformAllPropsFinal(elOption, allProps) {\n  setLagecyTransformProp(elOption, allProps, 'position');\n  setLagecyTransformProp(elOption, allProps, 'scale');\n  setLagecyTransformProp(elOption, allProps, 'origin');\n  setTransformProp(elOption, allProps, 'x');\n  setTransformProp(elOption, allProps, 'y');\n  setTransformProp(elOption, allProps, 'scaleX');\n  setTransformProp(elOption, allProps, 'scaleY');\n  setTransformProp(elOption, allProps, 'originX');\n  setTransformProp(elOption, allProps, 'originY');\n  setTransformProp(elOption, allProps, 'rotation');\n} // See [STRATEGY_TRANSITION].\n\n\nfunction prepareStyleTransitionFrom(el, morphFromEl, elOption, styleOpt, transFromProps, isInit) {\n  if (!styleOpt) {\n    return;\n  } // At present in \"many-to-one\"/\"one-to-many\" case, to not support \"many\" have\n  // different styles and make style transitions. That might be a rare case.\n\n\n  var fromEl = morphFromEl || el;\n  var fromElStyle = fromEl.style;\n  var transFromStyleProps;\n  var enterFrom = styleOpt.enterFrom;\n\n  if (isInit && enterFrom) {\n    var enterFromKeys = keys(enterFrom);\n    !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n\n    for (var i = 0; i < enterFromKeys.length; i++) {\n      var key = enterFromKeys[i]; // Do not clone, animator will perform that clone.\n\n      transFromStyleProps[key] = enterFrom[key];\n    }\n  }\n\n  if (!isInit && fromElStyle) {\n    if (styleOpt.transition) {\n      var transitionKeys = normalizeToArray(styleOpt.transition);\n      !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n\n      for (var i = 0; i < transitionKeys.length; i++) {\n        var key = transitionKeys[i];\n        var elVal = fromElStyle[key]; // Do not clone, see `checkNonStyleTansitionRefer`.\n\n        transFromStyleProps[key] = elVal;\n      }\n    } else if (el.getAnimationStyleProps && indexOf(elOption.transition, 'style') >= 0) {\n      var animationProps = el.getAnimationStyleProps();\n      var animationStyleProps = animationProps ? animationProps.style : null;\n\n      if (animationStyleProps) {\n        !transFromStyleProps && (transFromStyleProps = transFromProps.style = {});\n        var styleKeys = keys(styleOpt);\n\n        for (var i = 0; i < styleKeys.length; i++) {\n          var key = styleKeys[i];\n\n          if (animationStyleProps[key]) {\n            var elVal = fromElStyle[key];\n            transFromStyleProps[key] = elVal;\n          }\n        }\n      }\n    }\n  }\n\n  var leaveTo = styleOpt.leaveTo;\n\n  if (leaveTo) {\n    var leaveToKeys = keys(leaveTo);\n    var leaveToProps = getOrCreateLeaveToPropsFromEl(el);\n    var leaveToStyleProps = leaveToProps.style || (leaveToProps.style = {});\n\n    for (var i = 0; i < leaveToKeys.length; i++) {\n      var key = leaveToKeys[i];\n      leaveToStyleProps[key] = leaveTo[key];\n    }\n  }\n}\n/**\n * If make \"transform\"(x/y/scaleX/scaleY/orient/originX/originY) transition between\n * two path elements that have different hierarchy, before we retrieve the \"from\" props,\n * we have to calculate the local transition of the \"oldPath\" based on the parent of\n * the \"newPath\".\n * At present, the case only happend in \"morphing\". Without morphing, the transform\n * transition are all between elements in the same hierarchy, where this kind of process\n * is not needed.\n *\n * [CAVEAT]:\n * This method makes sense only if: (very tricky)\n * (1) \"newEl\" has been added to its final parent.\n * (2) Local transform props of \"newPath.parent\" are not at their final value but already\n * have been at the \"from value\".\n *     This is currently ensured by:\n *     (2.1) \"graphicUtil.animationFrom\", which will set the element to the \"from value\"\n *     immediately.\n *     (2.2) \"morph\" option is not allowed to be set on Group, so all of the groups have\n *     been finished their \"updateElNormal\" when calling this method in morphing process.\n */\n\n\nfunction calcOldElLocalTransformBasedOnNewElParent(oldEl, newEl) {\n  if (!oldEl || oldEl === newEl || oldEl.parent === newEl.parent) {\n    return oldEl;\n  } // Not sure oldEl is rendered (may have \"lazyUpdate\"),\n  // so always call `getComputedTransform`.\n\n\n  var tmpM = tmpTransformable.transform || (tmpTransformable.transform = matrix.identity([]));\n  var oldGlobalTransform = oldEl.getComputedTransform();\n  oldGlobalTransform ? matrix.copy(tmpM, oldGlobalTransform) : matrix.identity(tmpM);\n  var newParent = newEl.parent;\n\n  if (newParent) {\n    newParent.getComputedTransform();\n  }\n\n  tmpTransformable.originX = oldEl.originX;\n  tmpTransformable.originY = oldEl.originY;\n  tmpTransformable.parent = newParent;\n  tmpTransformable.decomposeTransform();\n  return tmpTransformable;\n}\n\nvar checkNonStyleTansitionRefer;\n\nif (process.env.NODE_ENV !== 'production') {\n  checkNonStyleTansitionRefer = function (propName, optVal, elVal) {\n    if (!isArrayLike(optVal)) {\n      assert(optVal != null && isFinite(optVal), 'Prop `' + propName + '` must refer to a finite number or ArrayLike for transition.');\n    } else {\n      // Try not to copy array for performance, but if user use the same object in different\n      // call of `renderItem`, it will casue animation transition fail.\n      assert(optVal !== elVal, 'Prop `' + propName + '` must use different Array object each time for transition.');\n    }\n  };\n}\n\nfunction isNonStyleTransitionEnabled(optVal, elVal) {\n  // The same as `checkNonStyleTansitionRefer`.\n  return !isArrayLike(optVal) ? optVal != null && isFinite(optVal) : optVal !== elVal;\n}\n\nvar checkTransformPropRefer;\n\nif (process.env.NODE_ENV !== 'production') {\n  checkTransformPropRefer = function (key, usedIn) {\n    assert(hasOwn(TRANSFORM_PROPS, key), 'Prop `' + key + '` is not a permitted in `' + usedIn + '`. ' + 'Only `' + keys(TRANSFORM_PROPS).join('`, `') + '` are permitted.');\n  };\n}\n\nfunction getOrCreateLeaveToPropsFromEl(el) {\n  var innerEl = inner(el);\n  return innerEl.leaveToProps || (innerEl.leaveToProps = {});\n} // Use it to avoid it be exposed to user.\n\n\nvar tmpDuringScope = {};\nvar customDuringAPI = {\n  // Usually other props do not need to be changed in animation during.\n  setTransform: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(hasOwn(TRANSFORM_PROPS, key), 'Only ' + transformPropNamesStr + ' available in `setTransform`.');\n    }\n\n    tmpDuringScope.el[key] = val;\n    return this;\n  },\n  getTransform: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(hasOwn(TRANSFORM_PROPS, key), 'Only ' + transformPropNamesStr + ' available in `getTransform`.');\n    }\n\n    return tmpDuringScope.el[key];\n  },\n  setShape: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n\n    var shape = tmpDuringScope.el.shape || (tmpDuringScope.el.shape = {});\n    shape[key] = val;\n    tmpDuringScope.isShapeDirty = true;\n    return this;\n  },\n  getShape: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n\n    var shape = tmpDuringScope.el.shape;\n\n    if (shape) {\n      return shape[key];\n    }\n  },\n  setStyle: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n\n    var style = tmpDuringScope.el.style;\n\n    if (style) {\n      if (process.env.NODE_ENV !== 'production') {\n        if (eqNaN(val)) {\n          warn('style.' + key + ' must not be assigned with NaN.');\n        }\n      }\n\n      style[key] = val;\n      tmpDuringScope.isStyleDirty = true;\n    }\n\n    return this;\n  },\n  getStyle: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n\n    var style = tmpDuringScope.el.style;\n\n    if (style) {\n      return style[key];\n    }\n  },\n  setExtra: function (key, val) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n\n    var extra = tmpDuringScope.el.extra || (tmpDuringScope.el.extra = {});\n    extra[key] = val;\n    return this;\n  },\n  getExtra: function (key) {\n    if (process.env.NODE_ENV !== 'production') {\n      assertNotReserved(key);\n    }\n\n    var extra = tmpDuringScope.el.extra;\n\n    if (extra) {\n      return extra[key];\n    }\n  }\n};\n\nfunction assertNotReserved(key) {\n  if (process.env.NODE_ENV !== 'production') {\n    if (key === 'transition' || key === 'enterFrom' || key === 'leaveTo') {\n      throw new Error('key must not be \"' + key + '\"');\n    }\n  }\n}\n\nfunction duringCall() {\n  // Do not provide \"percent\" until some requirements come.\n  // Because consider thies case:\n  // enterFrom: {x: 100, y: 30}, transition: 'x'.\n  // And enter duration is different from update duration.\n  // Thus it might be confused about the meaning of \"percent\" in during callback.\n  var scope = this;\n  var el = scope.el;\n\n  if (!el) {\n    return;\n  } // If el is remove from zr by reason like legend, during still need to called,\n  // becuase el will be added back to zr and the prop value should not be incorrect.\n\n\n  var newstUserDuring = inner(el).userDuring;\n  var scopeUserDuring = scope.userDuring; // Ensured a during is only called once in each animation frame.\n  // If a during is called multiple times in one frame, maybe some users' calulation logic\n  // might be wrong (not sure whether this usage exists).\n  // The case of a during might be called twice can be: by default there is a animator for\n  // 'x', 'y' when init. Before the init animation finished, call `setOption` to start\n  // another animators for 'style'/'shape'/'extra'.\n\n  if (newstUserDuring !== scopeUserDuring) {\n    // release\n    scope.el = scope.userDuring = null;\n    return;\n  }\n\n  tmpDuringScope.el = el;\n  tmpDuringScope.isShapeDirty = false;\n  tmpDuringScope.isStyleDirty = false; // Give no `this` to user in \"during\" calling.\n\n  scopeUserDuring(customDuringAPI);\n\n  if (tmpDuringScope.isShapeDirty && el.dirtyShape) {\n    el.dirtyShape();\n  }\n\n  if (tmpDuringScope.isStyleDirty && el.dirtyStyle) {\n    el.dirtyStyle();\n  } // markRedraw() will be called by default in during.\n  // FIXME `this.markRedraw();` directly ?\n  // FIXME: if in future meet the case that some prop will be both modified in `during` and `state`,\n  // consider the issue that the prop might be incorrect when return to \"normal\" state.\n\n}\n\nfunction updateElOnState(state, el, elStateOpt, styleOpt, attachedTxInfo, isRoot, isTextContent) {\n  var elDisplayable = el.isGroup ? null : el;\n  var txCfgOpt = attachedTxInfo && attachedTxInfo[state].cfg; // PENDING:5.0 support customize scale change and transition animation?\n\n  if (elDisplayable) {\n    // By default support auto lift color when hover whether `emphasis` specified.\n    var stateObj = elDisplayable.ensureState(state);\n\n    if (styleOpt === false) {\n      var existingEmphasisState = elDisplayable.getState(state);\n\n      if (existingEmphasisState) {\n        existingEmphasisState.style = null;\n      }\n    } else {\n      // style is needed to enable defaut emphasis.\n      stateObj.style = styleOpt || null;\n    } // If `elOption.styleEmphasis` or `elOption.emphasis.style` is `false`,\n    // remove hover style.\n    // If `elOption.textConfig` or `elOption.emphasis.textConfig` is null/undefined, it does not\n    // make sense. So for simplicity, we do not ditinguish `hasOwnProperty` and null/undefined.\n\n\n    if (txCfgOpt) {\n      stateObj.textConfig = txCfgOpt;\n    }\n\n    setDefaultStateProxy(elDisplayable);\n  }\n}\n\nfunction updateZ(el, elOption, seriesModel, attachedTxInfo) {\n  // Group not support textContent and not support z yet.\n  if (el.isGroup) {\n    return;\n  }\n\n  var elDisplayable = el;\n  var currentZ = seriesModel.currentZ;\n  var currentZLevel = seriesModel.currentZLevel; // Always erase.\n\n  elDisplayable.z = currentZ;\n  elDisplayable.zlevel = currentZLevel; // z2 must not be null/undefined, otherwise sort error may occur.\n\n  var optZ2 = elOption.z2;\n  optZ2 != null && (elDisplayable.z2 = optZ2 || 0);\n\n  for (var i = 0; i < STATES.length; i++) {\n    updateZForEachState(elDisplayable, elOption, STATES[i]);\n  }\n}\n\nfunction updateZForEachState(elDisplayable, elOption, state) {\n  var isNormal = state === NORMAL;\n  var elStateOpt = isNormal ? elOption : retrieveStateOption(elOption, state);\n  var optZ2 = elStateOpt ? elStateOpt.z2 : null;\n  var stateObj;\n\n  if (optZ2 != null) {\n    // Do not `ensureState` until required.\n    stateObj = isNormal ? elDisplayable : elDisplayable.ensureState(state);\n    stateObj.z2 = optZ2 || 0;\n  }\n}\n\nfunction setLagecyTransformProp(elOption, targetProps, legacyName, fromTransformable // If provided, retrieve from the element.\n) {\n  var legacyArr = elOption[legacyName];\n  var xyName = LEGACY_TRANSFORM_PROPS[legacyName];\n\n  if (legacyArr) {\n    if (fromTransformable) {\n      targetProps[xyName[0]] = fromTransformable[xyName[0]];\n      targetProps[xyName[1]] = fromTransformable[xyName[1]];\n    } else {\n      targetProps[xyName[0]] = legacyArr[0];\n      targetProps[xyName[1]] = legacyArr[1];\n    }\n  }\n}\n\nfunction setTransformProp(elOption, allProps, name, fromTransformable // If provided, retrieve from the element.\n) {\n  if (elOption[name] != null) {\n    allProps[name] = fromTransformable ? fromTransformable[name] : elOption[name];\n  }\n}\n\nfunction setTransformPropToTransitionFrom(transitionFrom, name, fromTransformable // If provided, retrieve from the element.\n) {\n  if (fromTransformable) {\n    transitionFrom[name] = fromTransformable[name];\n  }\n}\n\nfunction makeRenderItem(customSeries, data, ecModel, api) {\n  var renderItem = customSeries.get('renderItem');\n  var coordSys = customSeries.coordinateSystem;\n  var prepareResult = {};\n\n  if (coordSys) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert(renderItem, 'series.render is required.');\n      assert(coordSys.prepareCustoms || prepareCustoms[coordSys.type], 'This coordSys does not support custom series.');\n    } // `coordSys.prepareCustoms` is used for external coord sys like bmap.\n\n\n    prepareResult = coordSys.prepareCustoms ? coordSys.prepareCustoms(coordSys) : prepareCustoms[coordSys.type](coordSys);\n  }\n\n  var userAPI = defaults({\n    getWidth: api.getWidth,\n    getHeight: api.getHeight,\n    getZr: api.getZr,\n    getDevicePixelRatio: api.getDevicePixelRatio,\n    value: value,\n    style: style,\n    ordinalRawValue: ordinalRawValue,\n    styleEmphasis: styleEmphasis,\n    visual: visual,\n    barLayout: barLayout,\n    currentSeriesIndices: currentSeriesIndices,\n    font: font\n  }, prepareResult.api || {});\n  var userParams = {\n    // The life cycle of context: current round of rendering.\n    // The global life cycle is probably not necessary, because\n    // user can store global status by themselves.\n    context: {},\n    seriesId: customSeries.id,\n    seriesName: customSeries.name,\n    seriesIndex: customSeries.seriesIndex,\n    coordSys: prepareResult.coordSys,\n    dataInsideLength: data.count(),\n    encode: wrapEncodeDef(customSeries.getData())\n  }; // If someday intending to refactor them to a class, should consider do not\n  // break change: currently these attribute member are encapsulated in a closure\n  // so that do not need to force user to call these method with a scope.\n  // Do not support call `api` asynchronously without dataIndexInside input.\n\n  var currDataIndexInside;\n  var currItemModel;\n  var currItemStyleModels = {};\n  var currLabelModels = {};\n  var seriesItemStyleModels = {};\n  var seriesLabelModels = {};\n\n  for (var i = 0; i < STATES.length; i++) {\n    var stateName = STATES[i];\n    seriesItemStyleModels[stateName] = customSeries.getModel(PATH_ITEM_STYLE[stateName]);\n    seriesLabelModels[stateName] = customSeries.getModel(PATH_LABEL[stateName]);\n  }\n\n  function getItemModel(dataIndexInside) {\n    return dataIndexInside === currDataIndexInside ? currItemModel || (currItemModel = data.getItemModel(dataIndexInside)) : data.getItemModel(dataIndexInside);\n  }\n\n  function getItemStyleModel(dataIndexInside, state) {\n    return !data.hasItemOption ? seriesItemStyleModels[state] : dataIndexInside === currDataIndexInside ? currItemStyleModels[state] || (currItemStyleModels[state] = getItemModel(dataIndexInside).getModel(PATH_ITEM_STYLE[state])) : getItemModel(dataIndexInside).getModel(PATH_ITEM_STYLE[state]);\n  }\n\n  function getLabelModel(dataIndexInside, state) {\n    return !data.hasItemOption ? seriesLabelModels[state] : dataIndexInside === currDataIndexInside ? currLabelModels[state] || (currLabelModels[state] = getItemModel(dataIndexInside).getModel(PATH_LABEL[state])) : getItemModel(dataIndexInside).getModel(PATH_LABEL[state]);\n  }\n\n  return function (dataIndexInside, payload) {\n    currDataIndexInside = dataIndexInside;\n    currItemModel = null;\n    currItemStyleModels = {};\n    currLabelModels = {};\n    return renderItem && renderItem(defaults({\n      dataIndexInside: dataIndexInside,\n      dataIndex: data.getRawIndex(dataIndexInside),\n      // Can be used for optimization when zoom or roam.\n      actionType: payload ? payload.type : null\n    }, userParams), userAPI);\n  };\n  /**\n   * @public\n   * @param dim by default 0.\n   * @param dataIndexInside by default `currDataIndexInside`.\n   */\n\n  function value(dim, dataIndexInside) {\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n    return data.get(data.getDimension(dim || 0), dataIndexInside);\n  }\n  /**\n   * @public\n   * @param dim by default 0.\n   * @param dataIndexInside by default `currDataIndexInside`.\n   */\n\n\n  function ordinalRawValue(dim, dataIndexInside) {\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n    var dimInfo = data.getDimensionInfo(dim || 0);\n\n    if (!dimInfo) {\n      return;\n    }\n\n    var val = data.get(dimInfo.name, dataIndexInside);\n    var ordinalMeta = dimInfo && dimInfo.ordinalMeta;\n    return ordinalMeta ? ordinalMeta.categories[val] : val;\n  }\n  /**\n   * @deprecated The orgininal intention of `api.style` is enable to set itemStyle\n   * like other series. But it not necessary and not easy to give a strict definition\n   * of what it return. And since echarts5 it needs to be make compat work. So\n   * deprecates it since echarts5.\n   *\n   * By default, `visual` is applied to style (to support visualMap).\n   * `visual.color` is applied at `fill`. If user want apply visual.color on `stroke`,\n   * it can be implemented as:\n   * `api.style({stroke: api.visual('color'), fill: null})`;\n   *\n   * [Compat]: since ec5, RectText has been separated from its hosts el.\n   * so `api.style()` will only return the style from `itemStyle` but not handle `label`\n   * any more. But `series.label` config is never published in doc.\n   * We still compat it in `api.style()`. But not encourage to use it and will still not\n   * to pulish it to doc.\n   * @public\n   * @param dataIndexInside by default `currDataIndexInside`.\n   */\n\n\n  function style(userProps, dataIndexInside) {\n    if (process.env.NODE_ENV !== 'production') {\n      warnDeprecated('api.style', 'Please write literal style directly instead.');\n    }\n\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n    var style = data.getItemVisual(dataIndexInside, 'style');\n    var visualColor = style && style.fill;\n    var opacity = style && style.opacity;\n    var itemStyle = getItemStyleModel(dataIndexInside, NORMAL).getItemStyle();\n    visualColor != null && (itemStyle.fill = visualColor);\n    opacity != null && (itemStyle.opacity = opacity);\n    var opt = {\n      inheritColor: isString(visualColor) ? visualColor : '#000'\n    };\n    var labelModel = getLabelModel(dataIndexInside, NORMAL); // Now that the feture of \"auto adjust text fill/stroke\" has been migrated to zrender\n    // since ec5, we should set `isAttached` as `false` here and make compat in\n    // `convertToEC4StyleForCustomSerise`.\n\n    var textStyle = labelStyleHelper.createTextStyle(labelModel, null, opt, false, true);\n    textStyle.text = labelModel.getShallow('show') ? retrieve2(customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;\n    var textConfig = labelStyleHelper.createTextConfig(labelModel, opt, false);\n    preFetchFromExtra(userProps, itemStyle);\n    itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);\n    userProps && applyUserPropsAfter(itemStyle, userProps);\n    itemStyle.legacy = true;\n    return itemStyle;\n  }\n  /**\n   * @deprecated The reason see `api.style()`\n   * @public\n   * @param dataIndexInside by default `currDataIndexInside`.\n   */\n\n\n  function styleEmphasis(userProps, dataIndexInside) {\n    if (process.env.NODE_ENV !== 'production') {\n      warnDeprecated('api.styleEmphasis', 'Please write literal style directly instead.');\n    }\n\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n    var itemStyle = getItemStyleModel(dataIndexInside, EMPHASIS).getItemStyle();\n    var labelModel = getLabelModel(dataIndexInside, EMPHASIS);\n    var textStyle = labelStyleHelper.createTextStyle(labelModel, null, null, true, true);\n    textStyle.text = labelModel.getShallow('show') ? retrieve3(customSeries.getFormattedLabel(dataIndexInside, EMPHASIS), customSeries.getFormattedLabel(dataIndexInside, NORMAL), getDefaultLabel(data, dataIndexInside)) : null;\n    var textConfig = labelStyleHelper.createTextConfig(labelModel, null, true);\n    preFetchFromExtra(userProps, itemStyle);\n    itemStyle = convertToEC4StyleForCustomSerise(itemStyle, textStyle, textConfig);\n    userProps && applyUserPropsAfter(itemStyle, userProps);\n    itemStyle.legacy = true;\n    return itemStyle;\n  }\n\n  function applyUserPropsAfter(itemStyle, extra) {\n    for (var key in extra) {\n      if (hasOwn(extra, key)) {\n        itemStyle[key] = extra[key];\n      }\n    }\n  }\n\n  function preFetchFromExtra(extra, itemStyle) {\n    // A trick to retrieve those props firstly, which are used to\n    // apply auto inside fill/stroke in `convertToEC4StyleForCustomSerise`.\n    // (It's not reasonable but only for a degree of compat)\n    if (extra) {\n      extra.textFill && (itemStyle.textFill = extra.textFill);\n      extra.textPosition && (itemStyle.textPosition = extra.textPosition);\n    }\n  }\n  /**\n   * @public\n   * @param dataIndexInside by default `currDataIndexInside`.\n   */\n\n\n  function visual(visualType, dataIndexInside) {\n    dataIndexInside == null && (dataIndexInside = currDataIndexInside);\n\n    if (hasOwn(STYLE_VISUAL_TYPE, visualType)) {\n      var style_1 = data.getItemVisual(dataIndexInside, 'style');\n      return style_1 ? style_1[STYLE_VISUAL_TYPE[visualType]] : null;\n    } // Only support these visuals. Other visual might be inner tricky\n    // for performance (like `style`), do not expose to users.\n\n\n    if (hasOwn(NON_STYLE_VISUAL_PROPS, visualType)) {\n      return data.getItemVisual(dataIndexInside, visualType);\n    }\n  }\n  /**\n   * @public\n   * @return If not support, return undefined.\n   */\n\n\n  function barLayout(opt) {\n    if (coordSys.type === 'cartesian2d') {\n      var baseAxis = coordSys.getBaseAxis();\n      return getLayoutOnAxis(defaults({\n        axis: baseAxis\n      }, opt));\n    }\n  }\n  /**\n   * @public\n   */\n\n\n  function currentSeriesIndices() {\n    return ecModel.getCurrentSeriesIndices();\n  }\n  /**\n   * @public\n   * @return font string\n   */\n\n\n  function font(opt) {\n    return labelStyleHelper.getFont(opt, ecModel);\n  }\n}\n\nfunction wrapEncodeDef(data) {\n  var encodeDef = {};\n  each(data.dimensions, function (dimName, dataDimIndex) {\n    var dimInfo = data.getDimensionInfo(dimName);\n\n    if (!dimInfo.isExtraCoord) {\n      var coordDim = dimInfo.coordDim;\n      var dataDims = encodeDef[coordDim] = encodeDef[coordDim] || [];\n      dataDims[dimInfo.coordDimIndex] = dataDimIndex;\n    }\n  });\n  return encodeDef;\n}\n\nfunction createOrUpdateItem(api, el, dataIndex, elOption, seriesModel, group, data, morphPreparation) {\n  // [Rule]\n  // If `renderItem` returns `null`/`undefined`/`false`, remove the previous el if existing.\n  //     (It seems that violate the \"merge\" principle, but most of users probably intuitively\n  //     regard \"return;\" as \"show nothing element whatever\", so make a exception to meet the\n  //     most cases.)\n  // The rule or \"merge\" see [STRATEGY_MERGE].\n  // If `elOption` is `null`/`undefined`/`false` (when `renderItem` returns nothing).\n  if (!elOption) {\n    removeElementDirectly(el, group);\n    return;\n  }\n\n  el = doCreateOrUpdateEl(api, el, dataIndex, elOption, seriesModel, group, true, morphPreparation);\n  el && data.setItemGraphicEl(dataIndex, el);\n  el && enableHoverEmphasis(el, elOption.focus, elOption.blurScope);\n  return el;\n}\n\nfunction doCreateOrUpdateEl(api, el, dataIndex, elOption, seriesModel, group, isRoot, morphPreparation) {\n  if (process.env.NODE_ENV !== 'production') {\n    assert(elOption, 'should not have an null/undefined element setting');\n  }\n\n  var toBeReplacedIdx = -1;\n\n  if (el && doesElNeedRecreate(el, elOption) // || (\n  //     // PENDING: even in one-to-one mapping case, if el is marked as morph,\n  //     // do not sure whether the el will be mapped to another el with different\n  //     // hierarchy in Group tree. So always recreate el rather than reuse the el.\n  //     morphPreparation && morphPreparation.isOneToOneFrom(el)\n  // )\n  ) {\n    // Should keep at the original index, otherwise \"merge by index\" will be incorrect.\n    toBeReplacedIdx = group.childrenRef().indexOf(el);\n    el = null;\n  }\n\n  var elIsNewCreated = !el;\n\n  if (!el) {\n    el = createEl(elOption);\n  } else {\n    // FIMXE:NEXT unified clearState?\n    // If in some case the performance issue arised, consider\n    // do not clearState but update cached normal state directly.\n    el.clearStates();\n  }\n\n  var canMorph = inner(el).canMorph = elOption.morph && isPath(el);\n  var thisElIsMorphTo = canMorph && morphPreparation && morphPreparation.hasFrom(); // Use update animation when morph is enabled.\n\n  var isInit = elIsNewCreated && !thisElIsMorphTo;\n  attachedTxInfoTmp.normal.cfg = attachedTxInfoTmp.normal.conOpt = attachedTxInfoTmp.emphasis.cfg = attachedTxInfoTmp.emphasis.conOpt = attachedTxInfoTmp.blur.cfg = attachedTxInfoTmp.blur.conOpt = attachedTxInfoTmp.select.cfg = attachedTxInfoTmp.select.conOpt = null;\n  attachedTxInfoTmp.isLegacy = false;\n  doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfoTmp);\n  doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit);\n  var pendingAllPropsFinal = updateElNormal(api, el, thisElIsMorphTo, dataIndex, elOption, elOption.style, attachedTxInfoTmp, seriesModel, isInit, false);\n\n  if (thisElIsMorphTo) {\n    morphPreparation.addTo(el, elOption, dataIndex, pendingAllPropsFinal);\n  }\n\n  for (var i = 0; i < STATES.length; i++) {\n    var stateName = STATES[i];\n\n    if (stateName !== NORMAL) {\n      var otherStateOpt = retrieveStateOption(elOption, stateName);\n      var otherStyleOpt = retrieveStyleOptionOnState(elOption, otherStateOpt, stateName);\n      updateElOnState(stateName, el, otherStateOpt, otherStyleOpt, attachedTxInfoTmp, isRoot, false);\n    }\n  }\n\n  updateZ(el, elOption, seriesModel, attachedTxInfoTmp);\n\n  if (elOption.type === 'group') {\n    mergeChildren(api, el, dataIndex, elOption, seriesModel, morphPreparation);\n  }\n\n  if (toBeReplacedIdx >= 0) {\n    group.replaceAt(el, toBeReplacedIdx);\n  } else {\n    group.add(el);\n  }\n\n  return el;\n} // `el` must not be null/undefined.\n\n\nfunction doesElNeedRecreate(el, elOption) {\n  var elInner = inner(el);\n  var elOptionType = elOption.type;\n  var elOptionShape = elOption.shape;\n  var elOptionStyle = elOption.style;\n  return (// If `elOptionType` is `null`, follow the merge principle.\n    elOptionType != null && elOptionType !== elInner.customGraphicType || elOptionType === 'path' && hasOwnPathData(elOptionShape) && getPathData(elOptionShape) !== elInner.customPathData || elOptionType === 'image' && hasOwn(elOptionStyle, 'image') && elOptionStyle.image !== elInner.customImagePath // // FIXME test and remove this restriction?\n    // || (elOptionType === 'text'\n    //     && hasOwn(elOptionStyle, 'text')\n    //     && (elOptionStyle as TextStyleProps).text !== elInner.customText\n    // )\n\n  );\n}\n\nfunction doCreateOrUpdateClipPath(el, dataIndex, elOption, seriesModel, isInit) {\n  // Based on the \"merge\" principle, if no clipPath provided,\n  // do nothing. The exists clip will be totally removed only if\n  // `el.clipPath` is `false`. Otherwise it will be merged/replaced.\n  var clipPathOpt = elOption.clipPath;\n\n  if (clipPathOpt === false) {\n    if (el && el.getClipPath()) {\n      el.removeClipPath();\n    }\n  } else if (clipPathOpt) {\n    var clipPath = el.getClipPath();\n\n    if (clipPath && doesElNeedRecreate(clipPath, clipPathOpt)) {\n      clipPath = null;\n    }\n\n    if (!clipPath) {\n      clipPath = createEl(clipPathOpt);\n\n      if (process.env.NODE_ENV !== 'production') {\n        assert(clipPath instanceof graphicUtil.Path, 'Only any type of `path` can be used in `clipPath`, rather than ' + clipPath.type + '.');\n      }\n\n      el.setClipPath(clipPath);\n    }\n\n    updateElNormal(null, clipPath, null, dataIndex, clipPathOpt, null, null, seriesModel, isInit, false);\n  } // If not define `clipPath` in option, do nothing unnecessary.\n\n}\n\nfunction doCreateOrUpdateAttachedTx(el, dataIndex, elOption, seriesModel, isInit, attachedTxInfo) {\n  // group do not support textContent temporarily untill necessary.\n  if (el.isGroup) {\n    return;\n  } // Normal must be called before emphasis, for `isLegacy` detection.\n\n\n  processTxInfo(elOption, null, attachedTxInfo);\n  processTxInfo(elOption, EMPHASIS, attachedTxInfo); // If `elOption.textConfig` or `elOption.textContent` is null/undefined, it does not make sence.\n  // So for simplicity, if \"elOption hasOwnProperty of them but be null/undefined\", we do not\n  // trade them as set to null to el.\n  // Especially:\n  // `elOption.textContent: false` means remove textContent.\n  // `elOption.textContent.emphasis.style: false` means remove the style from emphasis state.\n\n  var txConOptNormal = attachedTxInfo.normal.conOpt;\n  var txConOptEmphasis = attachedTxInfo.emphasis.conOpt;\n  var txConOptBlur = attachedTxInfo.blur.conOpt;\n  var txConOptSelect = attachedTxInfo.select.conOpt;\n\n  if (txConOptNormal != null || txConOptEmphasis != null || txConOptSelect != null || txConOptBlur != null) {\n    var textContent = el.getTextContent();\n\n    if (txConOptNormal === false) {\n      textContent && el.removeTextContent();\n    } else {\n      txConOptNormal = attachedTxInfo.normal.conOpt = txConOptNormal || {\n        type: 'text'\n      };\n\n      if (!textContent) {\n        textContent = createEl(txConOptNormal);\n        el.setTextContent(textContent);\n      } else {\n        // If in some case the performance issue arised, consider\n        // do not clearState but update cached normal state directly.\n        textContent.clearStates();\n      }\n\n      var txConStlOptNormal = txConOptNormal && txConOptNormal.style;\n      updateElNormal(null, textContent, null, dataIndex, txConOptNormal, txConStlOptNormal, null, seriesModel, isInit, true);\n\n      for (var i = 0; i < STATES.length; i++) {\n        var stateName = STATES[i];\n\n        if (stateName !== NORMAL) {\n          var txConOptOtherState = attachedTxInfo[stateName].conOpt;\n          updateElOnState(stateName, textContent, txConOptOtherState, retrieveStyleOptionOnState(txConOptNormal, txConOptOtherState, stateName), null, false, true);\n        }\n      }\n\n      txConStlOptNormal ? textContent.dirty() : textContent.markRedraw();\n    }\n  }\n}\n\nfunction processTxInfo(elOption, state, attachedTxInfo) {\n  var stateOpt = !state ? elOption : retrieveStateOption(elOption, state);\n  var styleOpt = !state ? elOption.style : retrieveStyleOptionOnState(elOption, stateOpt, EMPHASIS);\n  var elType = elOption.type;\n  var txCfg = stateOpt ? stateOpt.textConfig : null;\n  var txConOptNormal = elOption.textContent;\n  var txConOpt = !txConOptNormal ? null : !state ? txConOptNormal : retrieveStateOption(txConOptNormal, state);\n\n  if (styleOpt && ( // Because emphasis style has little info to detect legacy,\n  // if normal is legacy, emphasis is trade as legacy.\n  attachedTxInfo.isLegacy || isEC4CompatibleStyle(styleOpt, elType, !!txCfg, !!txConOpt))) {\n    attachedTxInfo.isLegacy = true;\n    var convertResult = convertFromEC4CompatibleStyle(styleOpt, elType, !state); // Explicitly specified `textConfig` and `textContent` has higher priority than\n    // the ones generated by legacy style. Otherwise if users use them and `api.style`\n    // at the same time, they not both work and hardly to known why.\n\n    if (!txCfg && convertResult.textConfig) {\n      txCfg = convertResult.textConfig;\n    }\n\n    if (!txConOpt && convertResult.textContent) {\n      txConOpt = convertResult.textContent;\n    }\n  }\n\n  if (!state && txConOpt) {\n    var txConOptNormal_1 = txConOpt; // `textContent: {type: 'text'}`, the \"type\" is easy to be missing. So we tolerate it.\n\n    !txConOptNormal_1.type && (txConOptNormal_1.type = 'text');\n\n    if (process.env.NODE_ENV !== 'production') {\n      // Do not tolerate incorret type for forward compat.\n      txConOptNormal_1.type !== 'text' && assert(txConOptNormal_1.type === 'text', 'textContent.type must be \"text\"');\n    }\n  }\n\n  var info = !state ? attachedTxInfo.normal : attachedTxInfo[state];\n  info.cfg = txCfg;\n  info.conOpt = txConOpt;\n}\n\nfunction retrieveStateOption(elOption, state) {\n  return !state ? elOption : elOption ? elOption[state] : null;\n}\n\nfunction retrieveStyleOptionOnState(stateOptionNormal, stateOption, state) {\n  var style = stateOption && stateOption.style;\n\n  if (style == null && state === EMPHASIS && stateOptionNormal) {\n    style = stateOptionNormal.styleEmphasis;\n  }\n\n  return style;\n} // Usage:\n// (1) By default, `elOption.$mergeChildren` is `'byIndex'`, which indicates that\n//     the existing children will not be removed, and enables the feature that\n//     update some of the props of some of the children simply by construct\n//     the returned children of `renderItem` like:\n//     `var children = group.children = []; children[3] = {opacity: 0.5};`\n// (2) If `elOption.$mergeChildren` is `'byName'`, add/update/remove children\n//     by child.name. But that might be lower performance.\n// (3) If `elOption.$mergeChildren` is `false`, the existing children will be\n//     replaced totally.\n// (4) If `!elOption.children`, following the \"merge\" principle, nothing will happen.\n//\n// For implementation simpleness, do not provide a direct way to remove sinlge\n// child (otherwise the total indicies of the children array have to be modified).\n// User can remove a single child by set its `ignore` as `true`.\n\n\nfunction mergeChildren(api, el, dataIndex, elOption, seriesModel, morphPreparation) {\n  var newChildren = elOption.children;\n  var newLen = newChildren ? newChildren.length : 0;\n  var mergeChildren = elOption.$mergeChildren; // `diffChildrenByName` has been deprecated.\n\n  var byName = mergeChildren === 'byName' || elOption.diffChildrenByName;\n  var notMerge = mergeChildren === false; // For better performance on roam update, only enter if necessary.\n\n  if (!newLen && !byName && !notMerge) {\n    return;\n  }\n\n  if (byName) {\n    diffGroupChildren({\n      api: api,\n      oldChildren: el.children() || [],\n      newChildren: newChildren || [],\n      dataIndex: dataIndex,\n      seriesModel: seriesModel,\n      group: el,\n      morphPreparation: morphPreparation\n    });\n    return;\n  }\n\n  notMerge && el.removeAll(); // Mapping children of a group simply by index, which\n  // might be better performance.\n\n  var index = 0;\n\n  for (; index < newLen; index++) {\n    newChildren[index] && doCreateOrUpdateEl(api, el.childAt(index), dataIndex, newChildren[index], seriesModel, el, false, morphPreparation);\n  }\n\n  for (var i = el.childCount() - 1; i >= index; i--) {\n    // Do not supprot leave elements that are not mentioned in the latest\n    // `renderItem` return. Otherwise users may not have a clear and simple\n    // concept that how to contorl all of the elements.\n    doRemoveEl(el.childAt(i), seriesModel, el);\n  }\n}\n\nfunction diffGroupChildren(context) {\n  new DataDiffer(context.oldChildren, context.newChildren, getKey, getKey, context).add(processAddUpdate).update(processAddUpdate).remove(processRemove).execute();\n}\n\nfunction getKey(item, idx) {\n  var name = item && item.name;\n  return name != null ? name : GROUP_DIFF_PREFIX + idx;\n}\n\nfunction processAddUpdate(newIndex, oldIndex) {\n  var context = this.context;\n  var childOption = newIndex != null ? context.newChildren[newIndex] : null;\n  var child = oldIndex != null ? context.oldChildren[oldIndex] : null;\n  doCreateOrUpdateEl(context.api, child, context.dataIndex, childOption, context.seriesModel, context.group, false, context.morphPreparation);\n}\n\nfunction processRemove(oldIndex) {\n  var context = this.context;\n  var child = context.oldChildren[oldIndex];\n  doRemoveEl(child, context.seriesModel, context.group);\n}\n\nfunction doRemoveEl(el, seriesModel, group) {\n  if (el) {\n    var leaveToProps = inner(el).leaveToProps;\n    leaveToProps ? graphicUtil.updateProps(el, leaveToProps, seriesModel, {\n      cb: function () {\n        group.remove(el);\n      }\n    }) : group.remove(el);\n  }\n}\n/**\n * @return SVG Path data.\n */\n\n\nfunction getPathData(shape) {\n  // \"d\" follows the SVG convention.\n  return shape && (shape.pathData || shape.d);\n}\n\nfunction hasOwnPathData(shape) {\n  return shape && (hasOwn(shape, 'pathData') || hasOwn(shape, 'd'));\n}\n\nfunction isPath(el) {\n  return el && el instanceof graphicUtil.Path;\n}\n\nfunction removeElementDirectly(el, group) {\n  el && group.remove(el);\n}\n/**\n * Any morph-potential el should added by `morphPreparation.addTo(el)`.\n * And they may apply morph or not when `morphPreparation.applyMorphing()`.\n * But at least, all of the \"to\" elements will apply all of the updates\n * as `doCreateOrUpdateItem` did.\n */\n\n\nvar MorphPreparation =\n/** @class */\nfunction () {\n  function MorphPreparation(seriesModel, transOpt) {\n    this._fromList = [];\n    this._toList = [];\n    this._toElOptionList = [];\n    this._allPropsFinalList = [];\n    this._toDataIndices = []; // Key: `toDataIndex`, not `toIdx`\n\n    this._morphConfigList = [];\n    this._seriesModel = seriesModel;\n    this._transOpt = transOpt;\n  }\n\n  MorphPreparation.prototype.hasFrom = function () {\n    return !!this._fromList.length;\n  }; // isOneToOneFrom(el: Element): boolean {\n  //     if (el && inner(el).canMorph) {\n  //         const fromList = this._fromList;\n  //         for (let i = 0; i < fromList.length; i++) {\n  //             if (fromList[i] === el) {\n  //                 return true;\n  //             }\n  //         }\n  //     }\n  // }\n\n\n  MorphPreparation.prototype.findAndAddFrom = function (el) {\n    if (!el) {\n      return;\n    }\n\n    if (inner(el).canMorph) {\n      this._fromList.push(el);\n    }\n\n    if (el.isGroup) {\n      var children = el.childrenRef();\n\n      for (var i = 0; i < children.length; i++) {\n        this.findAndAddFrom(children[i]);\n      }\n    }\n  };\n\n  MorphPreparation.prototype.addTo = function (path, elOption, dataIndex, allPropsFinal) {\n    if (path) {\n      this._toList.push(path);\n\n      this._toElOptionList.push(elOption);\n\n      this._toDataIndices.push(dataIndex);\n\n      this._allPropsFinalList.push(allPropsFinal);\n    }\n  };\n\n  MorphPreparation.prototype.applyMorphing = function () {\n    // [MORPHING_LOGIC_HINT]\n    // Pay attention to the order:\n    // (A) Apply `allPropsFinal` and `styleOption` to \"to\".\n    //     (Then \"to\" becomes to the final state.)\n    // (B) Apply `morphPath`/`combine`/`separate`.\n    //     (Based on the current state of \"from\" and the final state of \"to\".)\n    //     (Then we may get \"from.subList\" or \"to.subList\".)\n    // (C) Copy the related props from \"from\" to \"from.subList\", from \"to\" to \"to.subList\".\n    // (D) Collect `transitionFromProps` for \"to\" and \"to.subList\"\n    //     (Based on \"from\" or \"from.subList\".)\n    // (E) Apply `transitionFromProps` to \"to\" and \"to.subList\"\n    //     (It might change the prop values to the first frame value.)\n    // Case_I:\n    //     If (D) should be after (C), we use sequence: A - B - C - D - E\n    // Case_II:\n    //     If (A) should be after (D), we use sequence: D - A - B - C - E\n    // [MORPHING_LOGIC_HINT]\n    // zrender `morphPath`/`combine`/`separate` only manages the shape animation.\n    // Other props (like transfrom, style transition) will handled in echarts).\n    // [MORPHING_LOGIC_HINT]\n    // Make sure `applyPropsFinal` always be called for \"to\".\n    var type = this._type;\n    var fromList = this._fromList;\n    var toList = this._toList;\n    var toListLen = toList.length;\n    var fromListLen = fromList.length;\n\n    if (!fromListLen || !toListLen) {\n      return;\n    }\n\n    if (type === 'oneToOne') {\n      // In one-to-one case, we by default apply a simple rule:\n      // map \"from\" and \"to\" one by one.\n      // For this case: old_data_item_el and new_data_item_el\n      // has the same hierarchy of group tree but only some path type changed.\n      for (var toIdx = 0; toIdx < toListLen; toIdx++) {\n        this._oneToOneForSingleTo(toIdx, toIdx);\n      }\n    } else if (type === 'manyToOne') {\n      // A rough strategy: if there are more than one \"to\", we simply divide \"fromList\" equally.\n      var fromSingleSegLen = Math.max(1, Math.floor(fromListLen / toListLen));\n\n      for (var toIdx = 0, fromIdxStart = 0; toIdx < toListLen; toIdx++, fromIdxStart += fromSingleSegLen) {\n        var fromCount = toIdx + 1 >= toListLen ? fromListLen - fromIdxStart : fromSingleSegLen;\n\n        this._manyToOneForSingleTo(toIdx, fromIdxStart >= fromListLen ? null : fromIdxStart, fromCount);\n      }\n    } else if (type === 'oneToMany') {\n      // A rough strategy: if there are more than one \"from\", we simply divide \"toList\" equally.\n      var toSingleSegLen = Math.max(1, Math.floor(toListLen / fromListLen));\n\n      for (var toIdxStart = 0, fromIdx = 0; toIdxStart < toListLen; toIdxStart += toSingleSegLen, fromIdx++) {\n        var toCount = toIdxStart + toSingleSegLen >= toListLen ? toListLen - toIdxStart : toSingleSegLen;\n\n        this._oneToManyForSingleFrom(toIdxStart, toCount, fromIdx >= fromListLen ? null : fromIdx);\n      }\n    }\n  };\n\n  MorphPreparation.prototype._oneToOneForSingleTo = function ( // \"to\" must NOT be null/undefined.\n  toIdx, // May `fromIdx >= this._fromList.length`\n  fromIdx) {\n    var to = this._toList[toIdx];\n    var toElOption = this._toElOptionList[toIdx];\n    var toDataIndex = this._toDataIndices[toIdx];\n    var allPropsFinal = this._allPropsFinalList[toIdx];\n    var from = this._fromList[fromIdx];\n\n    var elAnimationConfig = this._getOrCreateMorphConfig(toDataIndex);\n\n    var morphDuration = elAnimationConfig.duration;\n\n    if (from && isCombiningPath(from)) {\n      applyPropsFinal(to, allPropsFinal, toElOption.style);\n\n      if (morphDuration) {\n        var combineResult = combine([from], to, elAnimationConfig, copyPropsWhenDivided);\n\n        this._processResultIndividuals(combineResult, toIdx, null);\n      } // The target el will not be displayed and transition from multiple path.\n      // transition on the target el does not make sense.\n\n    } else {\n      var morphFrom = morphDuration // from === to usually happen in scenarios where internal update like\n      // \"dataZoom\", \"legendToggle\" happen. If from is not in any morphing,\n      // we do not need to call `morphPath`.\n      && from && (from !== to || isInAnyMorphing(from)) ? from : null; // See [Case_II] above.\n      // In this case, there is probably `from === to`. And the `transitionFromProps` collecting\n      // does not depends on morphing. So we collect `transitionFromProps` first.\n\n      var transFromProps = {};\n      prepareShapeOrExtraTransitionFrom('shape', to, morphFrom, toElOption, transFromProps, false);\n      prepareShapeOrExtraTransitionFrom('extra', to, morphFrom, toElOption, transFromProps, false);\n      prepareTransformTransitionFrom(to, morphFrom, toElOption, transFromProps, false);\n      prepareStyleTransitionFrom(to, morphFrom, toElOption, toElOption.style, transFromProps, false);\n      applyPropsFinal(to, allPropsFinal, toElOption.style);\n\n      if (morphFrom) {\n        morphPath(morphFrom, to, elAnimationConfig);\n      }\n\n      applyTransitionFrom(to, toDataIndex, toElOption, this._seriesModel, transFromProps, false);\n    }\n  };\n\n  MorphPreparation.prototype._manyToOneForSingleTo = function ( // \"to\" must NOT be null/undefined.\n  toIdx, // May be null.\n  fromIdxStart, fromCount) {\n    var to = this._toList[toIdx];\n    var toElOption = this._toElOptionList[toIdx];\n    var allPropsFinal = this._allPropsFinalList[toIdx];\n    applyPropsFinal(to, allPropsFinal, toElOption.style);\n\n    var elAnimationConfig = this._getOrCreateMorphConfig(this._toDataIndices[toIdx]);\n\n    if (elAnimationConfig.duration && fromIdxStart != null) {\n      var combineFromList = [];\n\n      for (var fromIdx = fromIdxStart; fromIdx < fromCount; fromIdx++) {\n        combineFromList.push(this._fromList[fromIdx]);\n      }\n\n      var combineResult = combine(combineFromList, to, elAnimationConfig, copyPropsWhenDivided);\n\n      this._processResultIndividuals(combineResult, toIdx, null);\n    }\n  };\n\n  MorphPreparation.prototype._oneToManyForSingleFrom = function ( // \"to\" must NOT be null/undefined.\n  toIdxStart, toCount, // May be null\n  fromIdx) {\n    var from = fromIdx == null ? null : this._fromList[fromIdx];\n    var toList = this._toList;\n    var separateToList = [];\n\n    for (var toIdx = toIdxStart; toIdx < toCount; toIdx++) {\n      var to = toList[toIdx];\n      applyPropsFinal(to, this._allPropsFinalList[toIdx], this._toElOptionList[toIdx].style);\n      separateToList.push(to);\n    }\n\n    var elAnimationConfig = this._getOrCreateMorphConfig(this._toDataIndices[toIdxStart]);\n\n    if (elAnimationConfig.duration && from) {\n      var separateResult = separate(from, separateToList, elAnimationConfig, copyPropsWhenDivided);\n\n      this._processResultIndividuals(separateResult, toIdxStart, toCount);\n    }\n  };\n\n  MorphPreparation.prototype._processResultIndividuals = function (combineSeparateResult, toIdxStart, toCount) {\n    var isSeparate = toCount != null;\n\n    for (var i = 0; i < combineSeparateResult.count; i++) {\n      var fromIndividual = combineSeparateResult.fromIndividuals[i];\n      var toIndividual = combineSeparateResult.toIndividuals[i]; // Here it's a trick:\n      // For \"combine\" case, all of the `toIndividuals` map to the same `toIdx`.\n      // For \"separate\" case, the `toIndividuals` map to some certain segment of `_toList` accurately.\n\n      var toIdx = toIdxStart + (isSeparate ? i : 0);\n      var toElOption = this._toElOptionList[toIdx];\n      var dataIndex = this._toDataIndices[toIdx];\n      var transFromProps = {};\n      prepareTransformTransitionFrom(toIndividual, fromIndividual, toElOption, transFromProps, false);\n      prepareStyleTransitionFrom(toIndividual, fromIndividual, toElOption, toElOption.style, transFromProps, false);\n      applyTransitionFrom(toIndividual, dataIndex, toElOption, this._seriesModel, transFromProps, false);\n    }\n  };\n\n  MorphPreparation.prototype._getOrCreateMorphConfig = function (dataIndex) {\n    var morphConfigList = this._morphConfigList;\n    var config = morphConfigList[dataIndex];\n\n    if (config) {\n      return config;\n    }\n\n    var duration;\n    var easing;\n    var delay;\n    var seriesModel = this._seriesModel;\n    var transOpt = this._transOpt;\n\n    if (seriesModel.isAnimationEnabled()) {\n      // PENDING: refactor? this is the same logic as `src/util/graphic.ts#animateOrSetProps`.\n      var animationPayload = void 0;\n\n      if (seriesModel && seriesModel.ecModel) {\n        var updatePayload = seriesModel.ecModel.getUpdatePayload();\n        animationPayload = updatePayload && updatePayload.animation;\n      }\n\n      if (animationPayload) {\n        duration = animationPayload.duration || 0;\n        easing = animationPayload.easing || 'cubicOut';\n        delay = animationPayload.delay || 0;\n      } else {\n        easing = seriesModel.get('animationEasingUpdate');\n        var delayOption = seriesModel.get('animationDelayUpdate');\n        delay = isFunction(delayOption) ? delayOption(dataIndex) : delayOption;\n        var durationOption = seriesModel.get('animationDurationUpdate');\n        duration = isFunction(durationOption) ? durationOption(dataIndex) : durationOption;\n      }\n    }\n\n    config = {\n      duration: duration || 0,\n      delay: delay,\n      easing: easing,\n      dividingMethod: transOpt ? transOpt.dividingMethod : null\n    };\n    morphConfigList[dataIndex] = config;\n    return config;\n  };\n\n  MorphPreparation.prototype.reset = function (type) {\n    // `this._morphConfigList` can be kept. It only related to `dataIndex`.\n    this._type = type;\n    this._fromList.length = this._toList.length = this._toElOptionList.length = this._allPropsFinalList.length = this._toDataIndices.length = 0;\n  };\n\n  return MorphPreparation;\n}();\n\nfunction copyPropsWhenDivided(srcPath, tarPath, willClone) {\n  // Do not copy transform props.\n  // Sub paths are transfrom based on their host path.\n  // tarPath.x = srcPath.x;\n  // tarPath.y = srcPath.y;\n  // tarPath.scaleX = srcPath.scaleX;\n  // tarPath.scaleY = srcPath.scaleY;\n  // tarPath.originX = srcPath.originX;\n  // tarPath.originY = srcPath.originY;\n  // If just carry the style, will not be modifed, so do not copy.\n  tarPath.style = willClone ? clone(srcPath.style) : srcPath.style;\n  tarPath.zlevel = srcPath.zlevel;\n  tarPath.z = srcPath.z;\n  tarPath.z2 = srcPath.z2;\n}\n\nexport function install(registers) {\n  registers.registerChartView(CustomSeriesView);\n  registers.registerSeriesModel(CustomSeriesModel);\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}