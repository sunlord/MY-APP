{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport PathProxy from '../core/PathProxy';\nimport { cubicSubdivide } from '../core/curve';\nimport { defaults, assert, noop, clone } from '../core/util';\nimport { lerp } from '../core/vector';\nimport Rect from '../graphic/shape/Rect';\nimport Sector from '../graphic/shape/Sector';\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar PROP_XY = ['x', 'y'];\nvar PROP_WH = ['width', 'height'];\nvar tmpArr = [];\nfunction aroundEqual(a, b) {\n  return Math.abs(a - b) < 1e-5;\n}\nexport function pathToBezierCurves(path) {\n  var data = path.data;\n  var len = path.len();\n  var bezierArray = [];\n  var currentSubpath;\n  var xi = 0;\n  var yi = 0;\n  var x0 = 0;\n  var y0 = 0;\n  function createNewSubpath(x, y) {\n    if (currentSubpath && currentSubpath.length > 2) {\n      bezierArray.push(currentSubpath);\n    }\n    currentSubpath = [x, y];\n  }\n  function addLine(x0, y0, x1, y1) {\n    if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n      currentSubpath.push(x0, y0, x1, y1, x1, y1);\n    }\n  }\n  function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n    var delta = Math.abs(endAngle - startAngle);\n    var len = Math.tan(delta / 4) * 4 / 3;\n    var dir = endAngle < startAngle ? -1 : 1;\n    var c1 = Math.cos(startAngle);\n    var s1 = Math.sin(startAngle);\n    var c2 = Math.cos(endAngle);\n    var s2 = Math.sin(endAngle);\n    var x1 = c1 * rx + cx;\n    var y1 = s1 * ry + cy;\n    var x4 = c2 * rx + cx;\n    var y4 = s2 * ry + cy;\n    var hx = rx * len * dir;\n    var hy = ry * len * dir;\n    currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n  }\n  var x1;\n  var y1;\n  var x2;\n  var y2;\n  for (var i = 0; i < len;) {\n    var cmd = data[i++];\n    var isFirst = i === 1;\n    if (isFirst) {\n      xi = data[i];\n      yi = data[i + 1];\n      x0 = xi;\n      y0 = yi;\n      if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n        currentSubpath = [x0, y0];\n      }\n    }\n    switch (cmd) {\n      case CMD.M:\n        xi = x0 = data[i++];\n        yi = y0 = data[i++];\n        createNewSubpath(x0, y0);\n        break;\n      case CMD.L:\n        x1 = data[i++];\n        y1 = data[i++];\n        addLine(xi, yi, x1, y1);\n        xi = x1;\n        yi = y1;\n        break;\n      case CMD.C:\n        currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n        break;\n      case CMD.Q:\n        x1 = data[i++];\n        y1 = data[i++];\n        x2 = data[i++];\n        y2 = data[i++];\n        currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n        xi = x2;\n        yi = y2;\n        break;\n      case CMD.A:\n        var cx = data[i++];\n        var cy = data[i++];\n        var rx = data[i++];\n        var ry = data[i++];\n        var startAngle = data[i++];\n        var endAngle = data[i++] + startAngle;\n        i += 1;\n        var anticlockwise = !data[i++];\n        x1 = Math.cos(startAngle) * rx + cx;\n        y1 = Math.sin(startAngle) * ry + cy;\n        if (isFirst) {\n          x0 = x1;\n          y0 = y1;\n          createNewSubpath(x0, y0);\n        } else {\n          addLine(xi, yi, x1, y1);\n        }\n        xi = Math.cos(endAngle) * rx + cx;\n        yi = Math.sin(endAngle) * ry + cy;\n        var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n        for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n          var nextAngle = anticlockwise ? Math.max(angle + step, endAngle) : Math.min(angle + step, endAngle);\n          addArc(angle, nextAngle, cx, cy, rx, ry);\n        }\n        break;\n      case CMD.R:\n        x0 = xi = data[i++];\n        y0 = yi = data[i++];\n        x1 = x0 + data[i++];\n        y1 = y0 + data[i++];\n        createNewSubpath(x1, y0);\n        addLine(x1, y0, x1, y1);\n        addLine(x1, y1, x0, y1);\n        addLine(x0, y1, x0, y0);\n        addLine(x0, y0, x1, y0);\n        break;\n      case CMD.Z:\n        currentSubpath && addLine(xi, yi, x0, y0);\n        xi = x0;\n        yi = y0;\n        break;\n    }\n  }\n  if (currentSubpath && currentSubpath.length > 2) {\n    bezierArray.push(currentSubpath);\n  }\n  return bezierArray;\n}\nfunction alignSubpath(subpath1, subpath2) {\n  var len1 = subpath1.length;\n  var len2 = subpath2.length;\n  if (len1 === len2) {\n    return [subpath1, subpath2];\n  }\n  var shorterPath = len1 < len2 ? subpath1 : subpath2;\n  var shorterLen = Math.min(len1, len2);\n  var diff = Math.abs(len2 - len1) / 6;\n  var shorterBezierCount = (shorterLen - 2) / 6;\n  var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n  var newSubpath = [shorterPath[0], shorterPath[1]];\n  var remained = diff;\n  var tmpSegX = [];\n  var tmpSegY = [];\n  for (var i = 2; i < shorterLen;) {\n    var x0 = shorterPath[i - 2];\n    var y0 = shorterPath[i - 1];\n    var x1 = shorterPath[i++];\n    var y1 = shorterPath[i++];\n    var x2 = shorterPath[i++];\n    var y2 = shorterPath[i++];\n    var x3 = shorterPath[i++];\n    var y3 = shorterPath[i++];\n    if (remained <= 0) {\n      newSubpath.push(x1, y1, x2, y2, x3, y3);\n      continue;\n    }\n    var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n    for (var k = 1; k <= actualSubDivCount; k++) {\n      var p = k / actualSubDivCount;\n      cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n      cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n      x0 = tmpSegX[3];\n      y0 = tmpSegY[3];\n      newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n      x1 = tmpSegX[5];\n      y1 = tmpSegY[5];\n      x2 = tmpSegX[6];\n      y2 = tmpSegY[6];\n    }\n    remained -= actualSubDivCount - 1;\n  }\n  return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n  var len = lastSubpathSubpath.length;\n  var lastX = lastSubpathSubpath[len - 2];\n  var lastY = lastSubpathSubpath[len - 1];\n  var newSubpath = [];\n  for (var i = 0; i < otherSubpath.length;) {\n    newSubpath[i++] = lastX;\n    newSubpath[i++] = lastY;\n  }\n  return newSubpath;\n}\nexport function alignBezierCurves(array1, array2) {\n  var _a;\n  var lastSubpath1;\n  var lastSubpath2;\n  var newArray1 = [];\n  var newArray2 = [];\n  for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n    var subpath1 = array1[i];\n    var subpath2 = array2[i];\n    var newSubpath1 = void 0;\n    var newSubpath2 = void 0;\n    if (!subpath1) {\n      newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n      newSubpath2 = subpath2;\n    } else if (!subpath2) {\n      newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n      newSubpath1 = subpath1;\n    } else {\n      _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n      lastSubpath1 = newSubpath1;\n      lastSubpath2 = newSubpath2;\n    }\n    newArray1.push(newSubpath1);\n    newArray2.push(newSubpath2);\n  }\n  return [newArray1, newArray2];\n}\nexport function centroid(array) {\n  var signedArea = 0;\n  var cx = 0;\n  var cy = 0;\n  var len = array.length;\n  for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n    var x0 = array[j];\n    var y0 = array[j + 1];\n    var x1 = array[i];\n    var y1 = array[i + 1];\n    var a = x0 * y1 - x1 * y0;\n    signedArea += a;\n    cx += (x0 + x1) * a;\n    cy += (y0 + y1) * a;\n  }\n  if (signedArea === 0) {\n    return [array[0] || 0, array[1] || 0];\n  }\n  return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n  var bezierCount = (fromSubBeziers.length - 2) / 6;\n  var bestScore = Infinity;\n  var bestOffset = 0;\n  var len = fromSubBeziers.length;\n  var len2 = len - 2;\n  for (var offset = 0; offset < bezierCount; offset++) {\n    var cursorOffset = offset * 6;\n    var score = 0;\n    for (var k = 0; k < len; k += 2) {\n      var idx = k === 0 ? cursorOffset : (cursorOffset + k - 2) % len2 + 2;\n      var x0 = fromSubBeziers[idx] - fromCp[0];\n      var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n      var x1 = toSubBeziers[k] - toCp[0];\n      var y1 = toSubBeziers[k + 1] - toCp[1];\n      var dx = x1 - x0;\n      var dy = y1 - y0;\n      score += dx * dx + dy * dy;\n    }\n    if (score < bestScore) {\n      bestScore = score;\n      bestOffset = offset;\n    }\n  }\n  return bestOffset;\n}\nfunction reverse(array) {\n  var newArr = [];\n  var len = array.length;\n  for (var i = 0; i < len; i += 2) {\n    newArr[i] = array[len - i - 2];\n    newArr[i + 1] = array[len - i - 1];\n  }\n  return newArr;\n}\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n  var result = [];\n  var fromNeedsReverse;\n  for (var i = 0; i < fromArr.length; i++) {\n    var fromSubpathBezier = fromArr[i];\n    var toSubpathBezier = toArr[i];\n    var fromCp = centroid(fromSubpathBezier);\n    var toCp = centroid(toSubpathBezier);\n    if (fromNeedsReverse == null) {\n      fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n    }\n    var newFromSubpathBezier = [];\n    var newToSubpathBezier = [];\n    var bestAngle = 0;\n    var bestScore = Infinity;\n    var tmpArr_1 = [];\n    var len = fromSubpathBezier.length;\n    if (fromNeedsReverse) {\n      fromSubpathBezier = reverse(fromSubpathBezier);\n    }\n    var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n    var len2 = len - 2;\n    for (var k = 0; k < len2; k += 2) {\n      var idx = (offset + k) % len2 + 2;\n      newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n      newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n    }\n    newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n    newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n    if (searchAngleIteration > 0) {\n      var step = searchAngleRange / searchAngleIteration;\n      for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        var score = 0;\n        for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n          var x0 = newFromSubpathBezier[k];\n          var y0 = newFromSubpathBezier[k + 1];\n          var x1 = toSubpathBezier[k] - toCp[0];\n          var y1 = toSubpathBezier[k + 1] - toCp[1];\n          var newX1 = x1 * ca - y1 * sa;\n          var newY1 = x1 * sa + y1 * ca;\n          tmpArr_1[k] = newX1;\n          tmpArr_1[k + 1] = newY1;\n          var dx = newX1 - x0;\n          var dy = newY1 - y0;\n          score += dx * dx + dy * dy;\n        }\n        if (score < bestScore) {\n          bestScore = score;\n          bestAngle = angle;\n          for (var m = 0; m < tmpArr_1.length; m++) {\n            newToSubpathBezier[m] = tmpArr_1[m];\n          }\n        }\n      }\n    } else {\n      for (var i_1 = 0; i_1 < len; i_1 += 2) {\n        newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n        newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n      }\n    }\n    result.push({\n      from: newFromSubpathBezier,\n      to: newToSubpathBezier,\n      fromCp: fromCp,\n      toCp: toCp,\n      rotation: -bestAngle\n    });\n  }\n  return result;\n}\nexport function morphPath(fromPath, toPath, animationOpts) {\n  var fromPathProxy;\n  var toPathProxy;\n  if (!fromPath || !toPath) {\n    return toPath;\n  }\n  !fromPath.path && fromPath.createPathProxy();\n  fromPathProxy = fromPath.path;\n  fromPathProxy.beginPath();\n  fromPath.buildPath(fromPathProxy, fromPath.shape);\n  !toPath.path && toPath.createPathProxy();\n  toPathProxy = toPath.path;\n  toPathProxy === fromPathProxy && (toPathProxy = new PathProxy(false));\n  toPathProxy.beginPath();\n  if (isIndividualMorphingPath(toPath)) {\n    toPath.__oldBuildPath(toPathProxy, toPath.shape);\n  } else {\n    toPath.buildPath(toPathProxy, toPath.shape);\n  }\n  var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)),\n    fromBezierCurves = _a[0],\n    toBezierCurves = _a[1];\n  var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n  becomeIndividualMorphingPath(toPath, morphingData, 0);\n  var oldDone = animationOpts && animationOpts.done;\n  var oldAborted = animationOpts && animationOpts.aborted;\n  var oldDuring = animationOpts && animationOpts.during;\n  toPath.animateTo({\n    __morphT: 1\n  }, defaults({\n    during: function (p) {\n      toPath.dirtyShape();\n      oldDuring && oldDuring(p);\n    },\n    done: function () {\n      restoreIndividualMorphingPath(toPath);\n      toPath.createPathProxy();\n      toPath.dirtyShape();\n      oldDone && oldDone();\n    },\n    aborted: function () {\n      oldAborted && oldAborted();\n    }\n  }, animationOpts));\n  return toPath;\n}\nfunction morphingPathBuildPath(path) {\n  var morphingData = this.__morphingData;\n  var t = this.__morphT;\n  var onet = 1 - t;\n  var newCp = [];\n  for (var i = 0; i < morphingData.length; i++) {\n    var item = morphingData[i];\n    var from = item.from;\n    var to = item.to;\n    var angle = item.rotation * t;\n    var fromCp = item.fromCp;\n    var toCp = item.toCp;\n    var sa = Math.sin(angle);\n    var ca = Math.cos(angle);\n    lerp(newCp, fromCp, toCp, t);\n    for (var m = 0; m < from.length; m += 2) {\n      var x0 = from[m];\n      var y0 = from[m + 1];\n      var x1 = to[m];\n      var y1 = to[m + 1];\n      var x = x0 * onet + x1 * t;\n      var y = y0 * onet + y1 * t;\n      tmpArr[m] = x * ca - y * sa + newCp[0];\n      tmpArr[m + 1] = x * sa + y * ca + newCp[1];\n    }\n    for (var m = 0; m < from.length;) {\n      if (m === 0) {\n        path.moveTo(tmpArr[m++], tmpArr[m++]);\n      }\n      path.bezierCurveTo(tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++]);\n    }\n  }\n}\n;\nfunction becomeIndividualMorphingPath(path, morphingData, morphT) {\n  if (isIndividualMorphingPath(path)) {\n    updateIndividualMorphingPath(path, morphingData, morphT);\n    return;\n  }\n  var morphingPath = path;\n  morphingPath.__oldBuildPath = morphingPath.buildPath;\n  morphingPath.buildPath = morphingPathBuildPath;\n  updateIndividualMorphingPath(morphingPath, morphingData, morphT);\n}\nfunction updateIndividualMorphingPath(morphingPath, morphingData, morphT) {\n  morphingPath.__morphingData = morphingData;\n  morphingPath.__morphT = morphT;\n}\nfunction restoreIndividualMorphingPath(path) {\n  if (isIndividualMorphingPath(path)) {\n    path.buildPath = path.__oldBuildPath;\n    path.__oldBuildPath = path.__morphingData = null;\n  }\n}\nfunction isIndividualMorphingPath(path) {\n  return path.__oldBuildPath != null;\n}\nexport function isCombiningPath(path) {\n  return !!path.__combiningSubList;\n}\nexport function isInAnyMorphing(path) {\n  return isIndividualMorphingPath(path) || isCombiningPath(path);\n}\nexport function combine(fromPathList, toPath, animationOpts, copyPropsIfDivided) {\n  var fromIndividuals = [];\n  var separateCount = 0;\n  for (var i = 0; i < fromPathList.length; i++) {\n    var fromPath = fromPathList[i];\n    if (isCombiningPath(fromPath)) {\n      var fromCombiningSubList = fromPath.__combiningSubList;\n      for (var j = 0; j < fromCombiningSubList.length; j++) {\n        fromIndividuals.push(fromCombiningSubList[j]);\n      }\n      separateCount += fromCombiningSubList.length;\n    } else {\n      fromIndividuals.push(fromPath);\n      separateCount++;\n    }\n  }\n  if (!separateCount) {\n    return;\n  }\n  var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n  var toPathSplittedList = divideShape(toPath, separateCount, dividingMethod);\n  assert(toPathSplittedList.length === separateCount);\n  var oldDone = animationOpts && animationOpts.done;\n  var oldAborted = animationOpts && animationOpts.aborted;\n  var oldDuring = animationOpts && animationOpts.during;\n  var doneCount = 0;\n  var abortedCalled = false;\n  var morphAnimationOpts = defaults({\n    during: function (p) {\n      oldDuring && oldDuring(p);\n    },\n    done: function () {\n      doneCount++;\n      if (doneCount === toPathSplittedList.length) {\n        restoreCombiningPath(toPath);\n        oldDone && oldDone();\n      }\n    },\n    aborted: function () {\n      if (!abortedCalled) {\n        abortedCalled = true;\n        oldAborted && oldAborted();\n      }\n    }\n  }, animationOpts);\n  for (var i = 0; i < separateCount; i++) {\n    var from = fromIndividuals[i];\n    var to = toPathSplittedList[i];\n    copyPropsIfDivided && copyPropsIfDivided(toPath, to, true);\n    morphPath(from, to, morphAnimationOpts);\n  }\n  becomeCombiningPath(toPath, toPathSplittedList);\n  return {\n    fromIndividuals: fromIndividuals,\n    toIndividuals: toPathSplittedList,\n    count: separateCount\n  };\n}\nfunction becomeCombiningPath(path, combiningSubList) {\n  if (isCombiningPath(path)) {\n    updateCombiningPathSubList(path, combiningSubList);\n    return;\n  }\n  var combiningPath = path;\n  updateCombiningPathSubList(combiningPath, combiningSubList);\n  combiningPath.__oldAddSelfToZr = path.addSelfToZr;\n  combiningPath.__oldRemoveSelfFromZr = path.removeSelfFromZr;\n  combiningPath.addSelfToZr = combiningAddSelfToZr;\n  combiningPath.removeSelfFromZr = combiningRemoveSelfFromZr;\n  combiningPath.__oldBuildPath = combiningPath.buildPath;\n  combiningPath.buildPath = noop;\n  combiningPath.childrenRef = combiningChildrenRef;\n}\nfunction restoreCombiningPath(path) {\n  if (!isCombiningPath(path)) {\n    return;\n  }\n  var combiningPath = path;\n  updateCombiningPathSubList(combiningPath, null);\n  combiningPath.addSelfToZr = combiningPath.__oldAddSelfToZr;\n  combiningPath.removeSelfFromZr = combiningPath.__oldRemoveSelfFromZr;\n  combiningPath.buildPath = combiningPath.__oldBuildPath;\n  combiningPath.childrenRef = combiningPath.__combiningSubList = combiningPath.__oldAddSelfToZr = combiningPath.__oldRemoveSelfFromZr = combiningPath.__oldBuildPath = null;\n}\nfunction updateCombiningPathSubList(combiningPath, combiningSubList) {\n  if (combiningPath.__combiningSubList !== combiningSubList) {\n    combiningPathSubListAddRemoveWithZr(combiningPath, 'removeSelfFromZr');\n    combiningPath.__combiningSubList = combiningSubList;\n    if (combiningSubList) {\n      for (var i = 0; i < combiningSubList.length; i++) {\n        combiningSubList[i].parent = combiningPath;\n      }\n    }\n    combiningPathSubListAddRemoveWithZr(combiningPath, 'addSelfToZr');\n  }\n}\nfunction combiningAddSelfToZr(zr) {\n  this.__oldAddSelfToZr(zr);\n  combiningPathSubListAddRemoveWithZr(this, 'addSelfToZr');\n}\nfunction combiningPathSubListAddRemoveWithZr(path, method) {\n  var combiningSubList = path.__combiningSubList;\n  var zr = path.__zr;\n  if (combiningSubList && zr) {\n    for (var i = 0; i < combiningSubList.length; i++) {\n      var child = combiningSubList[i];\n      child[method](zr);\n    }\n  }\n}\nfunction combiningRemoveSelfFromZr(zr) {\n  this.__oldRemoveSelfFromZr(zr);\n  var combiningSubList = this.__combiningSubList;\n  for (var i = 0; i < combiningSubList.length; i++) {\n    var child = combiningSubList[i];\n    child.removeSelfFromZr(zr);\n  }\n}\nfunction combiningChildrenRef() {\n  return this.__combiningSubList;\n}\nexport function separate(fromPath, toPathList, animationOpts, copyPropsIfDivided) {\n  var toPathListLen = toPathList.length;\n  var fromPathList;\n  var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n  var copyProps = false;\n  if (isCombiningPath(fromPath)) {\n    var fromCombiningSubList = fromPath.__combiningSubList;\n    if (fromCombiningSubList.length === toPathListLen) {\n      fromPathList = fromCombiningSubList;\n    } else {\n      fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n      copyProps = true;\n    }\n  } else {\n    fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n    copyProps = true;\n  }\n  assert(fromPathList.length === toPathListLen);\n  for (var i = 0; i < toPathListLen; i++) {\n    if (copyProps && copyPropsIfDivided) {\n      copyPropsIfDivided(fromPath, fromPathList[i], false);\n    }\n    morphPath(fromPathList[i], toPathList[i], animationOpts);\n  }\n  return {\n    fromIndividuals: fromPathList,\n    toIndividuals: toPathList,\n    count: toPathListLen\n  };\n}\nfunction divideShape(path, separateCount, dividingMethod) {\n  return dividingMethod === 'duplicate' ? duplicateShape(path, separateCount) : splitShape(path, separateCount);\n}\nfunction splitShape(path, separateCount) {\n  var resultPaths = [];\n  if (separateCount <= 0) {\n    return resultPaths;\n  }\n  if (separateCount === 1) {\n    return duplicateShape(path, separateCount);\n  }\n  if (path instanceof Rect) {\n    var toPathShape = path.shape;\n    var splitPropIdx = toPathShape.height > toPathShape.width ? 1 : 0;\n    var propWH = PROP_WH[splitPropIdx];\n    var propXY = PROP_XY[splitPropIdx];\n    var subWH = toPathShape[propWH] / separateCount;\n    var xyCurr = toPathShape[propXY];\n    for (var i = 0; i < separateCount; i++, xyCurr += subWH) {\n      var subShape = {\n        x: toPathShape.x,\n        y: toPathShape.y,\n        width: toPathShape.width,\n        height: toPathShape.height\n      };\n      subShape[propXY] = xyCurr;\n      subShape[propWH] = i < separateCount - 1 ? subWH : toPathShape[propXY] + toPathShape[propWH] - xyCurr;\n      var splitted = new Rect({\n        shape: subShape\n      });\n      resultPaths.push(splitted);\n    }\n  } else if (path instanceof Sector) {\n    var toPathShape = path.shape;\n    var clockwise = toPathShape.clockwise;\n    var startAngle = toPathShape.startAngle;\n    var endAngle = toPathShape.endAngle;\n    var endAngleNormalized = normalizeRadian(startAngle, toPathShape.endAngle, clockwise);\n    var step = (endAngleNormalized - startAngle) / separateCount;\n    var angleCurr = startAngle;\n    for (var i = 0; i < separateCount; i++, angleCurr += step) {\n      var splitted = new Sector({\n        shape: {\n          cx: toPathShape.cx,\n          cy: toPathShape.cy,\n          r: toPathShape.r,\n          r0: toPathShape.r0,\n          clockwise: clockwise,\n          startAngle: angleCurr,\n          endAngle: i === separateCount - 1 ? endAngle : angleCurr + step\n        }\n      });\n      resultPaths.push(splitted);\n    }\n  } else {\n    return duplicateShape(path, separateCount);\n  }\n  return resultPaths;\n}\nfunction duplicateShape(path, separateCount) {\n  var resultPaths = [];\n  if (separateCount <= 0) {\n    return resultPaths;\n  }\n  var ctor = path.constructor;\n  for (var i = 0; i < separateCount; i++) {\n    var sub = new ctor({\n      shape: clone(path.shape)\n    });\n    resultPaths.push(sub);\n  }\n  return resultPaths;\n}\nfunction normalizeRadian(start, end, clockwise) {\n  return end + PI2 * Math[clockwise ? 'ceil' : 'floor']((start - end) / PI2);\n}","map":{"version":3,"names":["PathProxy","cubicSubdivide","defaults","assert","noop","clone","lerp","Rect","Sector","CMD","PI2","Math","PI","PROP_XY","PROP_WH","tmpArr","aroundEqual","a","b","abs","pathToBezierCurves","path","data","len","bezierArray","currentSubpath","xi","yi","x0","y0","createNewSubpath","x","y","length","push","addLine","x1","y1","addArc","startAngle","endAngle","cx","cy","rx","ry","delta","tan","dir","c1","cos","s1","sin","c2","s2","x4","y4","hx","hy","x2","y2","i","cmd","isFirst","L","C","Q","M","A","anticlockwise","step","angle","nextAngle","max","min","R","Z","alignSubpath","subpath1","subpath2","len1","len2","shorterPath","shorterLen","diff","shorterBezierCount","eachCurveSubDivCount","ceil","newSubpath","remained","tmpSegX","tmpSegY","x3","y3","actualSubDivCount","k","p","createSubpath","lastSubpathSubpath","otherSubpath","lastX","lastY","alignBezierCurves","array1","array2","_a","lastSubpath1","lastSubpath2","newArray1","newArray2","newSubpath1","newSubpath2","centroid","array","signedArea","j","findBestRingOffset","fromSubBeziers","toSubBeziers","fromCp","toCp","bezierCount","bestScore","Infinity","bestOffset","offset","cursorOffset","score","idx","dx","dy","reverse","newArr","findBestMorphingRotation","fromArr","toArr","searchAngleIteration","searchAngleRange","result","fromNeedsReverse","fromSubpathBezier","toSubpathBezier","newFromSubpathBezier","newToSubpathBezier","bestAngle","tmpArr_1","sa","ca","newX1","newY1","m","i_1","from","to","rotation","morphPath","fromPath","toPath","animationOpts","fromPathProxy","toPathProxy","createPathProxy","beginPath","buildPath","shape","isIndividualMorphingPath","__oldBuildPath","fromBezierCurves","toBezierCurves","morphingData","becomeIndividualMorphingPath","oldDone","done","oldAborted","aborted","oldDuring","during","animateTo","__morphT","dirtyShape","restoreIndividualMorphingPath","morphingPathBuildPath","__morphingData","t","onet","newCp","item","moveTo","bezierCurveTo","morphT","updateIndividualMorphingPath","morphingPath","isCombiningPath","__combiningSubList","isInAnyMorphing","combine","fromPathList","copyPropsIfDivided","fromIndividuals","separateCount","fromCombiningSubList","dividingMethod","toPathSplittedList","divideShape","doneCount","abortedCalled","morphAnimationOpts","restoreCombiningPath","becomeCombiningPath","toIndividuals","count","combiningSubList","updateCombiningPathSubList","combiningPath","__oldAddSelfToZr","addSelfToZr","__oldRemoveSelfFromZr","removeSelfFromZr","combiningAddSelfToZr","combiningRemoveSelfFromZr","childrenRef","combiningChildrenRef","combiningPathSubListAddRemoveWithZr","parent","zr","method","__zr","child","separate","toPathList","toPathListLen","copyProps","duplicateShape","splitShape","resultPaths","toPathShape","splitPropIdx","height","width","propWH","propXY","subWH","xyCurr","subShape","splitted","clockwise","endAngleNormalized","normalizeRadian","angleCurr","r","r0","ctor","constructor","sub","start","end"],"sources":["/Users/jiong/Downloads/my-app/node_modules/zrender/lib/tool/morphPath.js"],"sourcesContent":["import PathProxy from '../core/PathProxy';\nimport { cubicSubdivide } from '../core/curve';\nimport { defaults, assert, noop, clone } from '../core/util';\nimport { lerp } from '../core/vector';\nimport Rect from '../graphic/shape/Rect';\nimport Sector from '../graphic/shape/Sector';\nvar CMD = PathProxy.CMD;\nvar PI2 = Math.PI * 2;\nvar PROP_XY = ['x', 'y'];\nvar PROP_WH = ['width', 'height'];\nvar tmpArr = [];\nfunction aroundEqual(a, b) {\n    return Math.abs(a - b) < 1e-5;\n}\nexport function pathToBezierCurves(path) {\n    var data = path.data;\n    var len = path.len();\n    var bezierArray = [];\n    var currentSubpath;\n    var xi = 0;\n    var yi = 0;\n    var x0 = 0;\n    var y0 = 0;\n    function createNewSubpath(x, y) {\n        if (currentSubpath && currentSubpath.length > 2) {\n            bezierArray.push(currentSubpath);\n        }\n        currentSubpath = [x, y];\n    }\n    function addLine(x0, y0, x1, y1) {\n        if (!(aroundEqual(x0, x1) && aroundEqual(y0, y1))) {\n            currentSubpath.push(x0, y0, x1, y1, x1, y1);\n        }\n    }\n    function addArc(startAngle, endAngle, cx, cy, rx, ry) {\n        var delta = Math.abs(endAngle - startAngle);\n        var len = Math.tan(delta / 4) * 4 / 3;\n        var dir = endAngle < startAngle ? -1 : 1;\n        var c1 = Math.cos(startAngle);\n        var s1 = Math.sin(startAngle);\n        var c2 = Math.cos(endAngle);\n        var s2 = Math.sin(endAngle);\n        var x1 = c1 * rx + cx;\n        var y1 = s1 * ry + cy;\n        var x4 = c2 * rx + cx;\n        var y4 = s2 * ry + cy;\n        var hx = rx * len * dir;\n        var hy = ry * len * dir;\n        currentSubpath.push(x1 - hx * s1, y1 + hy * c1, x4 + hx * s2, y4 - hy * c2, x4, y4);\n    }\n    var x1;\n    var y1;\n    var x2;\n    var y2;\n    for (var i = 0; i < len;) {\n        var cmd = data[i++];\n        var isFirst = i === 1;\n        if (isFirst) {\n            xi = data[i];\n            yi = data[i + 1];\n            x0 = xi;\n            y0 = yi;\n            if (cmd === CMD.L || cmd === CMD.C || cmd === CMD.Q) {\n                currentSubpath = [x0, y0];\n            }\n        }\n        switch (cmd) {\n            case CMD.M:\n                xi = x0 = data[i++];\n                yi = y0 = data[i++];\n                createNewSubpath(x0, y0);\n                break;\n            case CMD.L:\n                x1 = data[i++];\n                y1 = data[i++];\n                addLine(xi, yi, x1, y1);\n                xi = x1;\n                yi = y1;\n                break;\n            case CMD.C:\n                currentSubpath.push(data[i++], data[i++], data[i++], data[i++], xi = data[i++], yi = data[i++]);\n                break;\n            case CMD.Q:\n                x1 = data[i++];\n                y1 = data[i++];\n                x2 = data[i++];\n                y2 = data[i++];\n                currentSubpath.push(xi + 2 / 3 * (x1 - xi), yi + 2 / 3 * (y1 - yi), x2 + 2 / 3 * (x1 - x2), y2 + 2 / 3 * (y1 - y2), x2, y2);\n                xi = x2;\n                yi = y2;\n                break;\n            case CMD.A:\n                var cx = data[i++];\n                var cy = data[i++];\n                var rx = data[i++];\n                var ry = data[i++];\n                var startAngle = data[i++];\n                var endAngle = data[i++] + startAngle;\n                i += 1;\n                var anticlockwise = !data[i++];\n                x1 = Math.cos(startAngle) * rx + cx;\n                y1 = Math.sin(startAngle) * ry + cy;\n                if (isFirst) {\n                    x0 = x1;\n                    y0 = y1;\n                    createNewSubpath(x0, y0);\n                }\n                else {\n                    addLine(xi, yi, x1, y1);\n                }\n                xi = Math.cos(endAngle) * rx + cx;\n                yi = Math.sin(endAngle) * ry + cy;\n                var step = (anticlockwise ? -1 : 1) * Math.PI / 2;\n                for (var angle = startAngle; anticlockwise ? angle > endAngle : angle < endAngle; angle += step) {\n                    var nextAngle = anticlockwise ? Math.max(angle + step, endAngle)\n                        : Math.min(angle + step, endAngle);\n                    addArc(angle, nextAngle, cx, cy, rx, ry);\n                }\n                break;\n            case CMD.R:\n                x0 = xi = data[i++];\n                y0 = yi = data[i++];\n                x1 = x0 + data[i++];\n                y1 = y0 + data[i++];\n                createNewSubpath(x1, y0);\n                addLine(x1, y0, x1, y1);\n                addLine(x1, y1, x0, y1);\n                addLine(x0, y1, x0, y0);\n                addLine(x0, y0, x1, y0);\n                break;\n            case CMD.Z:\n                currentSubpath && addLine(xi, yi, x0, y0);\n                xi = x0;\n                yi = y0;\n                break;\n        }\n    }\n    if (currentSubpath && currentSubpath.length > 2) {\n        bezierArray.push(currentSubpath);\n    }\n    return bezierArray;\n}\nfunction alignSubpath(subpath1, subpath2) {\n    var len1 = subpath1.length;\n    var len2 = subpath2.length;\n    if (len1 === len2) {\n        return [subpath1, subpath2];\n    }\n    var shorterPath = len1 < len2 ? subpath1 : subpath2;\n    var shorterLen = Math.min(len1, len2);\n    var diff = Math.abs(len2 - len1) / 6;\n    var shorterBezierCount = (shorterLen - 2) / 6;\n    var eachCurveSubDivCount = Math.ceil(diff / shorterBezierCount) + 1;\n    var newSubpath = [shorterPath[0], shorterPath[1]];\n    var remained = diff;\n    var tmpSegX = [];\n    var tmpSegY = [];\n    for (var i = 2; i < shorterLen;) {\n        var x0 = shorterPath[i - 2];\n        var y0 = shorterPath[i - 1];\n        var x1 = shorterPath[i++];\n        var y1 = shorterPath[i++];\n        var x2 = shorterPath[i++];\n        var y2 = shorterPath[i++];\n        var x3 = shorterPath[i++];\n        var y3 = shorterPath[i++];\n        if (remained <= 0) {\n            newSubpath.push(x1, y1, x2, y2, x3, y3);\n            continue;\n        }\n        var actualSubDivCount = Math.min(remained, eachCurveSubDivCount - 1) + 1;\n        for (var k = 1; k <= actualSubDivCount; k++) {\n            var p = k / actualSubDivCount;\n            cubicSubdivide(x0, x1, x2, x3, p, tmpSegX);\n            cubicSubdivide(y0, y1, y2, y3, p, tmpSegY);\n            x0 = tmpSegX[3];\n            y0 = tmpSegY[3];\n            newSubpath.push(tmpSegX[1], tmpSegY[1], tmpSegX[2], tmpSegY[2], x0, y0);\n            x1 = tmpSegX[5];\n            y1 = tmpSegY[5];\n            x2 = tmpSegX[6];\n            y2 = tmpSegY[6];\n        }\n        remained -= actualSubDivCount - 1;\n    }\n    return shorterPath === subpath1 ? [newSubpath, subpath2] : [subpath1, newSubpath];\n}\nfunction createSubpath(lastSubpathSubpath, otherSubpath) {\n    var len = lastSubpathSubpath.length;\n    var lastX = lastSubpathSubpath[len - 2];\n    var lastY = lastSubpathSubpath[len - 1];\n    var newSubpath = [];\n    for (var i = 0; i < otherSubpath.length;) {\n        newSubpath[i++] = lastX;\n        newSubpath[i++] = lastY;\n    }\n    return newSubpath;\n}\nexport function alignBezierCurves(array1, array2) {\n    var _a;\n    var lastSubpath1;\n    var lastSubpath2;\n    var newArray1 = [];\n    var newArray2 = [];\n    for (var i = 0; i < Math.max(array1.length, array2.length); i++) {\n        var subpath1 = array1[i];\n        var subpath2 = array2[i];\n        var newSubpath1 = void 0;\n        var newSubpath2 = void 0;\n        if (!subpath1) {\n            newSubpath1 = createSubpath(lastSubpath1 || subpath2, subpath2);\n            newSubpath2 = subpath2;\n        }\n        else if (!subpath2) {\n            newSubpath2 = createSubpath(lastSubpath2 || subpath1, subpath1);\n            newSubpath1 = subpath1;\n        }\n        else {\n            _a = alignSubpath(subpath1, subpath2), newSubpath1 = _a[0], newSubpath2 = _a[1];\n            lastSubpath1 = newSubpath1;\n            lastSubpath2 = newSubpath2;\n        }\n        newArray1.push(newSubpath1);\n        newArray2.push(newSubpath2);\n    }\n    return [newArray1, newArray2];\n}\nexport function centroid(array) {\n    var signedArea = 0;\n    var cx = 0;\n    var cy = 0;\n    var len = array.length;\n    for (var i = 0, j = len - 2; i < len; j = i, i += 2) {\n        var x0 = array[j];\n        var y0 = array[j + 1];\n        var x1 = array[i];\n        var y1 = array[i + 1];\n        var a = x0 * y1 - x1 * y0;\n        signedArea += a;\n        cx += (x0 + x1) * a;\n        cy += (y0 + y1) * a;\n    }\n    if (signedArea === 0) {\n        return [array[0] || 0, array[1] || 0];\n    }\n    return [cx / signedArea / 3, cy / signedArea / 3, signedArea];\n}\nfunction findBestRingOffset(fromSubBeziers, toSubBeziers, fromCp, toCp) {\n    var bezierCount = (fromSubBeziers.length - 2) / 6;\n    var bestScore = Infinity;\n    var bestOffset = 0;\n    var len = fromSubBeziers.length;\n    var len2 = len - 2;\n    for (var offset = 0; offset < bezierCount; offset++) {\n        var cursorOffset = offset * 6;\n        var score = 0;\n        for (var k = 0; k < len; k += 2) {\n            var idx = k === 0 ? cursorOffset : ((cursorOffset + k - 2) % len2 + 2);\n            var x0 = fromSubBeziers[idx] - fromCp[0];\n            var y0 = fromSubBeziers[idx + 1] - fromCp[1];\n            var x1 = toSubBeziers[k] - toCp[0];\n            var y1 = toSubBeziers[k + 1] - toCp[1];\n            var dx = x1 - x0;\n            var dy = y1 - y0;\n            score += dx * dx + dy * dy;\n        }\n        if (score < bestScore) {\n            bestScore = score;\n            bestOffset = offset;\n        }\n    }\n    return bestOffset;\n}\nfunction reverse(array) {\n    var newArr = [];\n    var len = array.length;\n    for (var i = 0; i < len; i += 2) {\n        newArr[i] = array[len - i - 2];\n        newArr[i + 1] = array[len - i - 1];\n    }\n    return newArr;\n}\nfunction findBestMorphingRotation(fromArr, toArr, searchAngleIteration, searchAngleRange) {\n    var result = [];\n    var fromNeedsReverse;\n    for (var i = 0; i < fromArr.length; i++) {\n        var fromSubpathBezier = fromArr[i];\n        var toSubpathBezier = toArr[i];\n        var fromCp = centroid(fromSubpathBezier);\n        var toCp = centroid(toSubpathBezier);\n        if (fromNeedsReverse == null) {\n            fromNeedsReverse = fromCp[2] < 0 !== toCp[2] < 0;\n        }\n        var newFromSubpathBezier = [];\n        var newToSubpathBezier = [];\n        var bestAngle = 0;\n        var bestScore = Infinity;\n        var tmpArr_1 = [];\n        var len = fromSubpathBezier.length;\n        if (fromNeedsReverse) {\n            fromSubpathBezier = reverse(fromSubpathBezier);\n        }\n        var offset = findBestRingOffset(fromSubpathBezier, toSubpathBezier, fromCp, toCp) * 6;\n        var len2 = len - 2;\n        for (var k = 0; k < len2; k += 2) {\n            var idx = (offset + k) % len2 + 2;\n            newFromSubpathBezier[k + 2] = fromSubpathBezier[idx] - fromCp[0];\n            newFromSubpathBezier[k + 3] = fromSubpathBezier[idx + 1] - fromCp[1];\n        }\n        newFromSubpathBezier[0] = fromSubpathBezier[offset] - fromCp[0];\n        newFromSubpathBezier[1] = fromSubpathBezier[offset + 1] - fromCp[1];\n        if (searchAngleIteration > 0) {\n            var step = searchAngleRange / searchAngleIteration;\n            for (var angle = -searchAngleRange / 2; angle <= searchAngleRange / 2; angle += step) {\n                var sa = Math.sin(angle);\n                var ca = Math.cos(angle);\n                var score = 0;\n                for (var k = 0; k < fromSubpathBezier.length; k += 2) {\n                    var x0 = newFromSubpathBezier[k];\n                    var y0 = newFromSubpathBezier[k + 1];\n                    var x1 = toSubpathBezier[k] - toCp[0];\n                    var y1 = toSubpathBezier[k + 1] - toCp[1];\n                    var newX1 = x1 * ca - y1 * sa;\n                    var newY1 = x1 * sa + y1 * ca;\n                    tmpArr_1[k] = newX1;\n                    tmpArr_1[k + 1] = newY1;\n                    var dx = newX1 - x0;\n                    var dy = newY1 - y0;\n                    score += dx * dx + dy * dy;\n                }\n                if (score < bestScore) {\n                    bestScore = score;\n                    bestAngle = angle;\n                    for (var m = 0; m < tmpArr_1.length; m++) {\n                        newToSubpathBezier[m] = tmpArr_1[m];\n                    }\n                }\n            }\n        }\n        else {\n            for (var i_1 = 0; i_1 < len; i_1 += 2) {\n                newToSubpathBezier[i_1] = toSubpathBezier[i_1] - toCp[0];\n                newToSubpathBezier[i_1 + 1] = toSubpathBezier[i_1 + 1] - toCp[1];\n            }\n        }\n        result.push({\n            from: newFromSubpathBezier,\n            to: newToSubpathBezier,\n            fromCp: fromCp,\n            toCp: toCp,\n            rotation: -bestAngle\n        });\n    }\n    return result;\n}\nexport function morphPath(fromPath, toPath, animationOpts) {\n    var fromPathProxy;\n    var toPathProxy;\n    if (!fromPath || !toPath) {\n        return toPath;\n    }\n    !fromPath.path && fromPath.createPathProxy();\n    fromPathProxy = fromPath.path;\n    fromPathProxy.beginPath();\n    fromPath.buildPath(fromPathProxy, fromPath.shape);\n    !toPath.path && toPath.createPathProxy();\n    toPathProxy = toPath.path;\n    toPathProxy === fromPathProxy && (toPathProxy = new PathProxy(false));\n    toPathProxy.beginPath();\n    if (isIndividualMorphingPath(toPath)) {\n        toPath.__oldBuildPath(toPathProxy, toPath.shape);\n    }\n    else {\n        toPath.buildPath(toPathProxy, toPath.shape);\n    }\n    var _a = alignBezierCurves(pathToBezierCurves(fromPathProxy), pathToBezierCurves(toPathProxy)), fromBezierCurves = _a[0], toBezierCurves = _a[1];\n    var morphingData = findBestMorphingRotation(fromBezierCurves, toBezierCurves, 10, Math.PI);\n    becomeIndividualMorphingPath(toPath, morphingData, 0);\n    var oldDone = animationOpts && animationOpts.done;\n    var oldAborted = animationOpts && animationOpts.aborted;\n    var oldDuring = animationOpts && animationOpts.during;\n    toPath.animateTo({\n        __morphT: 1\n    }, defaults({\n        during: function (p) {\n            toPath.dirtyShape();\n            oldDuring && oldDuring(p);\n        },\n        done: function () {\n            restoreIndividualMorphingPath(toPath);\n            toPath.createPathProxy();\n            toPath.dirtyShape();\n            oldDone && oldDone();\n        },\n        aborted: function () {\n            oldAborted && oldAborted();\n        }\n    }, animationOpts));\n    return toPath;\n}\nfunction morphingPathBuildPath(path) {\n    var morphingData = this.__morphingData;\n    var t = this.__morphT;\n    var onet = 1 - t;\n    var newCp = [];\n    for (var i = 0; i < morphingData.length; i++) {\n        var item = morphingData[i];\n        var from = item.from;\n        var to = item.to;\n        var angle = item.rotation * t;\n        var fromCp = item.fromCp;\n        var toCp = item.toCp;\n        var sa = Math.sin(angle);\n        var ca = Math.cos(angle);\n        lerp(newCp, fromCp, toCp, t);\n        for (var m = 0; m < from.length; m += 2) {\n            var x0 = from[m];\n            var y0 = from[m + 1];\n            var x1 = to[m];\n            var y1 = to[m + 1];\n            var x = x0 * onet + x1 * t;\n            var y = y0 * onet + y1 * t;\n            tmpArr[m] = (x * ca - y * sa) + newCp[0];\n            tmpArr[m + 1] = (x * sa + y * ca) + newCp[1];\n        }\n        for (var m = 0; m < from.length;) {\n            if (m === 0) {\n                path.moveTo(tmpArr[m++], tmpArr[m++]);\n            }\n            path.bezierCurveTo(tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++], tmpArr[m++]);\n        }\n    }\n}\n;\nfunction becomeIndividualMorphingPath(path, morphingData, morphT) {\n    if (isIndividualMorphingPath(path)) {\n        updateIndividualMorphingPath(path, morphingData, morphT);\n        return;\n    }\n    var morphingPath = path;\n    morphingPath.__oldBuildPath = morphingPath.buildPath;\n    morphingPath.buildPath = morphingPathBuildPath;\n    updateIndividualMorphingPath(morphingPath, morphingData, morphT);\n}\nfunction updateIndividualMorphingPath(morphingPath, morphingData, morphT) {\n    morphingPath.__morphingData = morphingData;\n    morphingPath.__morphT = morphT;\n}\nfunction restoreIndividualMorphingPath(path) {\n    if (isIndividualMorphingPath(path)) {\n        path.buildPath = path.__oldBuildPath;\n        path.__oldBuildPath = path.__morphingData = null;\n    }\n}\nfunction isIndividualMorphingPath(path) {\n    return path.__oldBuildPath != null;\n}\nexport function isCombiningPath(path) {\n    return !!path.__combiningSubList;\n}\nexport function isInAnyMorphing(path) {\n    return isIndividualMorphingPath(path) || isCombiningPath(path);\n}\nexport function combine(fromPathList, toPath, animationOpts, copyPropsIfDivided) {\n    var fromIndividuals = [];\n    var separateCount = 0;\n    for (var i = 0; i < fromPathList.length; i++) {\n        var fromPath = fromPathList[i];\n        if (isCombiningPath(fromPath)) {\n            var fromCombiningSubList = fromPath.__combiningSubList;\n            for (var j = 0; j < fromCombiningSubList.length; j++) {\n                fromIndividuals.push(fromCombiningSubList[j]);\n            }\n            separateCount += fromCombiningSubList.length;\n        }\n        else {\n            fromIndividuals.push(fromPath);\n            separateCount++;\n        }\n    }\n    if (!separateCount) {\n        return;\n    }\n    var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n    var toPathSplittedList = divideShape(toPath, separateCount, dividingMethod);\n    assert(toPathSplittedList.length === separateCount);\n    var oldDone = animationOpts && animationOpts.done;\n    var oldAborted = animationOpts && animationOpts.aborted;\n    var oldDuring = animationOpts && animationOpts.during;\n    var doneCount = 0;\n    var abortedCalled = false;\n    var morphAnimationOpts = defaults({\n        during: function (p) {\n            oldDuring && oldDuring(p);\n        },\n        done: function () {\n            doneCount++;\n            if (doneCount === toPathSplittedList.length) {\n                restoreCombiningPath(toPath);\n                oldDone && oldDone();\n            }\n        },\n        aborted: function () {\n            if (!abortedCalled) {\n                abortedCalled = true;\n                oldAborted && oldAborted();\n            }\n        }\n    }, animationOpts);\n    for (var i = 0; i < separateCount; i++) {\n        var from = fromIndividuals[i];\n        var to = toPathSplittedList[i];\n        copyPropsIfDivided && copyPropsIfDivided(toPath, to, true);\n        morphPath(from, to, morphAnimationOpts);\n    }\n    becomeCombiningPath(toPath, toPathSplittedList);\n    return {\n        fromIndividuals: fromIndividuals,\n        toIndividuals: toPathSplittedList,\n        count: separateCount\n    };\n}\nfunction becomeCombiningPath(path, combiningSubList) {\n    if (isCombiningPath(path)) {\n        updateCombiningPathSubList(path, combiningSubList);\n        return;\n    }\n    var combiningPath = path;\n    updateCombiningPathSubList(combiningPath, combiningSubList);\n    combiningPath.__oldAddSelfToZr = path.addSelfToZr;\n    combiningPath.__oldRemoveSelfFromZr = path.removeSelfFromZr;\n    combiningPath.addSelfToZr = combiningAddSelfToZr;\n    combiningPath.removeSelfFromZr = combiningRemoveSelfFromZr;\n    combiningPath.__oldBuildPath = combiningPath.buildPath;\n    combiningPath.buildPath = noop;\n    combiningPath.childrenRef = combiningChildrenRef;\n}\nfunction restoreCombiningPath(path) {\n    if (!isCombiningPath(path)) {\n        return;\n    }\n    var combiningPath = path;\n    updateCombiningPathSubList(combiningPath, null);\n    combiningPath.addSelfToZr = combiningPath.__oldAddSelfToZr;\n    combiningPath.removeSelfFromZr = combiningPath.__oldRemoveSelfFromZr;\n    combiningPath.buildPath = combiningPath.__oldBuildPath;\n    combiningPath.childrenRef =\n        combiningPath.__combiningSubList =\n            combiningPath.__oldAddSelfToZr =\n                combiningPath.__oldRemoveSelfFromZr =\n                    combiningPath.__oldBuildPath = null;\n}\nfunction updateCombiningPathSubList(combiningPath, combiningSubList) {\n    if (combiningPath.__combiningSubList !== combiningSubList) {\n        combiningPathSubListAddRemoveWithZr(combiningPath, 'removeSelfFromZr');\n        combiningPath.__combiningSubList = combiningSubList;\n        if (combiningSubList) {\n            for (var i = 0; i < combiningSubList.length; i++) {\n                combiningSubList[i].parent = combiningPath;\n            }\n        }\n        combiningPathSubListAddRemoveWithZr(combiningPath, 'addSelfToZr');\n    }\n}\nfunction combiningAddSelfToZr(zr) {\n    this.__oldAddSelfToZr(zr);\n    combiningPathSubListAddRemoveWithZr(this, 'addSelfToZr');\n}\nfunction combiningPathSubListAddRemoveWithZr(path, method) {\n    var combiningSubList = path.__combiningSubList;\n    var zr = path.__zr;\n    if (combiningSubList && zr) {\n        for (var i = 0; i < combiningSubList.length; i++) {\n            var child = combiningSubList[i];\n            child[method](zr);\n        }\n    }\n}\nfunction combiningRemoveSelfFromZr(zr) {\n    this.__oldRemoveSelfFromZr(zr);\n    var combiningSubList = this.__combiningSubList;\n    for (var i = 0; i < combiningSubList.length; i++) {\n        var child = combiningSubList[i];\n        child.removeSelfFromZr(zr);\n    }\n}\nfunction combiningChildrenRef() {\n    return this.__combiningSubList;\n}\nexport function separate(fromPath, toPathList, animationOpts, copyPropsIfDivided) {\n    var toPathListLen = toPathList.length;\n    var fromPathList;\n    var dividingMethod = animationOpts ? animationOpts.dividingMethod : null;\n    var copyProps = false;\n    if (isCombiningPath(fromPath)) {\n        var fromCombiningSubList = fromPath.__combiningSubList;\n        if (fromCombiningSubList.length === toPathListLen) {\n            fromPathList = fromCombiningSubList;\n        }\n        else {\n            fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n            copyProps = true;\n        }\n    }\n    else {\n        fromPathList = divideShape(fromPath, toPathListLen, dividingMethod);\n        copyProps = true;\n    }\n    assert(fromPathList.length === toPathListLen);\n    for (var i = 0; i < toPathListLen; i++) {\n        if (copyProps && copyPropsIfDivided) {\n            copyPropsIfDivided(fromPath, fromPathList[i], false);\n        }\n        morphPath(fromPathList[i], toPathList[i], animationOpts);\n    }\n    return {\n        fromIndividuals: fromPathList,\n        toIndividuals: toPathList,\n        count: toPathListLen\n    };\n}\nfunction divideShape(path, separateCount, dividingMethod) {\n    return dividingMethod === 'duplicate'\n        ? duplicateShape(path, separateCount)\n        : splitShape(path, separateCount);\n}\nfunction splitShape(path, separateCount) {\n    var resultPaths = [];\n    if (separateCount <= 0) {\n        return resultPaths;\n    }\n    if (separateCount === 1) {\n        return duplicateShape(path, separateCount);\n    }\n    if (path instanceof Rect) {\n        var toPathShape = path.shape;\n        var splitPropIdx = toPathShape.height > toPathShape.width ? 1 : 0;\n        var propWH = PROP_WH[splitPropIdx];\n        var propXY = PROP_XY[splitPropIdx];\n        var subWH = toPathShape[propWH] / separateCount;\n        var xyCurr = toPathShape[propXY];\n        for (var i = 0; i < separateCount; i++, xyCurr += subWH) {\n            var subShape = {\n                x: toPathShape.x,\n                y: toPathShape.y,\n                width: toPathShape.width,\n                height: toPathShape.height\n            };\n            subShape[propXY] = xyCurr;\n            subShape[propWH] = i < separateCount - 1\n                ? subWH\n                : toPathShape[propXY] + toPathShape[propWH] - xyCurr;\n            var splitted = new Rect({ shape: subShape });\n            resultPaths.push(splitted);\n        }\n    }\n    else if (path instanceof Sector) {\n        var toPathShape = path.shape;\n        var clockwise = toPathShape.clockwise;\n        var startAngle = toPathShape.startAngle;\n        var endAngle = toPathShape.endAngle;\n        var endAngleNormalized = normalizeRadian(startAngle, toPathShape.endAngle, clockwise);\n        var step = (endAngleNormalized - startAngle) / separateCount;\n        var angleCurr = startAngle;\n        for (var i = 0; i < separateCount; i++, angleCurr += step) {\n            var splitted = new Sector({\n                shape: {\n                    cx: toPathShape.cx,\n                    cy: toPathShape.cy,\n                    r: toPathShape.r,\n                    r0: toPathShape.r0,\n                    clockwise: clockwise,\n                    startAngle: angleCurr,\n                    endAngle: i === separateCount - 1 ? endAngle : angleCurr + step\n                }\n            });\n            resultPaths.push(splitted);\n        }\n    }\n    else {\n        return duplicateShape(path, separateCount);\n    }\n    return resultPaths;\n}\nfunction duplicateShape(path, separateCount) {\n    var resultPaths = [];\n    if (separateCount <= 0) {\n        return resultPaths;\n    }\n    var ctor = path.constructor;\n    for (var i = 0; i < separateCount; i++) {\n        var sub = new ctor({\n            shape: clone(path.shape)\n        });\n        resultPaths.push(sub);\n    }\n    return resultPaths;\n}\nfunction normalizeRadian(start, end, clockwise) {\n    return end + PI2 * (Math[clockwise ? 'ceil' : 'floor']((start - end) / PI2));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}